Microsoft (R) Macro Assembler Version 6.14.8444		    07/19/22 20:22:34
unix.asm						     Page 1 - 1


				; ****************************************************************************
				; UNIX.ASM (RETRO UNIX 8086 Kernel v0.1.0.4) - (Only for 1.44 MB floppy disks)
				; ----------------------------------------------------------------------------
				;
				; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
				; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
				; 1.44 MB Floppy Disk 
				; (11/03/2013)
				;
				; [ Last Modification: 19/07/2022 ] ; 2022 modification (previous: 29/06/2022)
				;
				; Derivation from UNIX Operating System (v1.0 for PDP-11) 
				; (Original) Source Code by Ken Thompson (1971-1972)
				; <Bell Laboratories (17/3/1972)>
				; <Preliminary Release of UNIX Implementation Document>
				;
				; ****************************************************************************
				; 27/01/2022 - 19/07/2022
				; Assembler: MASM 6.14
				;	masm unix.asm, unix.obj, unix.lst
				;	link /t unix.obj

				; 15/07/2022
				; 15/05/2022, 02/06/2022, 13/06/2022, 14/06/2022, 26/06/2022, 29/06/2022
				; 04/04/2022, 22/04/2022, 29/04/2022, 09/05/2022, 10/05/2022, 11/05/2022	
				; 28/08/2014, 01/09/2014, 16/07/2015, 04/02/2022, 03/03/2022, 30/03/2022
				; 20/07/2014, 21/07/2014, 23/07/2014, 24/07/2014, 27/07/2014, 28/07/2014
				; 05/07/2014, 07/07/2014, 08/07/2014, 09/07/2014, 12/07/2014, 18/07/2014
				; 26/06/2014, 27/06/2014, 30/06/2014, 01/07/2014, 03/07/2014, 04/07/2014
				; 31/05/2014, 02/06/2014, 03/06/2014, 11/06/2014, 23/06/2014, 25/06/2014
				; 05/05/2014, 19/05/2014, 20/05/2014, 22/05/2014, 26/05/2014, 30/05/2014
				; 17/04/2014, 22/04/2014, 25/04/2014, 29/04/2014, 30/04/2014, 01/05/2014
				; 24/03/2014, 04/04/2014, 10/04/2014, 11/04/2014, 14/04/2014, 15/04/2014
				; 04/03/2014, 07/03/2014, 08/03/2014, 12/03/2014, 18/03/2014, 20/03/2014	
				; 14/02/2014, 17/02/2014, 23/02/2014, 25/02/2014, 28/02/2014, 03/03/2014
				; 18/01/2014, 20/01/2014, 21/01/2014, 26/01/2014, 01/02/2014, 05/02/2014
				; 10/01/2014, 12/01/2014, 13/01/2014, 14/01/2014, 16/01/2014, 17/01/2014
				; 03/12/2013, 04/12/2013, 06/12/2013, 07/12/2013, 10/12/2013, 12/12/2013		
				; 24/10/2013, 30/10/2013, 04/11/2013, 18/11/2013, 19/11/2013, 30/11/2013
				; 22/09/2013, 24/09/2013, 05/10/2013, 10/10/2013, 20/10/2013, 23/10/2013	
				; 30/08/2013, 26/08/2013, 03/09/2013, 13/09/2013, 17/09/2013, 20/09/2013	
				; 18/08/2013, 16/08/2013, 14/08/2013, 13/08/2013, 12/08/2013, 11/08/2013
				; 09/08/2013, 08/08/2013, 05/08/2013, 03/08/2013, 02/08/2013, 01/08/2013
				; 31/07/2013 user/u structure (u.rw and u.namei_r has been removed)
				; 30/07/2013, 29/07/2013
				; 28/07/2013 u.rw, u.namei_r, u.ttyn, u.errn
				; 26/07/2013, 25/07/2013, 24/07/2013, 17/07/2013, 16/07/2013, 14/07/2013
				; 13/07/2013 kernel initialization additions & modifications
				; 09/07/2013
				; 20/06/2013 set date & time (for 'sysstime' system call)
				; 04/06/2013 ecore (sysexec) 
				; 03/06/2013 p_time (systime, sysmdate)
				; 26/05/2013
				; 24/05/2013 (end of core)
				; 21/05/2013 com_stat: owner and status of COM/serial port (1&2)
				; 10/05/2013 tty modifications (keyboard functions)
				; 26/04/2013 device numbers, structure modifications
				; 11/03/2013

				; 30/01/2022 - compact kernel (moving buffers to bss section)

 = 0010				nproc 	equ	16  ; number of processes
 = 0032				nfiles 	equ	50
 = 0008				ntty	equ     8   ; 8+1 -> 8 (10/05/2013)
				;nbuf	equ	6
 = 0008				nbuf	equ	8   ; 15/07/2022 

 = 2000				csgmnt	equ	2000h	; 26/05/2013 (segment of process 1)
 = 0000				core	equ 	0  	    ; 19/04/2013	
 = 7FC0				ecore	equ	32768 - 64  ; 04/06/2013 (24/05/2013)
					; (if total size of argument list and arguments is 128 bytes)
					; maximum executable file size = 32768-(64+40+128-6) = 32530 bytes
					; maximum stack size = 40 bytes (+6 bytes for 'IRET' at 32570)	
					; initial value of user's stack pointer = 32768-64-128-2 = 32574
					; 	(sp=32768-args_space-2 at the beginning of execution)
					; argument list offset = 32768-64-128 = 32576 (if it is 128 bytes)
					; 'u' structure offset (for the '/core' dump file) = 32704
					; '/core' dump file size = 32768 bytes
				 
				; 08/03/2014 
 = 06C0				sdsegmnt equ	6C0h  ; 256*16 bytes (swap data segment size for 16 processes)		 	 
				; 19/04/2013 Retro UNIX 8086 v1 feature only !
				;sdsegmnt equ 	740h  ; swap data segment (for user structures and registers)

				; 30/08/2013
 = 0004				time_count equ 4 ; 10 --> 4 01/02/2014

				; 05/02/2014
				; process status
				;SFREE 	equ 0
				;SRUN	equ 1
				;SWAIT	equ 2
				;SZOMB	equ 3
				;SSLEEP	equ 4 ; Retro UNIX 8086 V1 extension (for sleep and wakeup)

				; 30/01/2022
				; .bss section

 = SizeOfFile			BSSSTART equ SizeOfFile

 = SizeOfFile+2			fsp	equ SizeOfFile+2
 = fsp+(nfiles*8)		fspend	equ fsp+(nfiles*8)

 = fspend+2			sb0	equ fspend+2
 = sb0+4			systm   equ sb0+4
 = systm+512			sb1	equ systm+512
 = sb1+4			mount	equ sb1+4
 = mount+512			Buffer	equ mount+512
				;BuffersEnd equ Buffer+(nbuf*516)	

 = Buffer+(nbuf*516)		BSSEND	equ Buffer+(nbuf*516)

 = BSSEND-BSSSTART		BSSSIZE equ BSSEND-BSSSTART

 = BSSEND+256-64		sstack	equ BSSEND+256-64		

 0040				user 	struc
					; 10/10/2013
					; 11/03/2013. 
					;Derived from UNIX v1 source code 'user' structure (ux).
					;u.

 0000  0000			        sp_     dw ? ; sp
 0002  0000				usp	dw ?
 0004  0000				r0	dw ?
 0006  0000				cdir	dw ?
 0008  000A [				fp	db 10 dup(?)
        00
       ]
 0012  0000				fofp	dw ?
 0014  0000				dirp	dw ?
 0016  0000				namep	dw ?
 0018  0000				off	dw ?
 001A  0000				base	dw ?
 001C  0000				count	dw ?
 001E  0000				nread	dw ?
 0020  0000				break_	dw ? ; break
 0022  0000				ttyp	dw ? 
 0024  000A [				dirbuf	db 10 dup(?)
        00
       ]
					;pri	dw ? ; 14/02/2014
 002E  00				quant	db ? ; Retro UNIX 8086 v1 Feature only ! (uquant)
 002F  00				pri	db ? ; 
 0030  0000				intr	dw ?
 0032  0000				quit	dw ?
					; emt	dw ? ; 10/10/2013
 0034  0000				ilgins	dw ?
 0036  0000				cdrv	dw ? ; cdev
 0038  00				uid_	db ? ; uid
 0039  00				ruid	db ?
 003A  00				bsys	db ?
 003B  00				uno	db ?
					; user/program segment (12/03/2013)
 003C  0000			        segmnt  dw ? ; 12/03/2013 - Retro Unix 8086 v1 feature only !
					; tty number (rtty, rcvt, wtty)
 003E  00				ttyn	db ? ; 28/07/2013 - Retro Unix 8086 v1 feature only !
					; last error number (reserved)
 003F  00				errn	db ? ; 28/07/2013 - Retro Unix 8086 v1 feature only !

				user 	ends

 00A0				process  struc 
					; 05/02/2014 ttys -> waitc (waiting channel, tty number)
					; 17/09/2013 ttys (10 byte structure)
					; 03/09/2013 ttyc (word -> byte) [ 10 bytes -> 9 bytes ]
					; 14/08/2013 dska -> ttyc
					; 11/03/2013. 
					;Derived from UNIX v1 source code 'proc' structure (ux).
					;p.
					
 0000  0010 [			        pid     dw nproc dup(?)
        0000
       ]
 0020  0010 [			        ppid    dw nproc dup(?)
        0000
       ]
 0040  0010 [			        break   dw nproc dup(?)
        0000
       ]
 0060  0010 [			        ttyc    db nproc dup(?) ; console tty in Retro UNIX 8086 v1.
        00
       ]
 0070  0010 [				waitc	db nproc dup(?) ; waiting channel in Retro UNIX 8086 v1.
        00
       ]
 0080  0010 [				link	db nproc dup(?)
        00
       ]
 0090  0010 [				stat	db nproc dup(?)
        00
       ]

				process ends

 0020				inode 	struc ; 11/03/2013. 
					;Derived from UNIX v1 source code 'inode' structure (ux).
					;i.

 0000  0000				flgs	dw ?
 0002  00				nlks	db ?
 0003  00				uid	db ?
 0004  0000			        size_   dw ? ; size
 0006  0008 [				dskp	dw 8 dup(?) ; 16 bytes
        0000
       ]
 0016  00000000				ctim	dd ?
 001A  00000000				mtim	dd ?
 001E  0000				rsvd	dw ? ; Reserved (ZERO/Undefined word for UNIX v1.)

				inode	ends

				;superblock struc ; 30/01/2022
				;;systm	struc ; 11/03/2013. 
				;	;Derived from UNIX v1 source code 'systm' structure (ux).
				;	;s.
				;
				;	dw 	?
				;	db 	128 dup(?)
				;	dw 	?
				;	db 	64 dup (?)
				;	time	dd ?
				;	syst	dd ?
				;	wait_   dd ? ; wait
				;	idlet	dd ?
				;	chrgt	dd ?
				;	drerr	dw ?
				;
				;;systm	ends
				;superblock ends ; 30/01/2022

				; 30/03/2022 ; Retro UNIX 8086 v1 2022 modification
				;	     ; (bugfix for 1.44MB disks)
 01A2				superblock struc ; 30/03/2022
				;systm	struc ; 11/03/2013. 
					;Derived from UNIX v1 source code 'systm' structure (ux).
					;s.
 0000  0000				dw 	? ; free blocks map size (=360)
 0002  0168 [				db 	360 dup(?) ; fb map (for 1.44MB floppy disk)
        00
       ]
 016A  0000				dw 	? ; inode map size (=32)
 016C  0020 [				db 	32 dup (?) ; inode map (256+40 inodes)
        00
       ]
 018C  00000000				time	dd ?
 0190  00000000				syst	dd ?
 0194  00000000				wait_   dd ? ; wait
 0198  00000000				idlet	dd ?
 019C  00000000				chrgt	dd ?
 01A0  0000				drerr	dw ?

				;systm	ends
				superblock ends ; 30/03/2022

				; fsp table entry (8 bytes) ;; 19/04/2013
				;       inum   	dw 0 	; inode number
				;	devnum  dw 0	; device number   
				;	ofsp	dw 0	; offset pointer
				;	oc	db 0	; open count
				;	df	db 0	; deleted flag
				;

 0024				phydrv	struc ; 26/04/2013  (09/07/2013)
					; Physical drv parameters of Retro UNIX 8086 v1 devices
					; Retro UNIX 8086 v1 feature only !
 0000  0006 [				err	db 6 dup(?) ; error status (>0 means error)
        00
       ]
 0006  0006 [				pdn 	db 6 dup(?) ; physical drive number
        00
       ]
 000C  0006 [				spt	dw 6 dup(?) ; sectors per track
        0000
       ]
 0018  0006 [				hds	dw 6 dup(?) ; heads
        0000
       ]
				phydrv	ends	


				; 14/07/2013
				; UNIX v1 system calls
 = 0000				_rele 	equ 0
 = 0001				_exit 	equ 1
 = 0002				_fork 	equ 2
 = 0003				_read 	equ 3
 = 0004				_write	equ 4
 = 0005				_open	equ 5
 = 0006				_close 	equ 6
 = 0007				_wait 	equ 7
 = 0008				_creat 	equ 8
 = 0009				_link 	equ 9
 = 000A				_unlink	equ 10
 = 000B				_exec	equ 11
 = 000C				_chdir	equ 12
 = 000D				_time 	equ 13
 = 000E				_mkdir 	equ 14
 = 000F				_chmod	equ 15
 = 0010				_chown	equ 16
 = 0011				_break	equ 17
 = 0012				_stat	equ 18
 = 0013				_seek	equ 19
 = 0014				_tell 	equ 20
 = 0015				_mount	equ 21
 = 0016				_umount	equ 22
 = 0017				_setuid	equ 23
 = 0018				_getuid	equ 24
 = 0019				_stime	equ 25
 = 001A				_quit	equ 26	
 = 001B				_intr	equ 27
 = 001C				_fstat	equ 28
 = 001D				_emt 	equ 29
 = 001E				_mdate 	equ 30
 = 001F				_stty 	equ 31
 = 0020				_gtty	equ 32
 = 0021				_ilgins	equ 33
 = 0022				_sleep	equ 34 ; Retro UNIX 8086 v1 feature only !

				sys macro syscallnumber
				    ; 14/07/2013
				    ; Retro UNIX 8086 v1 system call.		
				    mov ax, syscallnumber	
				    int 20h	
				    endm	

				.8086

 0000				UNIX  	SEGMENT PUBLIC PARA 'CODE'
				                assume cs:UNIX,ds:UNIX,es:UNIX,ss:UNIX
 0000				START:

				; 11/03/2013  
				; include files according to original UNIX v1 (except ux.s)
				; (u0.s, u1.s, u2.s, u3.s, u34.s, u5.s, u6.s, u7.s, u8.s, u9.s)
				;
				include u0.asm ; u0.s (with major modifications for 8086 PC)
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U0.ASM (include u0.asm) //// UNIX v1 -> u0.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 30/01/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 30/01/2022 - compact kernel (moving buffers to bss section)
			      C 
			      C ; 26/01/2022, 27/01/2022, 28/01/2022, 29/01/2022
			      C ; 23/07/2014, 27/07/2014, 28/07/2014, 15/04/2015
			      C ; 07/07/2014, 08/07/2014, 12/07/2014, 20/07/2014
			      C ; 30/06/2014, 03/07/2014, 04/07/2014, 05/07/2014
			      C ; 23/06/2014, 25/06/2014, 26/06/2014, 27/06/2014
			      C ; 22/05/2014, 26/05/2014, 02/06/2014, 03/06/2014
			      C ; 01/05/2014, 05/05/2014, 19/05/2014, 20/05/2014
			      C ; 14/04/2014, 25/04/2014, 29/04/2014, 30/04/2014
			      C ; 03/03/2014, 04/03/2014, 07/03/2014, 12/03/2014
			      C ; 05/02/2014, 14/02/2014, 23/02/2014, 28/02/2014
			      C ; 17/01/2014, 18/01/2014, 20/01/2014, 01/02/2014
			      C ; 30/10/2013, 04/12/2013, 06/12/2013, 10/12/2013
			      C ; 24/09/2013, 29/09/2013, 05/10/2013, 10/10/2013	
			      C ; 30/08/2013, 03/09/2013, 17/09/2013, 20/09/2013
			      C ; 23/07/2013, 29/07/2013, 11/08/2013, 12/08/2013	
			      C ; 16/07/2013, 17/07/2013, 18/07/2013, 22/07/2013
			      C ; 15/07/2013, 20/05/2013, 21/05/2013, 27/05/2013
			      C ; 15/05/2013, 17/05/2013, 13/07/2013, 14/07/2013
			      C ; 11/03/2013, 11/04/2013, 09/05/2013, 10/05/2013
			      C 
			      C ; 29/04/2014 --> serial port (terminal) login functionality test
			      C ;		 by using fake INT 14h, tty6, tty7
			      C ;		 etc/init has been modified for leaving tty6 and tty7 free
			      C 
 0000			      C kernel_init:
			      C 	; 30/01/2022
			      C 	; 26/01/2022
			      C 	; 15/04/2015
			      C 	; 07/03/2014
			      C 	; 04/03/2013
			      C 	; 28/02/2014
			      C 	; 14/02/2014
			      C 	; 05/02/2014
			      C 	; 04/12/2013
			      C 	; 05/10/2013
			      C 	; 29/07/2013
			      C 	; 18/07/2013
			      C 	; 17/07/2013
			      C 	; 14/07/2013
			      C 	; 13/07/2013
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; Retro UNIX 8086 v1 
			      C 	; kernel relies on data from its 'boot' program ...
			      C 	;
			      C 	;;mov 	ax, cs
			      C 	;mov 	ds, ax
			      C 	;mov 	es, ax
			      C 	;cli
			      C 	;mov 	ss, ax
			      C 	;mov 	sp, 32766 
			      C 	;sti
			      C 	; mov 	bp, sp
 0000  88 16 25E8 R	      C 	mov     byte ptr [unixbootdrive], dl
 0004  8E D9		      C 	mov	ds, cx ; boot sector segment
			      C  	; bx = boot sector buffer
 0006  8B 47 02		      C 	mov	ax, word ptr [BX]+2 ; 14/07/2013
 0009  8B 57 04		      C 	mov	dx, word ptr [BX]+4 ; 14/07/2013
 000C  0E		      C 	push	cs
 000D  1F		      C 	pop	ds
			      C 	; 26/01/2022
 000E  3D 5552		      C 	cmp	ax, 'UR'
			      C 	;jne	kernel_init_err ; jne short kernel_init_err
 0011  75 19		      C 	jne	short kernel_init_err
 0013  81 FA 5346	      C 	cmp	dx, 'SF'
			      C 	;jne	kernel_init_err ; jne short kernel_init_err
 0017  75 13		      C 	jne	short kernel_init_err
			      C 	;
			      C 	; 30/01/2022
			      C 	; clear bss section
 0019  1E		      C 	push	ds
 001A  07		      C 	pop	es
 001B  B9 15BD		      C 	mov	cx, BSSSIZE+1
 001E  D1 E9		      C 	shr	cx, 1
 0020  BF 2892 R	      C 	mov	di, BSSSTART
 0023  33 C0		      C 	xor	ax, ax
 0025  F3/ AB		      C 	rep	stosw
			      C 	;
 0027  E8 19E1		      C 	call	drv_init
			      C 	;jc	kernel_init_err ; jc short kernel_init_err
 002A  73 05		      C 	jnc	short @f
			      C 
			      C 	; 26/01/2021
 002C			      C kernel_init_err:	
 002C  BE 27E4 R	      C 	mov	si, offset kernel_init_err_msg
 002F  EB 7C		      C 	jmp	p_kernel_init_err
 0031			      C @@:
			      C 	; 14/02/2014
			      C 	; 14/07/2013
			      C 	;mov	ax, 41
 0031  B0 29		      C 	mov	al, 41 ; 30/01/2022
 0033  A3 26F0 R	      C 	mov	word ptr [rootdir], ax
 0036  A3 27AA R	      C 	mov	word ptr [u.cdir], ax
 0039  B8 0001		      C 	mov	ax, 1 ; 15/04/2015 (mov al, 1)	
 003C  A2 27DF R	      C 	mov	byte ptr [u.uno], al
 003F  A3 26EE R	      C 	mov	word ptr [mpid], ax
 0042  A3 260A R	      C 	mov	word ptr [p.pid], ax
 0045  A2 269A R	      C 	mov	byte ptr [p.stat], al ; SRUN, 05/02/2014
			      C 	;
 0048  B0 04		      C 	mov	al, time_count ; 30/08/2013
			      C 	;; 29/07/2013
			      C 	;;mov	byte ptr [s.wait_]+2, al
			      C         ;;mov	byte ptr [s.idlet]+2, al
			      C 	; 14/02/2014 uquant -> u.quant
 004A  A2 27D2 R	      C 	mov	byte ptr [u.quant], al ; 14/07/2013
			      C 	; 22/07/2013
 004D  8C C8		      C 	mov	ax, cs
 004F  A3 27E0 R	      C 	mov	word ptr [u.segmnt], ax ; reset to CS
			      C         ;
 0052  E8 23B9		      C  	call	epoch
			      C 	;mov	word ptr [s.time], ax
			      C 	;mov	word ptr [s.time]+2, dx
			      C 	; 30/01/2022
 0055  A3 2BB6 R	      C 	mov	word ptr [systm.time], ax
 0058  89 16 2BB8 R	      C 	mov	word ptr [systm.time]+2, dx
			      C 	;
 005C  E8 008A		      C 	call	kb_init 
			      C 	; ES = 0 (30/06/2014)
			      C 	;
			      C 	; 28/02/2014 INT 16h handler
 005F  B8 1D86 R	      C 	mov	ax, offset int_16h
 0062  BF 0058		      C 	mov	di, 22*4 ; INT 16h vector - offset
 0065  AB		      C 	stosw
 0066  8C C8		      C 	mov	ax, cs
 0068  AB		      C 	stosw
			      C 	;mov	es, ax ; 30/06/2014)
			      C 	;
			      C 	; 30/01/2022
			      C 	; save ROMBIOS INT 1Ch vector
			      C 	; (will be used for diskette motor off countdown) 
			      C 	;mov	di, 28*4 ; INT 1Ch vector - offset
			      C 	;mov	ax, word ptr es:[di]
			      C 	;mov	word ptr [int1Ch], ax
			      C 	;mov	ax, word ptr es:[di+2]
			      C 	;mov	word ptr [int1Ch+2], ax
			      C 	;
			      C 	;; 10/12/2013 
			      C 	;; INT 1Ch handling disabled here,
			      C 	;;	it will be enabled by 'sys emt'
			      C 	;;	system call (in 'etc/init')
			      C ; INT 1Ch (clock/timer) transfer to unix kernel
			      C 	;; 30/06/2014
			      C 	;;xor 	ax, ax
			      C 	;;mov	es, ax ; 0 
			      C 	;; ES = 0
			      C 	;mov	di, 28*4 ; INT 1Ch vector - offset
			      C 	;cli
			      C 	;mov	ax, offset clock
			      C 	;stosw   ; offset
			      C 	;mov	ax, cs
			      C 	;stosw	; segment
			      C 	;sti
			      C 	;
			      C ; setting up syscall vector (int 20h)
 0069  B8 025A R	      C 	mov	ax, offset sysent
 006C  BF 0080		      C 	mov	di, 32*4 ; INT 20h for system calls
 006F  AB		      C 	stosw
 0070  8C C8		      C 	mov	ax, cs
 0072  AB		      C 	stosw
			      C 	;mov	es, ax ; 14/04/2014
			      C 	;
			      C 	; 26/01/2022
			      C 	; 17/01/2014
			      C 	; ES = 0
 0073  E8 0182		      C 	call	sp_init ; serial port interrupts
			      C 	; 14/04/2014
			      C 	;mov	ax, cs
			      C 	;mov	es, ax
			      C 	; 26/01/2022
			      C 	;xor	bl, bl ; video page 0
			      C ;@@:	; clear video pages (reset cursor positions)
			      C 	;call 	vp_clr  ; 17/07/2013
			      C 	;inc	bl
			      C 	;cmp	bl, 8
			      C 	;jb	short @b
			      C 	
			      C 	; 26/01/2022
			      C 	; clear all (8) video pages
 0076			      C clr_all_vps:
			      C 	; clear all video pages
			      C 	;
			      C 	; 26/01/2022
			      C 	;
			      C 	;sub	di, di
			      C  	;push	es
 0076  B8 B800		      C 	mov	ax, 0B800h
 0079  8E C0		      C 	mov	es, ax
 007B  B8 0720		      C 	mov	ax, 0720h  ; ah = attribute/color
			      C 	;		   ; al = character/space
 007E  B9 3E80		      C 	mov	cx, 8*2000 ; 16000 words, 32000 bytes
 0081  F3/ AB		      C 	rep	stosw
			      C 	;pop	es
			      C 	;retn
			      C 
			      C 	; 26/01/2022
 0083  8C C8		      C 	mov	ax, cs
 0085  8E C0		      C 	mov	es, ax
			      C 	;
			      C 	; reset cursor position for video page 0
 0087  32 DB		      C 	xor	bl, bl ; video page 0
 0089  33 D2		      C 	xor	dx, dx ; column (dl) 0, row (dh) 0
 008B  E8 1B3C		      C 	call	set_cpos
			      C 
			      C ;;	13/07/2013
			      C ;;	Kernel is running message ... (temporary)
			      C ;
 008E  BE 2807 R	      C 	mov	si, offset kernel_init_ok_msg
			      C 	; 26/01/2022
			      C 	; 07/03/2014
 0091  E8 0045		      C 	call 	print_msg
			      C 	;;;;;
 0094			      C print_msg_int10h:
			      C 	;lodsb
			      C 	;mov	ah, 0Eh
			      C 	;mov	bx, 07h
			      C ;@@:
			      C 	;int	10h
			      C 	;lodsb
			      C 	;and	al, al
			      C 	;jnz	short @b
			      C 	;
			      C ;	; 26/01/2022
			      C ;	;
			      C ;	; 17/01/2014
			      C ;	; ES = 0
			      C ;	call	sp_init ; serial port interrupts
			      C ;	; 14/04/2014
			      C ;	mov	ax, cs
			      C ;	mov	es, ax
			      C ;	;
			      C ;	; 05/10/2013 Temporary
			      C ;	xor 	al, al ; mov al, 0
			      C ;	; mov byte ptr [u.ttyn], 0
			      C ;	call	getc
			      C ;	; 16/07/2013
			      C ;	;xor 	al, al
			      C ;	; 04/12/2013
			      C ;	xor	bl, bl ; video page 0
			      C ;@@:	; clear video pages (reset cursor positions)
			      C ;	call 	vp_clr  ; 17/07/2013
			      C ;	inc	bl
			      C ;	cmp	bl, 8
			      C ;	jb	short @b
			      C 	;
			      C 	; 17/07/2013
			      C 	;mov    al, byte ptr [unixbootdrive]
			      C 	;cmp	al, 80h ; 128 (80h->hd0)
			      C 	;jna	short @f
			      C 	;sub	al, 7Eh ; 126 (2->hd0)
			      C ;@@:
			      C 	;mov	byte ptr [rdev], al
			      C 	;
 0094  E8 1A09		      C 	call 	bf_init ; buffer initialization ; 17/07/2013
			      C 
			      C ;; original UNIX v1 (PDP-11) code here:
			      C 	; / make current program a user
			      C 	;
			      C 	; mov    $41.,r0    / rootdir set to 41 and never changed
			      C 	; mov    r0,rootdir / rootdir is i-number of root directory
			      C 	; mov    r0,u.cdir  / u.cdir is i-number of process current directory
			      C 	; mov    $1,r0
			      C 	; movb   r0,u.uno   / set process table index for this process to 1
			      C 	; mov    r0,mpid    / initialize mpid to 1
			      C 	; mov    r0,p.pid   / p.pid identifies process
			      C 	; movb   r0,p.stat  / process status = 1 i.e., active
			      C         ;                   /                = 0 free
			      C 	;                   /                = 2 waiting for a child to die
			      C         ;                   /                = 3 terminated but not yet waited
			      C         ;                   /                    for
			      C 	; 18/01/2014
			      C 	;sti
			      C 	; 24/07/2013
 0097  BB 00B6 R	      C 	mov	bx, offset init_file
 009A  B9 00B2 R	      C 	mov	cx, offset init_argp
			      C 	; (([u.segmnt] = CS))
			      C 	; BX contains 'etc/init' asciiz file name address  
			      C 	; CX contains address of argument list pointer
			      C 	;
 009D  FE 0E 26F7 R	      C 	dec 	byte ptr [sysflg] ; FFh = ready for system call
			      C 			      	  ; 0 = executing a system call
			      C 	;mov	ax, _exec
			      C 	;int	20h
			      C 	sys	_exec  ; execute file
 00A1  B8 000B		     1C     mov ax, _exec	
 00A4  CD 20		     1C     int 20h	
			      C 	;
 00A6  73 18		      C 	jnc	short panic
			      C 	;
 00A8  BE 2873 R	      C 	mov	si, offset etc_init_err_msg
 00AB  EB 00		      C 	jmp	short @f
			      C 
			      C ;; original UNIX v1 (PDP-11) code here:
			      C  ; 1:
			      C 	; decb sysflg / normally sysflag=0, indicates executing in system
			      C 	; sys exec; 2f; 1f / generates trap interrupt; trap vector =
			      C         ;                  / sysent; 0
			      C 	; br panic / execute file/etc/init
			      C 
			      C  ; 1:
			      C 	; 2f;0
			      C  ; 2:
			      C 	; </etc/init\0> / UNIX looks for strings term, noted by nul\0
			      C 
			      C 	; 26/01/2021
			      C ;kernel_init_err:
			      C ;	;; NOTE: Unix kernel will load boot sector
			      C ;	;; 	
			      C ;	mov	si, offset kernel_init_err_msg
 00AD			      C @@:
 00AD			      C p_kernel_init_err:
 00AD  E8 0029		      C 	call 	print_msg
 00B0  EB 14		      C 	jmp	short key_to_reboot
			      C 
			      C align 2
 00B2			      C init_argp:
 00B2  00B6 R 0000	      C 	dw 	offset init_file, 0
 00B6			      C init_file:
 00B6  2F 65 74 63 2F 69      C 	db 	'/etc/init', 0
       6E 69 74 00
			      C 
 00C0			      C panic:
			      C 	; 07/03/2014
			      C 	; 05/10/2013 ('call getc' instead of 'int 16h')
			      C 	; 14/07/2013 (panic_msg/print_msg)
			      C       	; 10/04/2013	
			      C       	;
			      C       	; Retro Unix 8086 v1 modification on original Unix v1 panic procedure!
			      C       	;
			      C 	
 00C0  BE 2858 R	      C 	mov 	si, offset panic_msg
 00C3  E8 0013		      C 	call 	print_msg
 00C6			      C key_to_reboot:
			      C 	;hlt
			      C 	; 05/10/2013
 00C6  32 C0		      C 	xor 	al, al
 00C8  E8 19F9		      C 	call 	getc
			      C 	;
 00CB  B0 0A		      C 	mov	al, 0Ah
 00CD  8A 26 2736 R	      C 	mov	ah, byte ptr [ptty] ; [active_page]
 00D1  E8 1A90		      C 	call 	write_tty
			      C 
			      C 	; 15/07/2013
			      C 	;mov 	ah, 0Eh
			      C 	;;mov 	bx, 07h
			      C 	;;mov 	al, 0Dh
			      C 	;;int 	10h
			      C  	;mov 	al, 0Ah
			      C 	;int	10h			
			      C 
 00D4			      C cpu_reset:
			      C 	; 07/03/2014
			      C 	; CPU reset (power on) address
 00D4  EA		      C 	db	0EAh  ; far jump (jmp 0FFFFh:0000h)
 00D5  0000		      C 	dw	0
 00D7  FFFF		      C 	dw	0FFFFh	; F000:0FFF0h
			      C 	
			      C ;khere:	hlt
			      C ;	jmp 	short khere
			      C 
			      C ;@@:
			      C 	; 24/09/2013
			      C 	; Reset INT 09h vector for next start-up
			      C 	;xor	di, di
			      C 	;mov	es, di
			      C 	;mov	di, 4*9
			      C 	;mov	si, offset int09h
			      C 	;movsw
			      C 	;movsw		
			      C 	;
			      C       	;int 19h
			      C 
			      C ;      	hlt	
			      C ;      	jmp short @b  			
			      C 	
			      C 	; clr ps
			      C ;1:
			      C 	; dec 0
			      C 	; bne 1b
			      C 	; dec $5
			      C 	; bne 1b
			      C 	; jmp *$173700 / rom loader address
			      C 
 00D9			      C print_msg:
			      C 	; 07/03/2014
			      C 	; (Modified registers: AX, BX, CX, DX, SI, DI)
			      C 	;
 00D9  AC		      C 	lodsb
 00DA			      C @@:
 00DA  56		      C 	push 	si
 00DB  8A 26 2736 R	      C 	mov	ah, byte ptr [ptty]
 00DF  E8 1A82		      C 	call 	write_tty
 00E2  5E		      C 	pop	si
 00E3  AC		      C 	lodsb
 00E4  22 C0		      C 	and 	al, al
 00E6  75 F2		      C 	jnz 	short @b
 00E8  C3		      C 	retn
			      C 
			      C 	; 14/07/2013
			      C 	; 13/07/2013
			      C 	;lodsb
			      C 	;mov	bx, 07h
			      C 	;mov	ah, 0Eh
			      C ;@@:
			      C 	;int	10h
			      C 	;lodsb
			      C 	;and	al, al
			      C 	;jnz	short @b
			      C 	;retn
			      C 
 00E9			      C kb_init:
			      C 	; 30/06/2014
			      C 	; 03/03/2014
			      C 	; 11/08/2013
			      C 	; 16/07/2013
			      C 	; 15/07/2013
			      C 	; 13/07/2013
			      C 	; 21/05/2013 
			      C 	; 17/05/2013
			      C 	; 10/05/2013	
			      C       	;
			      C 	; Initialization of keyboard handlers		
			      C 	;
			      C       	; Retro Unix 8086 v1 feature only!
			      C       	;
			      C 	; ((Modified registers: AX, CX, SI, DI, ES))
			      C 	;
 00E9  33 C0		      C 	xor 	ax, ax ; 11/08/2013
 00EB  BF 271C R	      C 	mov	di, offset int09h
 00EE  8E D8		      C 	mov 	ds, ax ; 0
 00F0  B8 0024		      C 	mov	ax, 9*4 ; INT 09h vector - offset
 00F3  8B F0		      C 	mov	si, ax
 00F5  A5		      C 	movsw		; offset
 00F6  A5		      C 	movsw		; segment
 00F7  8B F8		      C 	mov	di, ax
 00F9  8C D8		      C 	mov	ax, ds
 00FB  8E C0		      C 	mov	es, ax	
 00FD  8C C8		      C 	mov	ax, cs
 00FF  8E D8		      C 	mov	ds, ax
 0101  FA		      C 	cli
 0102  B8 0147 R	      C 	mov	ax, offset kb_int
 0105  AB		      C 	stosw		
 0106  8C C8		      C 	mov	ax, cs
 0108  AB		      C 	stosw		
 0109  B8 0115 R	      C 	mov	ax, offset ctrlbrk
 010C  BF 006C		      C 	mov	di, 27*4 ; INT 1Bh vector - offset
 010F  AB		      C 	stosw		; offset
 0110  8C C8		      C 	mov	ax, cs
 0112  AB		      C 	stosw		; segment
 0113  FB		      C 	sti
			      C 	;mov	es, ax  ; 30/06/2014 (ES = 0)
			      C 	;
			      C 	; 03/03/2014
			      C 			; SETUP KEYBOARD PARAMETERS
			      C 	;mov	si, offset KB_BUFFER 
			      C 	;mov	word ptr [BUFFER_HEAD], si
			      C 	;mov	word ptr [BUFFER_TAIL], si
			      C 	;mov	word ptr [BUFFER_START], si
			      C 	;add	si, 32	; DEFAULT BUFFER OF 32 BYTES
			      C 	;mov	word ptr [BUFFER_END], si
			      C 	;
 0114  C3		      C 	retn
			      C 
 0115			      C ctrlbrk:
			      C 	; 28/01/2022
			      C 	; 27/01/2022
			      C 	; 06/12/2013
			      C 	; 20/09/2013
			      C 	; 03/09/2013
			      C     	; 09/05/2013	
			      C       	;
			      C 	; INT 1Bh (control+break) handler		
			      C 	;
			      C       	; Retro Unix 8086 v1 feature only!
			      C       	;
			      C 
 0115  2E: 83 3E 27D4 R	      C 	cmp 	word ptr CS:[u.intr], 0
       00
			      C 	;ja 	short cbrk1
			      C 	;iret
			      C 	; 27/01/2022
 011B  76 29		      C 	jna	short cbrk4
			      C 
 011D			      C cbrk1:
			      C 	; 28/01/2022
 011D  1E		      C 	push	ds	
			      C 	; 20/09/2013	
 011E  50		      C 	push 	ax
			      C 	; 28/01/2022
 011F  0E		      C 	push	cs
 0120  1F		      C 	pop	ds
			      C 
			      C 	; 28/01/2022
			      C 	; (repetitive ctrl+brk check) 
 0121  A1 27D6 R	      C 	mov	ax, word ptr [u.quit]
 0124  40		      C 	inc	ax ; 0FFFFh -> 0
 0125  74 1D		      C 	jz	short cbrk3
			      C 
			      C 	;mov	al, byte ptr CS:[ptty]
 0127  A0 2736 R	      C 	mov	al, byte ptr [ptty]
 012A  FE C0		      C 	inc 	al
			      C 	; 28/01/2022
 012C  3A 06 27C6 R	      C 	cmp	al, byte ptr [u.ttyp]
			      C 	; 06/12/2013
			      C 	;cmp	al, byte ptr CS:[u.ttyp]
 0130  74 06		      C 	je	short cbrk2	
			      C 	;cmp	al, byte ptr CS:[u.ttyp]+1
 0132  3A 06 27C7 R	      C 	cmp	al, byte ptr [u.ttyp+1] 
 0136  75 0C		      C 	jne	short cbrk3	
 0138			      C cbrk2:
			      C 	; 28/01/2022
			      C 	;mov	ax, word ptr [u.quit]
 0138  33 C0		      C 	xor	ax, ax
 013A  39 06 27D6 R	      C 	cmp	word ptr [u.quit], ax ; 0
 013E  76 04		      C 	jna	short cbrk3 ; > 0
 0140  48		      C 	dec	ax ; 0FFFFh
			      C 	; 06/12/2013
			      C 	;mov	ax, word ptr CS:[u.quit]
			      C 	;and	ax, ax
			      C 	;jz	short cbrk3
			      C 	;xor	ax, ax ; 0
			      C 	;dec	ax
			      C 	;mov	ax, 0FFFFh
			      C 	; 0FFFFh = 'ctrl+brk' keystroke
			      C 	;mov	word ptr CS:[u.quit], ax
			      C 	; 28/01/2022
 0141  A3 27D6 R	      C 	mov	word ptr [u.quit], ax
			      C 	;mov	word ptr [u.quit], 0FFFFh
 0144			      C cbrk3:
 0144  58		      C 	pop	ax
			      C 	; 28/01/2022
 0145  1F		      C 	pop	ds
 0146			      C cbrk4:
 0146  CF		      C 	iret
			      C 
			      C ;tty_sw: ; < tty switch >
			      C 	; 23/02/2014
			      C 	; 04/12/2013 'act_disp_page' (U9.ASM)
			      C 	; 29/09/2013 (simplified)
			      C 	; 29/09/2013 u1.asm -> u0.asm
			      C 	; 22/09/2013
			      C 	; 17/09/2013
			      C 	; 03/09/2013
			      C 	; 21/08/2013
			      C 	; 18/08/2013
			      C 	; 16/07/2013
			      C 	; 15/07/2013
			      C 	; 20/05/2013
			      C 	;
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; INPUTS:
			      C 	;   AL = tty number to be switched on
			      C 	; OUTPUTS:
			      C 	;   Keyboard buffer will be reset and 
			      C 	;   active video page will be changed
			      C 	;   according to the requested tty number.
			      C 	;
			      C 	; ((Modified registers: AX))  
			      C 	;
			      C 	; 29/09/2013
			      C 	; 03/09/2013
			      C 	;
			      C 	;mov	al, byte ptr [nxtty] ; tty number
			      C 	;	                     ; video page
			      C 	;;; 
			      C 	; 04/12/2013
			      C 	;;mov	ah, 5 ; Set video page
			      C 	;;int 	10h
			      C 	;;mov	byte ptr [ptty], al ; byte ptr [active_page], al
			      C 	;call 	act_disp_page
			      C 	; 23/02/2014
			      C 	;mov	byte ptr [u.quant], 0 
			      C 	;retn
			      C 	
 0147			      C kb_int:
			      C 	; INT 09h Keyboard Handler		
			      C 	;
			      C 	; 30/06/2014
			      C 	; 12/03/2014
			      C 	; 07/03/2014
			      C 	; 04/03/2014
			      C 	; 03/03/2014 major modification
			      C 	; 25/02/2013 ;;
			      C 	; 23/02/2014
			      C 	; 14/02/2014
			      C 	; 01/02/2014
			      C 	; 20/01/2014
			      C 	; 18/01/2014
			      C 	; 17/01/2014
			      C         ; 10/10/2013   
			      C 	; 05/10/2013
			      C 	; 29/09/2013
			      C 	; 24/09/2013
			      C 	; 03/09/2013
			      C 	; 12/08/2013
			      C 	; 11/08/2013
			      C 	; 20/05/2013
			      C 	; 15/05/2013 
			      C     	; 10/05/2013	
			      C       	;
			      C 	; Retro Unix 8086 v1 feature only!
			      C 
			      C 	; 03/03/2014
			      C 	
 0147  1E		      C 	push	ds
 0148  50		      C 	push	ax
 0149  53		      C 	push	bx
			      C 	;
 014A  8C C8		      C 	mov	ax, cs
 014C  8E D8		      C 	mov	ds, ax
			      C 	;
 014E  9C		      C 	pushf
			      C 	; 04/03/2014
			      C 	;call	dword ptr [int09h]
			      C 	; 07/03/2014
 014F  0E		      C 	push	cs
 0150  E8 1CBB		      C 	call	int_09h
			      C 	;
			      C 	; 24/09/2013
 0153  B4 01		      C 	mov	ah, 1
 0155  CD 16		      C 	int 	16h
 0157  74 45		      C 	jz	short kb_int_4
			      C 	;
			      C 	; 04/03/2014
 0159  8A 1E 2736 R	      C 	mov	bl, byte ptr [ptty]
 015D  32 E4		      C 	xor	ah, ah
 015F  CD 16		      C 	int 	16h
			      C 	;
 0161  22 C0		      C 	and 	al, al
 0163  75 20		      C 	jnz	short kb_int_1
			      C 	;
 0165  80 FC 68		      C 	cmp	ah, 68h  ; ALT + F1 key
 0168  72 1B		      C 	jb	short kb_int_1
 016A  80 FC 6F		      C 	cmp	ah, 6Fh  ; ALT + F8 key	
 016D  77 16		      C 	ja	short kb_int_1
			      C 	;
 016F  8A FB		      C 	mov	bh, bl
 0171  80 C7 68		      C 	add	bh, 68h
 0174  38 E7		      C 	cmp	bh, ah
 0176  74 0D		      C 	je	short kb_int_1
 0178  8A C4		      C 	mov	al, ah
 017A  2C 68		      C 	sub	al, 68h
			      C 	;
			      C 	;mov	byte ptr [ptty], al  ; [active_page]
			      C 	;
 017C  E8 1BA2		      C 	call	tty_sw
 017F  33 C0		      C 	xor	ax, ax ; 0 ; 07/03/2014
			      C 	; 12/03/2014
 0181  8A 1E 2736 R	      C 	mov	bl, byte ptr [ptty]
 0185			      C kb_int_1:
 0185  32 FF		      C 	xor	bh, bh
 0187  D0 E3		      C 	shl	bl, 1
 0189  81 C3 2766 R	      C 	add	bx, offset ttychr
			      C 	; 12/03/2014
 018D  0B C0		      C 	or	ax, ax
 018F  74 05		      C 	jz	short kb_int_2
			      C 	; 29/09/2013
 0191  83 3F 00		      C 	cmp 	word ptr [BX], 0
 0194  77 02		      C       	ja	short kb_int_3 
 0196			      C kb_int_2:
			      C         ;
			      C         ; 24/09/2013
 0196  89 07		      C 	mov	word ptr [BX], ax  ; Save ascii code
			      C 				   ; and scan code of the character
			      C 				   ; for current tty (or last tty
			      C 				   ; just before tty switch).
 0198			      C kb_int_3:
			      C         ; 10/10/2013
 0198  A0 2736 R	      C         mov     al, byte ptr [ptty]
			      C 	; 14/02/2014
			      C 	;mov	bx, offset runq
 019B  E8 0E72		      C 	call	wakeup
			      C 	;
 019E			      C kb_int_4:
 019E  5B		      C 	pop	bx ; 24/09/2013
 019F  58		      C 	pop	ax
 01A0  1F		      C 	pop	ds
			      C 	;
 01A1  CF		      C 	iret
			      C 
			      C ;vp_clr:
			      C ;	; Reset/Clear Video Page
			      C ;	;
			      C ;	; 04/12/2013 scroll_up (U9.ASM) 
			      C ;	;
			      C ;	; 30/10/2013
			      C ;	; 17/09/2013
			      C ;	; 17/07/2013
			      C ;	; 21/05/2013
			      C ;	;
			      C ;	; Retro UNIX 8086 v1 feature only !
			      C ;	;
			      C ;	; INPUTS -> 
			      C ;	;   AL = video page number	 
			      C ;	;
			      C ;	; OUTPUT ->
			      C ;	;   none
			      C ;	; ((Modified registers: AX, BH, CX, DX, SI, DI))
			      C ;	;
			      C ;	; 04/12/2013
			      C ;	sub	al, al
			      C ;	; al = 0 (clear video page)
			      C ;	; bl = video page
			      C ;	mov	bh, 07h
			      C ;	; bh = 7 (attribute/color)
			      C ;	call	scroll_up
			      C ;	; bh = 7
			      C ;	; bl = video page
			      C ;	xor	dx, dx ; 0
			      C ;	;call	set_cpos
			      C ;	;retn
			      C ;	
			      C ;	; 30/10/2013
			      C ;	;push	es
			      C ;	;xor	ah, ah
			      C ;	;;push	ax
			      C ;	;mov	di, 0B800h
			      C ;	;mov	es, di
			      C ;	;mov	cx, 2000
			      C ;	;sub	dx, dx ; 30/10/2013
			      C ;	;or 	al, al
			      C ;	;jz	short @f
			      C ;	;; 30/10/2013
			      C ;	;shl	al, 1
			      C ;	;; 17/09/2013
			      C ;	;push 	ax
			      C ;	;mul	cx
			      C ;	;pop	dx
			      C ;;@@:
			      C ;	;mov	di, ax ; 17/09/2013
			      C ;	;mov	ah, 07h ; color
			      C ;	;rep	stosw
			      C ;	;;pop	ax
			      C ;	;;mov	bh, al ; video page
			      C ;	;;mov	ah, 2 ; set cursor position
			      C ;	;;xor 	dx, dx
			      C ;	;;int 	10h
			      C ;	;;xor 	ax, ax
			      C ;	;xor	ah, ah
			      C ;	;;pop	di    ; Video page number
			      C ;	;;shl	di, 1
			      C ;	;mov	di, dx
			      C ;	;mov	es, ax ; 0
			      C ;	;add	di, 450h ; 40h:50h or 0h:450h
			      C ;	;; di = cursor position of the video page.
			      C ;	;stosw	; reset cursor position
			      C ;	;pop 	es	
			      C ;	;retn
			      C 
 01A2			      C com2_int:
			      C 	; 28/07/2014
			      C 	; 27/07/2014
			      C 	; 23/07/2014
			      C 	; 20/07/2014 (null chr)
			      C 	; 07/07/2014
			      C 	; 05/07/2014
			      C 	; 04/07/2014
			      C 	; < serial port 2 interrupt handler >
			      C 	;
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
 01A2  52		      C 	push	dx
 01A3  50		      C 	push	ax
 01A4  BA 02FA		      C 	mov	dx, 2FAh   ; interrupt identification register
 01A7  B8 0009		      C 	mov	ax, 9	   ; tty number of com2
 01AA  EB 08		      C 	jmp	short @f
			      C 
 01AC			      C com1_int:
			      C 	; 28/07/2014
			      C 	; 27/07/2014
			      C 	; 23/07/2014
			      C 	; 20/07/2014 (null chr)
			      C 	; 07/07/2014
			      C 	; 05/07/2014
			      C 	; 04/07/2014
			      C 	; < serial port 1 interrupt handler >
			      C 	;
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
 01AC  52		      C 	push	dx
 01AD  50		      C 	push	ax
 01AE  BA 03FA		      C 	mov	dx, 3FAh   ; interrupt identification register
 01B1  B8 0008		      C 	mov	ax, 8	   ; tty number of com1
 01B4			      C @@:
 01B4  1E		      C 	push	ds
 01B5  53		      C 	push	bx
 01B6  0E		      C 	push	cs
 01B7  1F		      C 	pop	ds
 01B8  50		      C 	push	ax
			      C 	;
 01B9  8B D8		      C 	mov	bx, ax
 01BB  EC		      C 	in	al, dx	   ; read register
 01BC  24 0F		      C 	and	al, 0Fh    ; leave lowernibble only
			      C 	; 28/07/2014
 01BE  3C 02		      C 	cmp	al, 2
 01C0  75 13		      C 	jne	short com_rdei
			      C 	;
 01C2  81 C3 2790 R	      C 	add	bx, offset tsleep - 8
 01C6  38 27		      C 	cmp	byte ptr [BX], ah ; 0
 01C8  76 04		      C 	jna	short @f
 01CA  88 27		      C 	mov	byte ptr [BX], ah ; 0
 01CC  EB 1D		      C 	jmp	short com_eoi
 01CE			      C @@:
 01CE  B0 20		      C 	mov	al, 20h
 01D0  E6 20		      C 	out	20h, al	   ; end of interrupt
 01D2  58		      C 	pop	ax
 01D3  EB 1E		      C 	jmp	short com_iret	
			      C 
 01D5			      C com_rdei:
 01D5  3C 04		      C 	cmp	al, 4	   ; is it receiver data available interrupt?
 01D7  75 12		      C 	jne	short com_eoi ; no, leave interrupt handler
			      C 	;
 01D9  83 EA 02		      C 	sub	dx, 3FAh-3F8h ; data register (3F8h, 2F8h)
 01DC  EC		      C 	in	al, dx     ; read character
			      C 	; 27/07/2014
 01DD  22 C0		      C 	and	al, al
 01DF  75 02		      C 	jnz	short @f
			      C 	; null chr (al=0, ah=0)
 01E1  FE CC		      C 	dec	ah ; 0FFh
 01E3			      C @@:	; 27/07/2014
			      C 	; 09/07/2014
 01E3  D0 E3		      C 	shl	bl, 1	
 01E5  81 C3 2766 R	      C 	add	bx, offset ttychr
			      C 	; 23/07/2014 (always overwrite)
			      C 	;;cmp	word ptr [BX], 0
			      C 	;;ja	short com_eoi
			      C 	;
 01E9  89 07		      C 	mov	word ptr [BX], ax  ; Save ascii code
			      C 				   ; scan code = 0
 01EB			      C com_eoi: 
 01EB  B0 20		      C 	mov	al, 20h
 01ED  E6 20		      C 	out	20h, al	   ; end of interrupt
			      C 	;
 01EF  58		      C       	pop	ax ; al = tty number (8 or 9)
 01F0  E8 0E1D		      C         call	wakeup
 01F3			      C com_iret:
 01F3  5B		      C 	pop	bx
 01F4  1F		      C 	pop	ds
 01F5  58		      C 	pop	ax
 01F6  5A		      C 	pop	dx
 01F7  CF		      C 	iret
			      C 
 01F8			      C sp_init:
			      C 	; 28/07/2014
			      C 	; 27/07/2014
			      C 	; 12/07/2014
			      C 	; 08/07/2014
			      C 	; 05/07/2014
			      C 	; 03/07/2014
			      C 	; 17/01/2014
			      C       	;
			      C 	; Initialization of serial port interrupt handlers		
			      C 	;
			      C       	; Retro Unix 8086 v1 feature only!
			      C       	;
			      C 	; ((Modified registers: AX, CX, DX, DI))
			      C 	;
			      C 	; ES = 0
			      C 	;
			      C 	; Set communication parameters for COM1
			      C 	;
 01F8  B1 E3		      C 	mov	cl, 0E3h
 01FA  32 E4		      C 	xor	ah, ah 
 01FC  8A C1		      C 	mov	al, cl    ; Communication parameters (E3h)
			      C 			  ; 9600 baud, parity none, one stop bit
 01FE  33 D2		      C 	xor	dx, dx	  ; COM1 (DX=0)
 0200  CD 14		      C 	int	14h
			      C 	; 12/07/2014
 0202  F6 C4 80		      C 	test	ah, 80h
 0205  75 52		      C 	jnz	short @f
			      C 	       ; (Note: Serial port interrupts will be disabled here...)	
			      C 	       ; (INT 14h initialization code disables interrupts.)
 0207  88 0E 279A R	      C 	mov	byte ptr [com1p], cl ; 0E3h
			      C 	;
			      C 	;; Hook serial port (COM1) interrupt
			      C 	;
 020B  BF 0030		      C 	mov	di, 12 * 4  ; 0Ch, COM1 (IRQ 4) interrupt vector
			      C 	;cli
 020E  B8 01AC R	      C 	mov	ax, offset com1_int
 0211  AB		      C 	stosw		
 0212  8C C8		      C 	mov	ax, cs
 0214  AB		      C 	stosw
			      C 	;sti
			      C 	;
			      C 	;; COM1 - enabling IRQ 4
 0215  BA 03FC		      C 	mov	dx, 3FCh   ;modem control register
 0218  EC		      C 	in	al, dx 	   ;read register
 0219  0C 08		      C 	or	al, 8      ;enable bit 3 (OUT2)
 021B  EE		      C 	out	dx, al     ;write back to register
 021C  BA 03F9		      C 	mov	dx, 3F9h   ;interrupt enable register
 021F  EC		      C 	in	al, dx     ;read register
			      C 	;or	al, 1      ;receiver data interrupt enable
			      C 	; 27/7/2014        ; and
 0220  0C 03		      C 	or	al, 3	   ;Transmitter empty interrupt enable
			      C 	;	
 0222  EE		      C 	out	dx, al 	   ;write back to register
 0223  E4 21		      C 	in	al, 21h    ;read interrupt mask register
 0225  24 EF		      C 	and	al, 0EFh   ;enable IRQ 4 (COM1)
 0227  E6 21		      C 	out	21h, al    ;write back to register
			      C 
			      C 	;
			      C 	; Set communication parameters for COM2
			      C 	;
 0229  BA 0001		      C 	mov	dx, 1	  ; COM2	
 022C  2A E4		      C 	sub	ah, ah 
 022E  8A C1		      C         mov     al, cl    ; Communication parameters (E3h)
			      C 			  ; 9600 baud, parity none, one stop bit
 0230  CD 14		      C 	int	14h
			      C 	; 12/07/2014
 0232  F6 C4 80		      C 	test	ah, 80h
 0235  75 22		      C 	jnz	short @f
			      C 	       ; (Note: Serial port interrupts will be disabled here...)	
			      C 	       ; (INT 14h initialization code disables interrupts.)
 0237  88 0E 279B R	      C 	mov	byte ptr [com2p], cl ; 0E3h
			      C 	;
			      C 	;; Hook serial port (COM2) interrupt
			      C 	;
 023B  BF 002C		      C 	mov	di, 11 * 4  ; 0Bh, COM2 (IRQ 3) interrupt vector
			      C 	;cli
 023E  B8 01A2 R	      C 	mov	ax, offset com2_int
 0241  AB		      C 	stosw		
 0242  8C C8		      C 	mov	ax, cs
 0244  AB		      C 	stosw
			      C 	;sti
			      C 	;
			      C 	;; COM2 - enabling IRQ 3
 0245  BA 02FC		      C 	mov	dx, 2FCh   ;modem control register
 0248  EC		      C 	in	al, dx 	   ;read register
 0249  0C 08		      C 	or	al, 8      ;enable bit 3 (OUT2)
 024B  EE		      C 	out	dx, al     ;write back to register
 024C  BA 02F9		      C 	mov	dx, 2F9h   ;interrupt enable register
 024F  EC		      C 	in	al, dx     ;read register
			      C 	;or	al, 1      ;receiver data interrupt enable
			      C 	; 27/7/2014	   ; and	
 0250  0C 03		      C 	or	al, 3	   ;Transmitter empty interrupt enable
			      C 	;	
 0252  EE		      C 	out	dx, al 	   ;write back to register
 0253  E4 21		      C 	in	al, 21h    ;read interrupt mask register
 0255  24 F7		      C 	and	al, 0F7h   ;enable IRQ 3 (COM2)
 0257  E6 21		      C 	out	21h, al    ;write back to register
 0259			      C @@:
 0259  C3		      C 	retn
			      C 
				include u1.asm ; u1.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U1.ASM (include u1.asm) //// UNIX v1 -> u1.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 29/06/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 26/02/2022, 26/06/2022, 29/06/2022
			      C ; 27/01/2022, 28/01/2022, 30/01/2022, 01/02/2022, 02/02/2022
			      C ; 11/06/2014, 26/06/2014, 04/07/2014, 12/07/2014, 28/06/2015
			      C ; 07/03/2014, 10/04/2014, 15/04/2014, 22/04/2014, 30/04/2014
			      C ; 18/01/2014, 26/01/2014, 05/02/2014, 14/02/2014, 23/02/2014	
			      C ; 12/01/2014, 13/01/2014, 14/01/2014, 16/01/2014, 17/01/2014
			      C ; 18/11/2013, 04/12/2013, 06/12/2013, 07/12/2013, 10/12/2013 	
			      C ; 20/10/2013, 23/10/2013, 24/10/2013, 30/10/2013, 04/11/2013
			      C ; 03/09/2013, 16/09/2013, 17/09/2013, 22/09/2013, 29/09/2013	
			      C ; 14/08/2013, 18/08/2013, 19/08/2013, 21/08/2013, 30/08/2013
			      C ; 26/07/2013, 02/08/2013, 07/08/2013, 08/08/2013, 11/08/2013
			      C ; 15/07/2013, 16/07/2013, 22/07/2013, 23/07/2013, 24/07/2013
			      C ; 27/05/2013, 30/05/2013, 02/06/2013, 03/06/2013, 14/07/2013 
			      C ; 20/05/2013, 22/05/2013, 23/05/2013, 24/05/2013, 26/05/2013	
			      C ; 26/04/2013, 04/05/2013, 09/05/2013, 15/05/2013, 16/05/2013
			      C ; 11/03/2013, 10/04/2013, 16/04/2013, 17/04/2013, 19/04/2013 
			      C ; 
			      C 
			      C ; 30/01/2022 - compact kernel (moving buffers to bss section)
			      C 
 025A			      C unkni: ; / used for all system calls
 025A			      C sysent: ; < enter to system call >
			      C 	; 29/06/2022
			      C 	; 26/06/2022
			      C 	; 28/01/2022
			      C 	; 18/01/2014
			      C 	; 26/07/2013
			      C 	; 24/07/2013
			      C 	; 14/07/2013
			      C 	; 24/05/2013
			      C 	; 16/04/2013			
			      C 	; 10/04/2013
			      C 	;
			      C 	; 'unkni' or 'sysent' is sytem entry from various traps. 
			      C 	; The trap type is determined and an indirect jump is made to 
			      C 	; the appropriate system call handler. If there is a trap inside
			      C 	; the system a jump to panic is made. All user registers are saved 
			      C 	; and u.sp points to the end of the users stack. The sys (trap)
			      C 	; instructor is decoded to get the the system code part (see
			      C 	; trap instruction in the PDP-11 handbook) and from this 
			      C 	; the indirect jump address is calculated. If a bad system call is
			      C 	; made, i.e., the limits of the jump table are exceeded, 'badsys'
			      C 	; is called. If the call is legitimate control passes to the
			      C 	; appropriate system routine.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	Through a trap caused by any sys call outside the system.
			      C 	; Arguments:
			      C 	;	Arguments of particular system call.	
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       System call number is in AX register.
			      C 	;
			      C 	;       Other parameters are in DX, BX, CX, SI, DI, BP registers
			      C 	;	depending of function details.
			      C   	;
			      C 
			      C 	; 16/04/2013 segment changing
 025A  0E		      C 	push	cs
 025B  1F		      C 	pop	ds
			      C 	;
 025C  FE 06 26F7 R	      C 	inc	byte ptr [sysflg]
			      C 		; incb sysflg / indicate a system routine is in progress
 0260  FB		      C         sti ; 18/01/2014
			      C 	;jnz	panic ; 24/05/2013
			      C 	; 28/01/2022
 0261  74 03		      C 	jz	short @f
			      C 		; beq 1f
 0263  E9 FE5A		      C 	jmp	panic
			      C 		; jmp panic ; / called if trap inside system
 0266			      C @@: ;1:
			      C 	; 24/05/2013
 0266  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
 0269  89 26 27A6 R	      C 	mov	word ptr [u.usp], sp
			      C 			   
			      C ; 16/04/2013 stack segment changing
			      C 	;mov	ax, ss
			      C 	;mov 	word ptr [u.segmnt], ax
 026D  8C C8		      C 	mov	ax, cs
			      C 	; 24/05/2013
			      C 	;;;mov	es, ax ; 14/07/2013
 026F  FA		      C 	cli
			      C 	; 24/07/2013
 0270  BC 3F0E R	      C 	mov	sp, sstack ; offset sstack ; swap stack
			      C 		    ; (System/Kernel stack in Retro UNIX 8086 v1 !)
 0273  8E D0		      C 	mov	ss, ax	
 0275  FB		      C 	sti	
			      C 	; 24/05/2013
 0276  FF 36 27A6 R	      C 	push 	word ptr [u.usp] ; user's stack pointer (old sp)
			      C 			         ; which points to top of user's stack 
			      C 		    	         ; (Retro UNIX 8086 v1 modification!)
			      C 	;
 027A  52		      C 	push	dx
 027B  51		      C 	push	cx
 027C  53		      C 	push	bx
 027D  56		      C 	push	si
 027E  57		      C 	push	di
 027F  55		      C 	push	bp
			      C 	;
 0280  89 26 27A4 R	      C 	mov	word ptr [u.sp_], sp
			      C 	;;mov	ax, word ptr [s.syst+2]
			      C 	;;mov	word ptr [clockp], ax
			      C 		; mov $s.syst+2,clockp
			      C 		; mov r0,-(sp) / save user registers 
			      C 		; mov sp,u.r0 / pointer to bottom of users stack 
			      C 			   ; / in u.r0
			      C 		; mov r1,-(sp)
			      C 		; mov r2,-(sp)
			      C 		; mov r3,-(sp)
			      C 		; mov r4,-(sp)
			      C 		; mov r5,-(sp)
			      C 		; mov ac,-(sp) / "accumulator" register for extended
			      C 		             ; / arithmetic unit
			      C 		; mov mq,-(sp) / "multiplier quotient" register for the
			      C 		             ; / extended arithmetic unit
			      C 		; mov sc,-(sp) / "step count" register for the extended
			      C 		             ; / arithmetic unit
			      C 		; mov sp,u.sp / u.sp points to top of users stack
			      C 		; mov 18.(sp),r0 / store pc in r0
			      C 		; mov -(r0),r0 / sys inst in r0      10400xxx
			      C 		; sub $sys,r0 / get xxx code
 0284  A1 27A8 R	      C 	mov	ax, word ptr [u.r0]
 0287  D1 E0		      C 	shl	ax, 1
			      C 		; asl r0 / multiply by 2 to jump indirect in bytes
 0289  3D 0046		      C 	cmp	ax, offset error - offset syscalls ; 26/06/2022
			      C 	;cmp	ax, offset @f - offset syscalls
			      C 		; cmp r0,$2f-1f / limit of table (35) exceeded
			      C 	;jnb	short badsys
			      C 		; bhis badsys / yes, bad system call
			      C 	; 16/04/2013
 028C  F5		      C 	cmc
 028D  9C		      C 	pushf	
 028E  50		      C 	push	ax
			      C  	; 24/05/2013
 028F  8B 2E 27A6 R	      C 	mov 	bp, word ptr [u.usp]
			      C 	; 26/07/2013
			      C 	;mov	ax, 0FFFEh
 0293  B0 FE		      C 	mov	al, 0FEh ; 11111110b
 0295  14 00		      C 	adc	al, 0 ; al = al + cf
			      C 	;and	word ptr ES:[BP]+4, ax ; flags
			      C 	;;mov	ax, word ptr [u.segmnt]
			      C 	;;mov 	es, ax	
 0297  26: 20 46 04	      C 	and	byte ptr ES:[BP]+4, al ; flags (reset carry flag)
			      C 		; bic $341,20.(sp) / set users processor priority to 0 
			      C 				 ; / and clear carry bit
 029B  8C D8		      C 	mov	ax, ds ; 14/07/2013
 029D  8E C0		      C 	mov	es, ax ; 17/07/2013
			      C 	;pop	ax
			      C 	;mov	bp, ax
			      C 	;shr 	ax, 1
 029F  5D		      C 	pop	bp ; ax
			      C 	;mov	ax, word ptr [u.r0]
 02A0  9D		      C 	popf
			      C 	;jc	badsys
			      C 	; 28/01/2022
 02A1  73 03		      C 	jnc	short @f
 02A3  E9 00D0		      C 	jmp	badsys
 02A6			      C @@:
 02A6  A1 27A8 R	      C 	mov	ax, word ptr [u.r0]
			      C 	; system call registers: AX, DX, CX, BX, SI, DI
 02A9  FF A6 02AD R	      C 	jmp	word ptr [BP]+syscalls
			      C 		; jmp *1f(r0) / jump indirect thru table of addresses
			      C 		            ; / to proper system routine.
 02AD			      C syscalls: ; 1:
 02AD  034A R		      C 	dw offset sysrele   ; / 0
 02AF  0438 R		      C 	dw offset sysexit   ; / 1
 02B1  0509 R		      C 	dw offset sysfork   ; / 2
 02B3  05DB R		      C 	dw offset sysread   ; / 3
 02B5  05E8 R		      C 	dw offset syswrite  ; / 4
 02B7  060C R		      C 	dw offset sysopen   ; / 5
 02B9  06BE R		      C 	dw offset sysclose  ; / 6
 02BB  04B6 R		      C 	dw offset syswait   ; / 7
 02BD  067A R		      C 	dw offset syscreat  ; / 8
 02BF  094D R		      C 	dw offset syslink   ; / 9
 02C1  09A5 R		      C 	dw offset sysunlink ; / 10
 02C3  0A25 R		      C 	dw offset sysexec   ; / 11
 02C5  0D24 R		      C 	dw offset syschdir  ; / 12
 02C7  0D96 R		      C 	dw offset systime   ; / 13
 02C9  069A R		      C 	dw offset sysmkdir  ; / 14
 02CB  0D48 R		      C 	dw offset syschmod  ; / 15
 02CD  0D7C R		      C 	dw offset syschown  ; / 16
 02CF  0DBD R		      C 	dw offset sysbreak  ; / 17
 02D1  0B98 R		      C 	dw offset sysstat   ; / 18
 02D3  0E3B R		      C 	dw offset sysseek   ; / 19
 02D5  0E47 R		      C 	dw offset systell   ; / 20
 02D7  1588 R		      C 	dw offset sysmount  ; / 21
 02D9  15EB R		      C 	dw offset sysumount ; / 22
 02DB  0E99 R		      C 	dw offset syssetuid ; / 23
 02DD  0EB1 R		      C 	dw offset sysgetuid ; / 24
 02DF  0DA9 R		      C 	dw offset sysstime  ; / 25
 02E1  0E8F R		      C 	dw offset sysquit   ; / 26
 02E3  0E88 R		      C 	dw offset sysintr   ; / 27
 02E5  0B84 R		      C 	dw offset sysfstat  ; / 28
 02E7  06C8 R		      C 	dw offset sysemt    ; / 29
 02E9  06F4 R		      C 	dw offset sysmdate  ; / 30
 02EB  071E R		      C 	dw offset sysstty   ; / 31
 02ED  088A R		      C 	dw offset sysgtty   ; / 32
 02EF  06F1 R		      C 	dw offset sysilgins ; / 33
 02F1  1D76 R		      C 	dw offset syssleep  ; 34 ; Retro UNIX 8086 v1 feature only !
			      C 				 ; 11/06/2014
			      C ;@@: ;2:
			      C 
 02F3			      C error:
			      C 	; 07/08/2013
			      C 	; 26/05/2013
			      C 	; 24/05/2013
			      C 	; 22/05/2013
			      C 	; 04/05/2013
			      C 	; 18/04/2013
			      C 	; 16/04/2013
			      C 	; 10/04/2013
			      C 	; 'error' merely sets the error bit off the processor status (c-bit)
			      C 	; then falls right into the 'sysret', 'sysrele' return sequence.
			      C 	;
			      C 	; INPUTS -> none
			      C 	; OUTPUTS ->
			      C 	;	processor status - carry (c) bit is set (means error)
			      C 	;
			      C 
			      C 	; 26/05/2013 (Stack pointer must be reset here! 
			      C 	; 	      Because, jumps to error procedure
			      C 	;	      disrupts push-pop nesting balance)
 02F3  8B 26 27A4 R	      C 	mov	sp, word ptr [u.sp_]
 02F7  8B EC		      C         mov     bp, sp
			      C 		; mov u.sp,r1
 02F9  8B 5E 0C		      C         mov     bx, word ptr [BP]+12 ; user's stack pointer
			      C 	;
 02FC  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt]
 02FF  8E C0		      C 	mov	es, ax
			      C 	;;push	ds
			      C 	;;mov	ds, ax
			      C 	;
			      C 	;;; word ptr ES:[BX] -> IP
			      C 	;;; word ptr ES:[BX]+2 -> CS
			      C 	;;; word ptr ES:[BX]+4 -> FLAGS
			      C 
			      C 	;;or	byte ptr [BX]+4, 1
 0301  26: 80 4F 04 01	      C 	or	byte ptr ES:[BX]+4, 1  ; set carry bit of flags register
			      C 				       ; in user's stack
			      C 		; bis $1,20.(r1) / set c bit in processor status word below
			      C 		               ; / users stack
			      C 	;;pop	ds
 0306  8C C8		      C 	mov	ax, cs
 0308  8E C0		      C 	mov	es, ax
			      C 	; 07/08/2013
 030A  C7 06 26F9 R 0000      C 	mov	word ptr [namei_r], 0 ; namei_r, mkdir_w reset
			      C 
 0310			      C sysret: ; < return from system call>
			      C 	; 30/01/2022
			      C 	; 28/01/2022
			      C 	; 23/02/2014
			      C 	; 07/08/2013	
			      C 	; 24/05/2013
			      C 	; 04/05/2013
			      C 	; 26/04/2013
			      C 	; 10/04/2013
			      C 	;
			      C 	; 'sysret' first checks to see if process is about to be 
			      C 	; terminated (u.bsys). If it is, 'sysexit' is called.
			      C 	; If not, following happens:	 
			      C 	; 	1) The user's stack pointer is restored.
			      C 	;	2) r1=0 and 'iget' is called to see if last mentioned
			      C 	;	   i-node has been modified. If it has, it is written out
			      C 	;	   via 'ppoke'.
			      C 	;	3) If the super block has been modified, it is written out
			      C 	;	   via 'ppoke'.				
			      C 	;	4) If the dismountable file system's super block has been
			      C 	;	   modified, it is written out to the specified device
			      C 	;	   via 'ppoke'.
			      C 	;	5) A check is made if user's time quantum (uquant) ran out
			      C 	;	   during his execution. If so, 'tswap' is called to give
			      C 	;	   another user a chance to run.
			      C 	;	6) 'sysret' now goes into 'sysrele'. 
			      C 	;	   (See 'sysrele' for conclusion.)		
			      C 	;
			      C 	; Calling sequence:
			      C 	;	jump table or 'br sysret'
			      C 	; Arguments: 
			      C 	;	-	
			      C 	; ...............................................................
			      C 	;	
			      C 	; ((AX=r1 for 'iget' input))
			      C 	;	
 0310  33 C0		      C 	xor	ax, ax ; 04/05/2013
 0312  FE C0		      C 	inc	al ; 04/05/2013
 0314  38 06 27DE R	      C 	cmp	byte ptr [u.bsys], al ; 1
			      C 		; tstb u.bsys / is a process about to be terminated because
			      C 	;jnb	sysexit ; 04/05/2013
			      C 		; bne sysexit / of an error? yes, go to sysexit
			      C 	; 28/01/2022
 0318  72 03		      C 	jb	short @f
 031A  E9 011B		      C 	jmp	sysexit
 031D			      C @@:
			      C 	;mov	sp, word ptr [u.sp_] ; 24/05/2013 (that is not needed here)
			      C 		; mov u.sp,sp / no point stack to users stack
 031D  FE C8		      C 	dec 	al ; mov ax, 0
			      C 		; clr r1 / zero r1 to check last mentioned i-node
 031F  E8 0E64		      C 	call	iget
			      C 		; jsr r0,iget / if last mentioned i-node has been modified
			      C 		            ; / it is written out
 0322  33 C0		      C 	xor 	ax, ax ; 0
 0324  38 06 26F5 R	      C 	cmp	byte ptr [smod], al ; 0
			      C 		; tstb smod / has the super block been modified
 0328  76 0D		      C 	jna	short @f
			      C 		; beq 1f / no, 1f
 032A  A2 26F5 R	      C 	mov	byte ptr [smod], al ; 0
			      C 		; clrb smod / yes, clear smod
			      C 	; 30/01/2022
 032D  BB 2A26 R	      C 	mov	bx, sb0	; mov bx, offset sb0 ;; 07/08//2013
 0330  81 0F 0200	      C    	or	word ptr [BX], 200h ;;
			      C 	;or	word ptr [sb0], 200h ; write bit, bit 9
			      C 		; bis $1000,sb0 / set write bit in I/O queue for super block
			      C 		      	      ; / output
			      C 	; AX = 0
 0334  E8 15EC		      C 	call 	poke ; 07/08/2013
			      C 	; call	ppoke
			      C 	; AX = 0
			      C 		; jsr r0,ppoke / write out modified super block to disk
 0337			      C @@: ;1:
 0337  38 06 26F6 R	      C 	cmp	byte ptr [mmod], al ; 0
			      C 		; tstb	mmod / has the super block for the dismountable file
			      C 		           ; / system
 033B  76 0D		      C 	jna	short @f ; 23/02/2014 (@f location has been changed to u.quant check)
			      C 		; beq 1f / been modified?  no, 1f
 033D  A2 26F6 R	      C 	mov	byte ptr [mmod], al ; 0	
			      C 		; clrb mmod / yes, clear mmod
			      C         ;mov    ax, word ptr [mntd]
			      C         ;;mov   al, byte ptr [mdev] ; 26/04/2013
			      C 	; 30/01/2022
 0340  BB 2C2A R	      C 	mov	bx, sb1  ; mov	bx, offset sb1 ;; 07/08//2013
			      C         ;;mov	byte ptr [BX], al
			      C 	;mov    byte ptr [sb1], al
			      C 		; movb	mntd,sb1 / set the I/O queue
 0343  81 0F 0200	      C 	or	word ptr [BX], 200h
			      C 	;or	word ptr [sb1], 200h ; write bit, bit 9
			      C 		; bis $1000,sb1 / set write bit in I/O queue for detached sb
 0347  E8 15D9		      C 	call	poke ; 07/08/2013
			      C 	;call	ppoke 
			      C 		; jsr r0,ppoke / write it out to its device
			      C         ;xor    al, al ; 26/04/2013       
			      C ;@@: ;1:
			      C ;	cmp	byte ptr [uquant], al ; 0
			      C ;		; tstb uquant / is the time quantum 0?
			      C ;       ja      short @f
			      C ;       ;ja     short swapret
			      C 		; bne 1f / no, don't swap it out
			      C 
 034A			      C sysrele: ; < release >
			      C 	; 07/03/2014
			      C 	; 23/02/2014 
			      C 	; 14/02/2014 uquant -> u.quant
			      C 	; 18/01/2014
			      C 	; 07/12/2013
			      C 	; 20/10/2013
			      C 	; 22/09/2013
			      C 	; 16/05/2013
			      C 	; 08/05/2013
			      C 	; 16/04/2013
			      C 	; 11/04/2013			
			      C 	; 10/04/2013
			      C 	;
			      C 	; 'sysrele' first calls 'tswap' if the time quantum for a user is
			      C 	;  zero (see 'sysret'). It then restores the user's registers and
			      C 	; turns off the system flag. It then checked to see if there is
			      C 	; an interrupt from the user by calling 'isintr'. If there is, 
			      C 	; the output gets flashed (see isintr) and interrupt action is
			      C 	; taken by a branch to 'intract'. If there is no interrupt from
			      C 	; the user, a rti is made.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	Fall through a 'bne' in 'sysret' & ?
			      C 	; Arguments:
			      C 	;	-	
			      C 	; ...............................................................
			      C 	;	
			      C 	; 23/02/2014 (@@)
			      C 	; 22/09/2013
 034A			      C @@: ;1:
 034A  80 3E 27D2 R 00	      C 	cmp	byte ptr [u.quant], 0 ; 16/05/2013
			      C 		; tstb uquant / is the time quantum 0?
 034F  77 03		      C 	ja      short @f
			      C         ;ja     short swapret
			      C 		; bne 1f / no, don't swap it out
 0351			      C sysrelease: ; 07/12/2013 (jump from 'clock ')
			      C ;
 0351  E8 0B98		      C 	call	tswap
			      C 		; jsr r0,tswap / yes, swap it out
			      C ;
			      C ; Retro Unix 8086 v1 feature: return from 'swap' to 'swapret' address.
 0354			      C @@:
			      C ;swapret: ;1:
			      C 	; 26/05/2013 
			      C 	; 'sp' must be already equal to 'word ptr [u.sp_]' here ! 
			      C 	;mov	sp, word ptr [u.sp_] ; Retro Unix 8086 v1 modification!
			      C 				    ; 10/04/2013
			      C 				    ; (If an I/O error occurs during disk I/O,
			      C 				    ; related procedures will jump to 'error'
			      C 				    ; procedure directly without returning to 
			      C 				    ; the caller procedure. So, stack pointer
			      C                                     ; must be restored here.)
 0354  5D		      C 	pop	bp
 0355  5F		      C 	pop	di
 0356  5E		      C 	pop	si
 0357  5B		      C 	pop	bx
 0358  59		      C 	pop	cx
 0359  5A		      C 	pop	dx
			      C 		; mov (sp)+,sc / restore user registers
			      C 		; mov (sp)+,mq
			      C 		; mov (sp)+,ac
			      C 		; mov (sp)+,r5
			      C 		; mov (sp)+,r4
			      C 		; mov (sp)+,r3
			      C 		; mov (sp)+,r2
			      C 	; 22/09/2013
 035A  E8 0D04		      C 	call	isintr
			      C 	; 20/10/2013
 035D  74 03		      C 	jz	short @f
 035F  E8 00C4		      C 	call	intract
			      C 		; jsr r0,isintr / is there an interrupt from the user
			      C 		;     br intract / yes, output gets flushed, take interrupt
			      C 		               ; / action
 0362			      C @@:	
			      C 		; mov (sp)+,r1
 0362  58		      C 	pop	ax ; user's stack pointer 
			      C 		   ; (was pushed on system stack by 'sysenter'.)
			      C 		; mov (sp)+,r0
			      C 	; 24/05/2013
			      C 	; 18/01/2014
			      C 	;cli	; disable (hardware) interrupts
 0363  8B E0		      C 	mov	sp, ax	; user's stack pointer
 0365  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt]
 0368  8E D0		      C 	mov	ss, ax	; user's stack segment
			      C 	; 18/01/2014			
			      C 	;;sti 	; enable interrupts  ;; 07/03/2014
			      C 			; 'sti' is not needed here 
			      C 			; (because 'iret' will restore interrupt flag)
 036A  8E C0		      C 	mov	es, ax
			      C 	;;;mov	ax, word ptr [s.chrgt]+2
			      C 	;;;mov	word ptr [clockp], ax
			      C 	; 20/10/2013
 036C  A1 27A8 R	      C 	mov	ax, word ptr [u.r0] ; ((return value in AX))
 036F  FE 0E 26F7 R	      C 	dec	byte ptr [sysflg]
			      C 		; decb sysflg / turn system flag off
 0373  06		      C 	push	es
 0374  1F		      C 	pop	ds
 0375  CF		      C 	iret	
			      C 		; rti / no, return from interrupt
			      C 
 0376			      C badsys:
			      C 	; 29/06/2022 - Retro UNIX 8086 v1 (2022 modification)
			      C 	;
			      C 	; write 'invalid system call !' message to user's console tty
			      C 	; (then dump core to 'core' file and then terminate process)
			      C 	;
 0376  BE 03CC R	      C 	mov	si, offset badsys_msg
 0379  A0 27C6 R	      C 	mov 	al, byte ptr [u.ttyp] ; recent open tty
			      C 	; 0 = none
 037C  FE C8		      C 	dec	al
 037E  79 0A		      C 	jns	short invscmsg1 
 0380  2A FF		      C 	sub	bh, bh
 0382  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number	
 0386  8A 87 2669 R	      C 	mov	al, byte ptr [bx+p.ttyc-1] 
			      C 			; user's (process's) console tty
 038A			      C invscmsg1:
 038A  A2 27E2 R	      C 	mov	byte ptr [u.ttyn], al
 038D  AC		      C 	lodsb
 038E			      C invscmsg2:
 038E  56		      C 	push 	si
 038F  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn]
 0393  E8 17CE		      C 	call 	write_tty
 0396  5E		      C 	pop	si
 0397  AC		      C 	lodsb
 0398  22 C0		      C 	and 	al, al  ; 0
 039A  75 F2		      C 	jnz 	short invscmsg2
			      C 	;
			      C 	; 29/06/2022 (BugFix)
			      C 	;;;
 039C  06		      C 	push	es
 039D  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt] ; user's (process) egment
 03A0  8E C0		      C 	mov	es, ax
 03A2  8B 3E 27A6 R	      C 	mov	di, word ptr [u.usp]
 03A6  83 EF 06		      C 	sub	di, 6
 03A9  89 3E 27BA R	      C 	mov	word ptr [u.namep], di
			      C 	;mov	si, offset badsys_3 ; db 'core', 0, 0
			      C 	;movsw
			      C 	;movsw
			      C 	;movsw
 03AD  B8 6F63		      C 	mov	ax, 'oc'
 03B0  AB		      C 	stosw
 03B1  B8 6572		      C 	mov	ax, 'er'
 03B4  AB		      C 	stosw
 03B5  2B C0		      C 	sub	ax, ax
 03B7  AB		      C 	stosw
 03B8  07		      C 	pop	es
			      C 	;;;
			      C ;badsys:
			      C 	; 27/05/2013
			      C 	; 11/04/2013
 03B9  FE 06 27DE R	      C 	inc	byte ptr [u.bsys]
			      C 		; incb u.bsys / turn on the user's bad-system flag
			      C 	; 29/06/2022
			      C 	;mov	word ptr [u.namep], offset badsys_3 ;  3f
			      C 		; mov $3f,u.namep / point u.namep to "core\0\0"
 03BD  E8 086D		      C 	call	namei
			      C 		; jsr r0,namei / get the i-number for the core image file
			      C 	;or	ax, ax ; Retro UNIX 8086 v1 modification !
			      C 		       ; ax = 0 -> file not found 	
			      C 	;jz	short badsys_1
 03C0  72 25		      C 	jc	short badsys_1 ; 27/05/2013
			      C 		; br 1f / error
 03C2  F7 D8		      C 	neg	ax ; AX = r1
			      C 		; neg r1 / negate the i-number to open the core image file
			      C 		       ; / for writing
 03C4  E8 12A0		      C 	call	iopen
			      C 		; jsr r0,iopen / open the core image file
 03C7  E8 0EA6		      C 	call	itrunc
			      C 		; jsr r0,itrunc / free all associated blocks
			      C 
 03CA  EB 24		      C 	jmp	short badsys_2
			      C 		; br 2f
			      C 
			      C 	; 29/06/2022
 03CC			      C badsys_msg:
 03CC  0D 0A 07 49 6E 76      C 	db 	0Dh, 0Ah, 07h, 'Invalid System Call !', 0Dh, 0Ah, 0
       61 6C 69 64 20 53
       79 73 74 65 6D 20
       43 61 6C 6C 20 21
       0D 0A 00
			      C 
 03E7			      C badsys_1: ;1:
 03E7  B8 000F		      C 	mov	ax, 15 ; mode 17
			      C 		; mov $17,r1 / put i-node mode (17) in r1
 03EA  E8 09FC		      C 	call	maknod
			      C 		; jsr r0,maknod / make an i-node
 03ED  A1 27C8 R	      C 	mov	ax, word ptr [u.dirbuf] ; i-number
			      C 		; mov u.dirbuf,r1 / put i-node number in r1
 03F0			      C badsys_2: ;2:
			      C 	; 19/04/2013
 03F0  BE 0000		      C 	mov	si, offset user
 03F3  BF 7FC0		      C 	mov	di, ecore
 03F6  8B 0E 27E0 R	      C 	mov	cx, word ptr [u.segmnt]
 03FA  8E C1		      C 	mov	es, cx
 03FC  B9 0020		      C 	mov	cx, 32
 03FF  F3/ A5		      C 	rep	movsw
 0401  8C DA		      C 	mov	dx, ds
 0403  8E C2		      C 	mov	es, dx
			      C 	
 0405  C7 06 27BE R 0000      C         mov     word ptr [u.base], core
			      C 		; mov $core,u.base / move address core to u.base
 040B  C7 06 27C0 R 8000      C 	mov	word ptr [u.count], ecore - core + 64
			      C 		; mov $ecore-core,u.count / put the byte count in u.count
 0411  C7 06 27B6 R 27BC R    C 	mov	word ptr [u.fofp], offset u.off
			      C 		; mov $u.off,u.fofp / more user offset to u.fofp
 0417  89 0E 27BC R	      C 	mov	word ptr [u.off], cx ; 0
			      C 		; clr u.off / clear user offset
 041B  E8 0FD4		      C 	call	writei
			      C 		; jsr r0,writei / write out the core image to the user
			      C 	;mov	word ptr [u.base], offset user
			      C 		; mov $user,u.base / pt. u.base to user
			      C 	;mov	word ptr [u.count], 64
			      C 		; mov $64.,u.count / u.count = 64
			      C 	;call	writei
			      C 		; jsr r0,writei / write out all the user parameters
 041E  F7 D8		      C 	neg	ax ; r1
			      C 		; neg r1 / make i-number positive
 0420  E8 1372		      C 	call	iclose
			      C 		; jsr r0,iclose / close the core image file
 0423  EB 13		      C 	jmp	short sysexit
			      C 		; br sysexit /
			      C 
			      C 	; 29/06/2022
			      C ;badsys_3: ;3:
			      C ;	db	'core',0,0
			      C 		; <core\0\0>
			      C 
 0425			      C @@:	; 22/09/2013
 0425  C3		      C 	retn
			      C 
 0426			      C intract: ; / interrupt action
			      C 	; 07/12/2013
			      C 	; 06/12/2013
			      C 	; 20/10/2013
			      C 	; 22/09/2013
			      C 	; 03/09/2013
			      C 	; 16/05/2013 task/process/tty switch
			      C 	; 15/05/2013 (ptty, set video page)
			      C 	; 09/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; (Process/task switching and quit routine by using
			      C 	; Retro UNIX 8086 v1 keyboard interrupt output.))
			      C 	;
			      C 	; input -> 'u.quit'  (also value of 'u.intr' > 0)
			      C 	; output -> If value of 'u.quit' = FFFFh ('ctrl+brk' sign)
			      C 	;		'intract' will jump to 'sysexit'.
			      C 	;	    Intract will return to the caller 
			      C 	;		if value of 'u.quit' <> FFFFh. 	 
			      C 	; 07/12/2013	
 0426  FF 06 27D6 R	      C 	inc 	word ptr [u.quit]
 042A  74 06		      C 	jz	short @f ; FFFFh -> 0
 042C  FF 0E 27D6 R	      C 	dec	word ptr [u.quit]
 0430  EB F3		      C 	jmp	short @b
 0432			      C @@:	
			      C 	; 20/10/2013	
 0432  58		      C 	pop	ax ; call intract -> retn
 0433  58		      C 	pop	ax ; user's stack pointer ('sysrele') 
			      C 	;
 0434  33 C0		      C 	xor 	ax, ax
 0436  FE C0		      C 	inc	al	; mov ax, 1
			      C 	; 06/12/2013
			      C 	;mov	word ptr [u.quit], ax ; reset to
			      C 				      ; 'ctrl+brk' enabled
			      C 	;jmp	sysexit
			      C ;;;
			      C 	; UNIX v1 original 'intract' routine... 
			      C 	; / interrupt action
			      C 		;cmp *(sp),$rti / are you in a clock interrupt?
			      C 		; bne 1f / no, 1f
			      C 		; cmp (sp)+,(sp)+ / pop clock pointer
			      C 	; 1: / now in user area
			      C 		; mov r1,-(sp) / save r1
			      C 		; mov u.ttyp,r1 
			      C 			; / pointer to tty buffer in control-to r1
			      C 		; cmpb 6(r1),$177
			      C 			; / is the interrupt char equal to "del"
			      C 		; beq 1f / yes, 1f
			      C 		; clrb 6(r1) 
			      C 		        ; / no, clear the byte 
			      C 			; / (must be a quit character)
			      C 		; mov (sp)+,r1 / restore r1
			      C 		; clr u.quit / clear quit flag
			      C 		; bis $20,2(sp) 
			      C 		    	; / set trace for quit (sets t bit of 
			      C 			; / ps-trace trap)
			      C 		; rti   ;  / return from interrupt
			      C 	; 1: / interrupt char = del
			      C 		; clrb 6(r1) / clear the interrupt byte 
			      C 			   ; / in the buffer
			      C 		; mov (sp)+,r1 / restore r1
			      C 		; cmp u.intr,$core / should control be 
			      C 				; / transferred to loc core?
			      C 		; blo 1f
			      C 		; jmp *u.intr / user to do rti yes, 
			      C 				; / transfer to loc core
			      C 	; 1:
			      C 		; sys 1 / exit
			      C 
 0438			      C sysexit: ; <terminate process>
			      C 	; 14/02/2014
			      C 	; 05/02/2014
			      C 	; 17/09/2013
			      C 	; 30/08/2013
			      C 	; 19/04/2013			
			      C 	;
			      C 	; 'sysexit' terminates a process. First each file that
			      C 	; the process has opened is closed by 'flose'. The process
			      C 	; status is then set to unused. The 'p.pid' table is then
			      C 	; searched to find children of the dying process. If any of
			      C 	; children are zombies (died by not waited for), they are
			      C 	; set free. The 'p.pid' table is then searched to find the
			      C 	; dying process's parent. When the parent is found, it is
			      C 	; checked to see if it is free or it is a zombie. If it is
			      C 	; one of these, the dying process just dies. If it is waiting
			      C 	; for a child process to die, it notified that it doesn't 
			      C 	; have to wait anymore by setting it's status from 2 to 1
			      C 	; (waiting to active). It is awakened and put on runq by
			      C 	; 'putlu'. The dying process enters a zombie state in which
			      C 	; it will never be run again but stays around until a 'wait'
			      C 	; is completed by it's parent process. If the parent is not
			      C 	; found, process just dies. This means 'swap' is called with
			      C 	; 'u.uno=0'. What this does is the 'wswap' is not called
			      C 	; to write out the process and 'rswap' reads the new process
			      C 	; over the one that dies..i.e., the dying process is 
			      C 	; overwritten and destroyed.	
			      C  	;
			      C 	; Calling sequence:
			      C 	;	sysexit or conditional branch.
			      C 	; Arguments:
			      C 	;	-	
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       System call number (=1) is in AX register.
			      C 	;
			      C 	;       Other parameters are in DX, BX, CX, SI, DI, BP registers
			      C 	;	depending of function details.
			      C 	;
			      C 	; ('swap' procedure is mostly different than original UNIX v1.)
			      C 	;
			      C ; / terminate process
			      C 	; AX = 1
 0438  48		      C 	dec 	ax ; 0
 0439  A3 27D4 R	      C 	mov	word ptr [u.intr], ax ; 0
			      C 		; clr u.intr / clear interrupt control word
			      C 		; clr r1 / clear r1
			      C 	; AX = 0
 043C			      C sysexit_1: ; 1:
			      C 	; AX = File descriptor
			      C 		; / r1 has file descriptor (index to u.fp list)
			      C 		; / Search the whole list
 043C  E8 078A		      C 	call	fclose
			      C 		; jsr r0,fclose / close all files the process opened
			      C 	;; ignore error return
			      C 		; br .+2 / ignore error return
			      C 	;inc	ax
 043F  FE C0		      C 	inc	al
			      C 		; inc r1 / increment file descriptor
			      C 	;cmp	ax, 10
 0441  3C 0A		      C 	cmp	al, 10
			      C 		; cmp r1,$10. / end of u.fp list?
 0443  72 F7		      C 	jb	short sysexit_1
			      C 		; blt 1b / no, go back
 0445  32 FF		      C 	xor	bh, bh ; 0
 0447  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno]
			      C 		; movb	u.uno,r1 / yes, move dying process's number to r1
 044B  88 A7 2699 R	      C 	mov	byte ptr [BX]+p.stat-1, ah ; 0, SFREE, 05/02/2014
			      C 		; clrb p.stat-1(r1) / free the process
			      C 	;shl	bx, 1
 044F  D0 E3		      C 	shl	bl, 1
			      C 		; asl r1 / use r1 for index into the below tables
 0451  8B 8F 2608 R	      C 	mov	cx, word ptr [BX]+p.pid-2
			      C 		; mov p.pid-2(r1),r3 / move dying process's name to r3
 0455  8B 97 2628 R	      C 	mov	dx, word ptr [BX]+p.ppid-2
			      C 		; mov p.ppid-2(r1),r4 / move its parents name to r4
			      C 	; xor 	bx, bx ; 0
 0459  32 DB		      C 	xor	bl, bl ; 0
			      C 		; clr r2
 045B  33 F6		      C 	xor	si, si ; 0
			      C 		; clr r5 / initialize reg
 045D			      C sysexit_2: ; 1:
			      C 	        ; / find children of this dying process, 
			      C 		; / if they are zombies, free them
			      C 	;add	bx, 2
 045D  80 C3 02		      C 	add	bl, 2
			      C 		; add $2,r2 / search parent process table 
			      C 		          ; / for dying process's name
 0460  39 8F 2628 R	      C 	cmp	word ptr [BX]+p.ppid-2, cx
			      C 		; cmp p.ppid-2(r2),r3 / found it?
 0464  75 0F		      C 	jne	short sysexit_4
			      C 		; bne 3f / no
			      C 	;shr	bx, 1
 0466  D0 EB		      C 	shr	bl, 1
			      C 		; asr r2 / yes, it is a parent
 0468  80 BF 2699 R 03	      C 	cmp	byte ptr [BX]+p.stat-1, 3 ; SZOMB, 05/02/2014
			      C 		; cmpb p.stat-1(r2),$3 / is the child of this 
			      C 				     ; / dying process a zombie
 046D  75 04		      C 	jne	short sysexit_3 
			      C 		; bne 2f / no
 046F  88 A7 2699 R	      C 	mov	byte ptr [BX]+p.stat-1, ah ; 0, SFREE, 05/02/2014
			      C 		; clrb p.stat-1(r2) / yes, free the child process
 0473			      C sysexit_3: ; 2:
			      C 	;shr	bx, 1
 0473  D0 E3		      C 	shl	bl, 1
			      C 		; asl r2
 0475			      C sysexit_4: ; 3:
			      C 		; / search the process name table 
			      C 		; / for the dying process's parent
 0475  39 97 2608 R	      C 	cmp	word ptr [BX]+p.pid-2, dx ; 17/09/2013	
			      C 		; cmp p.pid-2(r2),r4 / found it?
 0479  75 02		      C 	jne	short sysexit_5
			      C 		; bne 3f / no
 047B  8B F3		      C 	mov	si, bx
			      C 		; mov r2,r5 / yes, put index to p.pid table (parents
			      C 		          ; / process # x2) in r5
 047D			      C sysexit_5: ; 3:
			      C 	;cmp	bx, nproc + nproc
 047D  80 FB 20		      C 	cmp	bl, nproc + nproc
			      C 		; cmp r2,$nproc+nproc / has whole table been searched?
 0480  72 DB		      C 	jb	short sysexit_2
			      C 		; blt 1b / no, go back
			      C 		; mov r5,r1 / yes, r1 now has parents process # x2
 0482  23 F6		      C 	and	si, si ; r5=r1
 0484  74 25		      C 	jz	short sysexit_6
			      C 		; beq 2f / no parent has been found. 
			      C 		       ; / The process just dies
 0486  D1 EE		      C 	shr	si, 1
			      C 		; asr r1 / set up index to p.stat
 0488  8A 84 2699 R	      C 	mov	al, byte ptr [SI]+p.stat-1
			      C 		; movb p.stat-1(r1),r2 / move status of parent to r2
 048C  22 C0		      C 	and	al, al
 048E  74 1B		      C 	jz	short sysexit_6
			      C 		; beq 2f / if its been freed, 2f
 0490  3C 03		      C 	cmp	al, 3
			      C 		; cmp r2,$3 / is parent a zombie?
 0492  74 17		      C 	je	short sysexit_6
			      C 		; beq 2f / yes, 2f
			      C 	; BH = 0
 0494  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno]
			      C 		; movb u.uno,r3 / move dying process's number to r3
 0498  C6 87 2699 R 03	      C 	mov	byte ptr [BX]+p.stat-1, 3 
			      C 		; movb $3,p.stat-1(r3) / make the process a zombie
			      C 	; 05/02/2014
 049D  3C 01		      C 	cmp	al, 1 ; SRUN
 049F  74 0A		      C 	je	short sysexit_6
			      C 	;cmp	al, 2
			      C 		; cmp r2,$2 / is the parent waiting for 
			      C 			  ; / this child to die
			      C 	;jne	short sysexit_6	
			      C 		; bne 2f / yes, notify parent not to wait any more
			      C 	; 05/02/2014
			      C 	; p.stat = 2 --> waiting
			      C 	; p.stat = 4 --> sleeping
 04A1  C6 84 2699 R 01	      C 	mov	byte ptr [SI]+p.stat-1, 1 ; SRUN ; 05/02/2014
			      C 	;dec	byte ptr [SI]+p.stat-1
			      C 		; decb	p.stat-1(r1) / awaken it by putting it (parent)
 04A6  8B C6		      C 	mov	ax, si ; r1 (process number in AL)
			      C 	; 14/02/2014
			      C 	;mov	bx, offset runq + 4
			      C 		; mov $runq+4,r2 / on the runq
 04A8  E8 0ADB		      C 	call	putlu
			      C 		; jsr r0, putlu
 04AB			      C sysexit_6: ; 2:
			      C 		; / the process dies
 04AB  C6 06 27DF R 00	      C 	mov	byte ptr [u.uno], 0
			      C 		; clrb u.uno / put zero as the process number, 
			      C 	          	   ; / so "swap" will
 04B0  E8 0A3F		      C 	call	swap
			      C 		; jsr r0,swap / overwrite process with another process
			      C 	; 30/08/2013
			      C 	;mov	sp, word ptr [u.sp_] ; Retro Unix 8086 v1 modification!
			      C 	;jmp	@b
			      C         ;;jmp	swapret ; Retro UNIX 8086 v1 modification !
 04B3			      C hlt_sys:
			      C 	;sti ; 18/01/2014
 04B3			      C @@:
 04B3  F4		      C 	hlt
			      C 	;jmp 	short hlt_sys
 04B4  EB FD		      C 	jmp	short @b
			      C 		; 0 / and thereby kill it; halt?
			      C 
 04B6			      C syswait: ; < wait for a processs to die >
			      C 	; 05/02/2014
			      C 	; 10/12/2013
			      C 	; 04/11/2013 
			      C 	; 30/10/2013
			      C 	; 23/10/2013
			      C 	; 24/05/2013
			      C 	; 'syswait' waits for a process die. 
			      C 	; It works in following way:
			      C 	;    1) From the parent process number, the parent's 
			      C 	; 	process name is found. The p.ppid table of parent
			      C 	;	names is then searched for this process name.
			      C 	;	If a match occurs, r2 contains child's process
			      C 	;	number. The child status is checked to see if it is
			      C 	;	a zombie, i.e; dead but not waited for (p.stat=3)
			      C 	;	If it is, the child process is freed and it's name
			      C 	;	is put in (u.r0). A return is then made via 'sysret'.
			      C 	;	If the child is not a zombie, nothinh happens and
			      C 	;	the search goes on through the p.ppid table until
			      C 	;	all processes are checked or a zombie is found.
			      C 	;    2) If no zombies are found, a check is made to see if
			      C 	;	there are any children at all. If there are none,
			      C 	;	an error return is made. If there are, the parent's
			      C 	;	status is set to 2 (waiting for child to die),
			      C 	;	the parent is swapped out, and a branch to 'syswait'
			      C 	;	is made to wait on the next process.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	?
			      C 	; Arguments:
			      C 	;	-
			      C 	; Inputs: - 
			      C 	; Outputs: if zombie found, it's name put in u.r0.	
			      C 	; ...............................................................
			      C 	;				
			      C 	
			      C ; / wait for a process to die
 04B6			      C syswait_0:
 04B6  32 FF		      C 	xor	bh, bh
 04B8  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno]
			      C 		; movb u.uno,r1 / put parents process number in r1
 04BC  D0 E3		      C 	shl	bl, 1
			      C 	;shl	bx, 1
			      C 		; asl r1 / x2 to get index into p.pid table
 04BE  8B 87 2608 R	      C 	mov	ax, word ptr [BX]+p.pid-2
			      C 		; mov p.pid-2(r1),r1 / get the name of this process
 04C2  33 F6		      C 	xor	si, si
			      C 		; clr r2
 04C4  33 C9		      C 	xor	cx, cx ; 30/10/2013
			      C 	;xor 	cl, cl
			      C 		; clr r3 / initialize reg 3
 04C6			      C syswait_1: ; 1:
 04C6  83 C6 02		      C 	add	si, 2
			      C 		; add $2,r2 / use r2 for index into p.ppid table
			      C 			  ; / search table of parent processes 
			      C 			  ; / for this process name
 04C9  3B 84 2628 R	      C 	cmp	ax, word ptr [SI]+p.ppid-2
			      C 		; cmp p.ppid-2(r2),r1 / r2 will contain the childs 
			      C 			            ; / process number
 04CD  75 1D		      C 	jne	short syswait_3
			      C 		;bne 3f / branch if no match of parent process name
			      C 	;inc	cx
 04CF  FE C1		      C 	inc	cl
			      C 		;inc r3 / yes, a match, r3 indicates number of children
 04D1  D1 EE		      C 	shr	si, 1
			      C 		; asr r2 / r2/2 to get index to p.stat table
			      C 	; The possible states ('p.stat' values) of a process are:
			      C 	;	0 = free or unused
			      C 	;	1 = active
			      C 	;	2 = waiting for a child process to die
			      C 	;	3 = terminated, but not yet waited for (zombie).	
 04D3  80 BC 2699 R 03	      C 	cmp	byte ptr [SI]+p.stat-1, 3 ; SZOMB, 05/02/2014
			      C 		; cmpb p.stat-1(r2),$3 / is the child process a zombie?
 04D8  75 10		      C 	jne	short syswait_2
			      C 		; bne 2f / no, skip it
 04DA  88 BC 2699 R	      C 	mov	byte ptr [SI]+p.stat-1, bh ; 0
			      C 		; clrb p.stat-1(r2) / yes, free it
 04DE  D1 E6		      C 	shl	si, 1
			      C 		; asl r2 / r2x2 to get index into p.pid table
 04E0  8B 84 2608 R	      C 	mov	ax, word ptr [SI]+p.pid-2
 04E4  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 		; mov p.pid-2(r2),*u.r0 
			      C 			      ; / put childs process name in (u.r0)
 04E7  E9 FE26		      C 	jmp	sysret
			      C 		; br sysret1 / return cause child is dead
 04EA			      C syswait_2: ; 2:
 04EA  D1 E6		      C 	shl	si, 1
			      C 		; asl r2 / r2x2 to get index into p.ppid table
 04EC			      C syswait_3: ; 3:
 04EC  83 FE 20		      C 	cmp	si, nproc+nproc
			      C 		; cmp r2,$nproc+nproc / have all processes been checked?
 04EF  72 D5		      C 	jb	syswait_1
			      C 		; blt 1b / no, continue search
			      C 	;and	cx, cx
 04F1  22 C9		      C 	and	cl, cl
			      C 		; tst r3 / one gets here if there are no children 
			      C 		       ; / or children that are still active
			      C 	; 30/10/2013
 04F3  75 07		      C 	jnz	short @f
			      C 	;jz	error
			      C 		; beq error1 / there are no children, error
 04F5  89 0E 27A8 R	      C 	mov	word ptr [u.r0], cx ; 0
 04F9  E9 FDF7		      C 	jmp	error
 04FC			      C @@:
 04FC  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno]
			      C 		; movb u.uno,r1 / there are children so put 
			      C 			      ; / parent process number in r1
 0500  FE 87 2699 R	      C 	inc	byte ptr [BX]+p.stat-1 ; 2, SWAIT, 05/02/2014
			      C 		; incb p.stat-1(r1) / it is waiting for 
			      C 				  ; / other children to die
			      C 	; 04/11/2013
 0504  E8 09EB		      C 	call	swap
			      C 		; jsr r0,swap / swap it out, because it's waiting
 0507  EB AD		      C 	jmp	syswait_0
			      C 		; br syswait / wait on next process
			      C 
 0509			      C sysfork: ; < create a new process >
			      C 	; 26/02/2022
			      C 	; 14/02/2014
			      C 	; 05/02/2014
			      C 	; 07/12/2013
			      C 	; 06/12/2013
			      C 	; 18/11/2013
			      C 	; 17/09/2013
			      C 	; 16/09/2013
			      C 	; 30/08/2013
			      C 	; 08/08/2013
			      C 	; 22/07/2013
			      C 	; 26/05/2013
			      C 	; 24/05/2013
			      C 	; 'sysfork' creates a new process. This process is referred
			      C 	; to as the child process. This new process core image is
			      C 	; a copy of that of the caller of 'sysfork'. The only
			      C 	; distinction is the return location and the fact that (u.r0)
			      C 	; in the old process (parent) contains the process id (p.pid)
			      C 	; of the new process (child). This id is used by 'syswait'.
			      C 	; 'sysfork' works in the following manner: 	
			      C 	;    1) The process status table (p.stat) is searched to find
			      C 	;	a process number that is unused. If none are found
			      C 	;	an error occurs.
			      C 	;    2) when one is found, it becomes the child process number
			      C 	;	and it's status (p.stat) is set to active.
			      C 	;    3) If the parent had a control tty, the interrupt 
			      C 	;	character in that tty buffer is cleared.
			      C 	;    4) The child process is put on the lowest priority run 
			      C 	;	queue via 'putlu'.
			      C 	;    5) A new process name is gotten from 'mpid' (actually 
			      C 	;	it is a unique number) and is put in the child's unique
			      C 	;	identifier; process id (p.pid).
			      C 	;    6) The process name of the parent is then obtained and
			      C 	;	placed in the unique identifier of the parent process
			      C 	;	name is then put in 'u.r0'.	
			      C 	;    7) The child process is then written out on disk by
			      C 	;	'wswap',i.e., the parent process is copied onto disk
			      C 	;	and the child is born. (The child process is written 
			      C 	;	out on disk/drum with 'u.uno' being the child process
			      C 	;	number.)
			      C 	;    8) The parent process number is then restored to 'u.uno'.
			      C 	;    9) The child process name is put in 'u.r0'.
			      C 	;   10) The pc on the stack sp + 18 is incremented by 2 to
			      C 	;	create the return address for the parent process.
			      C 	;   11) The 'u.fp' list as then searched to see what files
			      C 	;	the parent has opened. For each file the parent has
			      C 	;	opened, the corresponding 'fsp' entry must be updated
			      C 	;	to indicate that the child process also has opened
			      C 	;	the file. A branch to 'sysret' is then made.	 			 				
			      C 	;
			      C 	; Calling sequence:
			      C 	;	from shell ?
			      C 	; Arguments:
			      C 	;	-
			      C 	; Inputs: -
			      C 	; Outputs: *u.r0 - child process name
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	AX = r0 = PID (>0) (at the return of 'sysfork')
			      C 	;	= process id of child a parent process returns
			      C 	;	= process id of parent when a child process returns
			      C 	;
			      C 	;       In original UNIX v1, sysfork is called and returns as
			      C 	;	in following manner: (with an example: c library, fork)
			      C 	;	
			      C 	;	1:
			      C 	;		sys	fork
			      C 	;			br 1f  / child process returns here
			      C 	;		bes	2f     / parent process returns here
			      C 	;		/ pid of new process in r0
			      C 	;		rts	pc
			      C 	;	2: / parent process condionally branches here
			      C 	;		mov	$-1,r0 / pid = -1 means error return
			      C 	;		rts	pc
			      C 	;
			      C 	;	1: / child process brances here
			      C 	;		clr	r0   / pid = 0 in child process
			      C 	;		rts	pc
			      C 	;
			      C 	;	In UNIX v7x86 (386) by Robert Nordier (1999)
			      C 	;		// pid = fork();
			      C 	;		//
			      C 	;		// pid == 0 in child process; 
			      C 	;		// pid == -1 means error return
			      C 	;		// in child, 
			      C 	;		//	parents id is in par_uid if needed
			      C 	;		
			      C 	;		_fork:
			      C 	;			mov	$.fork,eax
			      C 	;			int	$0x30
			      C 	;			jmp	1f
			      C 	;			jnc	2f
			      C 	;			jmp	cerror
			      C 	;		1:
			      C 	;			mov	eax,_par_uid
			      C 	;			xor	eax,eax
			      C 	;		2:
			      C 	;			ret
			      C 	;
			      C 	;	In Retro UNIX 8086 v1,
			      C 	;	'sysfork' returns in following manner:
			      C 	;	
			      C 	;		mov	ax, sys_fork
			      C 	;		mov	bx, offset @f ; routine for child
			      C 	;		int	20h
			      C 	;		jc	error
			      C 	;		
			      C 	;	; Routine for parent process here (just after 'jc')
			      C 	;		mov	word ptr [pid_of_child], ax
			      C 	;		jmp	next_routine_for_parent	
			      C 	;
			      C 	;	@@: ; routine for child process here				
			      C 	;		....	
			      C 	;	NOTE: 'sysfork' returns to specified offset
			      C 	;	       for child process by using BX input.
			      C 	;	      (at first, parent process will return then 
			      C 	;	      child process will return -after swapped in-
			      C 	;	      'syswait' is needed in parent process
			      C 	;	      if return from child process will be waited for.)
			      C 	;	  				
			      C 	
			      C ; / create a new process
			      C 	; BX = return address for child process 
			      C 	     ; (Retro UNIX 8086 v1 modification !)
 0509  33 F6		      C 	xor 	si, si
			      C 		; clr r1
 050B			      C sysfork_1: ; 1: / search p.stat table for unused process number
 050B  46		      C 	inc	si
			      C 		; inc r1
 050C  80 BC 2699 R 00	      C 	cmp	byte ptr [SI]+p.stat-1, 0 ; SFREE, 05/02/2014
			      C 		; tstb p.stat-1(r1) / is process active, unused, dead
 0511  76 08		      C 	jna	short sysfork_2	
			      C 		; beq 1f / it's unused so branch
 0513  83 FE 10		      C 	cmp	si, nproc
			      C 		; cmp r1,$nproc / all processes checked
 0516  72 F3		      C 	jb	short sysfork_1	; 08/08/2013
			      C 		; blt 1b / no, branch back
			      C 	; Retro UNIX 8086 v1. modification:
			      C 	;	Parent process returns from 'sysfork' to address 
			      C 	;	which is just after 'sysfork' system call in parent
			      C 	;	process. Child process returns to address which is put
			      C 	;	in BX register by parent process for 'sysfork' 
			      C 	;	system call. 
			      C 	;	so, it is not needed to increment return address 
			      C 	;	of system call on the top of the user's stack.
			      C 	;	If the routine would be same with original UNIX v1 
			      C 	;	'sysfork' routine, 'add word ptr [SP]+12, 2'
			      C 	;	instruction would be put here. 
			      C 	;;	add word ptr [SP]+12, 2
			      C 	;;	jmp error
			      C 		;add $2,18.(sp) / add 2 to pc when trap occured, points
			      C 		             ; / to old process return
			      C 		; br error1 / no room for a new process
 0518  E9 FDD8		      C 	jmp	error ; 08/08/2013
 051B			      C sysfork_2: ; 1:
			      C 	; Retro UNIX 8086 v1. modification !
			      C 	; 08/08/2013
 051B  B8 0310 R	      C 	mov	ax, offset sysret
 051E  50		      C 	push	ax ; *
 051F  89 26 27A6 R	      C 	mov	word ptr [u.usp], sp
			      C 	;
			      C 	;;push	es
			      C         ; 08/08/2013
			      C 	; Return address for the parent process is already set
			      C 	; by sysenter routine.
			      C 	;mov	ax, word ptr [u.segmnt]
			      C 	;mov	es, ax
			      C 	;mov 	bp, sp	
			      C 	;mov	di, word ptr [BP]+12 ; user's stack pointer  
			      C 	;;pop	es
			      C 	;push 	word ptr ES:[DI]
			      C 	;;;mov	ax, word ptr ES:[DI] ; return address (IP)
			      C 	;;;push	ax  ; **** return address for the parent process
			      C 	;;mov	ax, cs
			      C 	;;mov	es, ax
			      C 	;;
 0523  FF 36 27E0 R	      C 	push	word ptr [u.segmnt] ; **
			      C 				; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; 06/12/2013
			      C 	;push	word ptr [u.uno] ; ***
			      C 		; movb u.uno,-(sp) / save parent process number
 0527  32 E4		      C 	xor	ah, ah
 0529  A0 27DF R	      C 	mov	al, byte ptr [u.uno] ; parent process number
 052C  50		      C 	push	ax ; ***
 052D  8B F8		      C 	mov	di, ax
			      C 	; 07/12/2013
 052F  8A 85 2669 R	      C         mov     al, byte ptr [DI]+p.ttyc-1 ; console tty (parent)
 0533  88 84 2669 R	      C         mov     byte ptr [SI]+p.ttyc-1, al ; set child's console tty
			      C 	; 05/02/2014 (p.ttys has been removed)
			      C         ;mov	byte ptr [SI]+p.ttys-1, al ; set parent's console tty
			      C 	; 26/02/2022 (p.waitc is not used)
			      C 	;mov     byte ptr [SI]+p.waitc-1, al 
			      C 	; 22/07/2013
 0537  8B C6		      C 	mov	ax, si
 0539  A2 27DF R	      C 	mov	byte ptr [u.uno], al
			      C 	;
			      C 	;mov	word ptr [u.uno], si
			      C 		;movb r1,u.uno / set child process number to r1
 053C  FE 84 2699 R	      C 	inc	byte ptr [SI]+p.stat-1 ; 1, SRUN, 05/02/2014
			      C 		; incb p.stat-1(r1) / set p.stat entry for child 
			      C 				; / process to active status
			      C 		; mov u.ttyp,r2 / put pointer to parent process' 
			      C 			      ; / control tty buffer in r2
			      C 	;;and	di, di
			      C 	;;jz	short sysfork_3	
			      C                 ; beq 2f / branch, if no such tty assigned
			      C 	;; ????
			      C 		; clrb 6(r2) / clear interrupt character in tty buffer
 0540			      C sysfork_3: ; 2:
 0540  53		      C 	push	bx  ; * return address for the child process
			      C 		    ; * Retro UNIX 8086 v1 feature only !	
			      C 	;;mov	ax, si ;; 22/07/2013
			      C 	; 14/02/2014
			      C 	;mov	bx, offset runq + 2 ; middle priority !
			      C 		; (Retro UNIX 8086 v1 modification!)
			      C 		; mov $runq+4,r2
 0541  E8 0A42		      C 	call	putlu 
			      C  		; jsr r0,putlu / put child process on lowest priority 
			      C 			     ; / run queue
 0544  D1 E6		      C 	shl	si, 1
			      C 		; asl r1 / multiply r1 by 2 to get index 
			      C 		       ; / into p.pid table
 0546  FF 06 26EE R	      C 	inc	word ptr [mpid]
			      C 		; inc mpid / increment m.pid; get a new process name
 054A  A1 26EE R	      C 	mov	ax, word ptr [mpid]
 054D  89 84 2608 R	      C 	mov	word ptr [SI]+p.pid-2, ax
			      C 		;mov mpid,p.pid-2(r1) / put new process name 
			      C 				    ; / in child process' name slot
 0551  5A		      C 	pop	dx  ; * return address for the child process
			      C 		    ; * Retro UNIX 8086 v1 feature only !	
			      C        	
			      C 	; 08/08//2013
 0552  5B		      C 	pop	bx ; ***
 0553  53		      C 	push 	bx ; ***
			      C 	;mov	bp, sp
			      C         ;mov	bx, word ptr [BP] ; ***
			      C 		; movb (sp),r2 / put parent process number in r2
 0554  32 FF		      C 	xor 	bh, bh ; 08/08/2013 
 0556  D1 E3		      C 	shl 	bx, 1
			      C 		;asl r2 / multiply by 2 to get index into below tables
 0558  8B 87 2608 R	      C 	mov	ax, word ptr [BX]+p.pid-2
			      C 		; mov p.pid-2(r2),r2 / get process name of parent
			      C 				   ; / process
 055C  89 84 2628 R	      C 	mov	word ptr [SI]+p.ppid-2, ax
			      C 		; mov r2,p.ppid-2(r1) / put parent process name 
			      C 			  ; / in parent process slot for child
 0560  A3 27A8 R	      C 	mov	word ptr [u.r0], ax	
			      C 		; mov r2,*u.r0 / put parent process name on stack 
			      C 			     ; / at location where r0 was saved
			      C 	; 22/07/2013
 0563  E8 0063		      C 	call	segm_sw  ; User segment switch
			      C 	; BX = New user segment ; 24/07/2013
			      C 	;
 0566  A1 27E0 R	      C 	mov 	ax, word ptr [u.segmnt] ; 08/08/2013
 0569  89 1E 27E0 R	      C 	mov	word ptr [u.segmnt], bx ; 24/07/2013
 056D  8E C3		      C 	mov	es, bx
 056F  33 F6		      C 	xor	si, si
 0571  33 FF		      C 	xor 	di, di
 0573  B9 4000		      C 	mov	cx, 16384
 0576  8E D8		      C 	mov	ds, ax ; 08/08/2013
 0578  F3/ A5		      C 	rep	movsw ; copy process (in current segment) to 
			      C 		      ;	new process segment
			      C 	; 08/08/2013
 057A  8C C8		      C 	mov	ax, cs
 057C  8E D8		      C 	mov	ds, ax
 057E  8B C3		      C 	mov	ax, bx ; new user segment
 0580  8B 2E 27A4 R	      C 	mov 	bp, word ptr [u.sp_]
 0584  8B 5E 0C		      C 	mov	bx, word ptr [BP]+12 ; user's stack pointer  
 0587  26: 89 17	      C 	mov	word ptr ES:[BX], dx ; *, CS:IP -> IP
			      C 			   ; * return address for the child process
 058A  26: 89 47 02	      C 	mov	word ptr ES:[BX]+2, ax ; CS:IP -> CS
			      C 			   ; * return address for the child process
			      C 	;mov	ax, cs
			      C 	;mov	es, ax
			      C 	;*
			      C 	;;mov	ax, offset sysret
			      C 	;;push	ax ; *
			      C 		; mov $sysret1,-(sp) /
			      C 	;mov	word ptr [u.usp], sp	
			      C 		; mov sp,u.usp / contents of sp at the time when 
			      C 			      ; / user is swapped out
			      C 		; mov $sstack,sp / point sp to swapping stack space
			      C 	; ES = u.segmnt
			      C 	; 06/12/2013
			      C 	;push	word ptr [u.intr] ; ****
			      C 	; 30/08/2013
 058E  FF 36 27C6 R	      C 	push	word ptr [u.ttyp] ; *****
 0592  33 C0		      C 	xor 	ax, ax
 0594  A3 27C6 R	      C 	mov 	word ptr [u.ttyp], ax ; 0
			      C 	;
 0597  E8 099F		      C 	call	wswap ; Retro UNIX 8086 v1 modification !
			      C 		;jsr r0,wswap / put child process out on drum
			      C 		;jsr r0,unpack / unpack user stack
			      C 		;mov u.usp,sp / restore user stack pointer
			      C 	; ES = DS
			      C 	;;mov	sp, word ptr [u.usp]
			      C 	; 30/08/2013
 059A  8F 06 27C6 R	      C 	pop	word ptr [u.ttyp] ; *****
			      C 	; 06/12/2013
			      C 	;pop 	word ptr [u.intr] ; ****
			      C 	;;pop	ax ; *
			      C 		; tst (sp)+ / bump stack pointer
			      C 	;pop	word ptr [u.uno] ; ***
 059E  58		      C 	pop	ax ; *** 22/07/2013
 059F  A2 27DF R	      C 	mov	byte ptr [u.uno], al 
			      C 		; movb (sp)+,u.uno / put parent process number in u.uno
			      C 	;
 05A2  8F 06 27E0 R	      C 	pop	word ptr [u.segmnt] ; **
			      C 				; Retro UNIX 8086 v1 feature only !
			      C 	;
 05A6  A1 26EE R	      C 	mov	ax, word ptr [mpid]
 05A9  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 		; mov mpid,*u.r0 / put child process name on stack 
			      C 			       ; / where r0 was saved
			      C 	; 08/08/2013
			      C 	; Return address for the parent process is already set
			      C 	; by sysenter routine.
			      C 	;pop	dx ; **** return address for the parent process
			      C 	;mov	ax, word ptr [u.segmnt]
			      C 	;mov	es, ax
			      C 	;mov	word ptr ES:[BX]+2, ax ; user's CS for iret <- ax
			      C 	;mov	word ptr ES:[BX], dx ; user's IP for iret <- dx 
			      C 		; add $2,18.(sp) / add 2 to pc on stack; gives parent
			      C 			          ; / process return
			      C 	;pop 	ax ; * 08/08/2013 
			      C         ;
 05AC  33 F6		      C         xor     si, si
			      C 		;clr r1
 05AE			      C sysfork_4: ; 1: / search u.fp list to find the files 
			      C 	      ; / opened by the parent process
 05AE  8A 9C 27AC R	      C         mov     bl, byte ptr [SI]+u.fp
			      C 		; movb u.fp(r1),r2 / get an open file for this process
 05B2  0A DB		      C         or      bl, bl
 05B4  74 0C		      C 	jz	short sysfork_5	
			      C 		; beq 2f / file has not been opened by parent, 
			      C 		       ; / so branch
 05B6  32 FF		      C 	xor     bh, bh ; 18/11/2013
 05B8  D1 E3		      C         shl     bx, 1
			      C 		; asl r2 / multiply by 8
 05BA  D1 E3		      C         shl     bx, 1 
			      C 		; asl r2 / to get index into fsp table
 05BC  D1 E3		      C         shl     bx, 1 
			      C 		; asl r2
 05BE  FF 87 2892 R	      C         inc     byte ptr [BX]+fsp-2
			      C 		; incb fsp-2(r2) / increment number of processes
			      C 			     ; / using file, because child will now be
			      C 			     ; / using this file
 05C2			      C sysfork_5: ; 2:
 05C2  46		      C         inc     si
			      C 		; inc r1 / get next open file
 05C3  83 FE 0A		      C         cmp     si, 10
			      C 		; cmp r1,$10. / 10. files is the maximum number which
			      C 			  ; / can be opened
 05C6  72 E6		      C 	jb	short sysfork_4	
			      C 		; blt 1b / check next entry
			      C 	; 08/08/2013
 05C8  C3		      C 	retn	; * -> sysret
			      C 	;jmp	sysret
			      C 		; br sysret1
			      C 
 05C9			      C segm_sw:
			      C 	; 24/07/2013
			      C 	; 23/07/2013
			      C 	; 22/07/2013 
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	; (User segment switch)
			      C 	; INPUT -> none
			      C 	; OUTPUT -> bx = new user segment
			      C 	;           (word ptr [u.segmnt] = ax)
			      C 	; ((Modified registers: cx))
			      C 	;
 05C9  8A 0E 27DF R	      C 	mov	cl, byte ptr [u.uno] ; 23/07/2013
 05CD  BB 2000		      C 	mov	bx, csgmnt ; segment of process 1
 05D0			      C @@:
 05D0  FE C9		      C 	dec	cl
 05D2  74 06		      C 	jz	short @f
 05D4  81 C3 0800	      C 	add	bx, 2048  ; (32768/16)
 05D8  EB F6		      C 	jmp	short @b	
 05DA			      C @@:		
			      C 	;;mov	word ptr [u.segmnt], bx ;; 24/07/2013
 05DA  C3		      C 	retn
			      C 
			      C 
 05DB			      C sysread: ; < read from file >
			      C 	; 27/01/2022
			      C 	; 23/05/2013
			      C 	; 'sysread' is given a buffer to read into and the number of
			      C 	; characters to be read. If finds the file from the file
			      C 	; descriptor located in *u.r0 (r0). This file descriptor
			      C 	; is returned from a successful open call (sysopen).
			      C 	; The i-number of file is obtained via 'rw1' and the data
			      C 	; is read into core via 'readi'.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysread; buffer; nchars
			      C 	; Arguments:
			      C 	;	buffer - location of contiguous bytes where 
			      C 	;		 input will be placed.
			      C 	;	nchars - number of bytes or characters to be read.
			      C 	; Inputs: *u.r0 - file descriptor (& arguments)
			      C 	; Outputs: *u.r0 - number of bytes read.	
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysread' system call has three arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 3 is used
			      C 	;	to get sysread system call arguments from the user;
			      C 	;	* 1st argument, file descriptor is in BX register
			      C 	;	* 2nd argument, buffer address/offset in CX register
			      C 	;	* 3rd argument, number of bytes is in DX register
			      C 	;
			      C 	;	AX register (will be restored via 'u.r0') will return
			      C 	;	to the user with number of bytes read. 
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg' routine gets these
			      C 	;	      arguments in these registers;
			      C 	;	      (BX= file descriptor)
			      C 	;	      (CX= buffer address in user's program segment)	
			      C 	;	      (DX= number of bytes)
			      C 	;	      then
			      C 	;	      * file descriptor (in BX) is moved into AX
			      C 	;	      * buffer address (in CX) is moved into 'u.base'.
			      C 	;	      * byte count (in DX) is moved into 'u.count'.	
			      C 	;
 05DB  E8 0023		      C 	call	rw1
			      C 		; jsr r0,rw1 / get i-number of file to be read into r1
 05DE  F6 C4 80		      C 	test	ah, 80h
			      C 		; tst r1 / negative i-number?
			      C 	;jnz	error
			      C 		; ble error1 / yes, error 1 to read
			      C 			   ; / it should be positive
			      C 	; 27/01/2022
 05E1  75 0D		      C 	jnz	short rw_error
 05E3  E8 0D0D		      C 	call	readi
			      C 		; jsr r0,readi / read data into core
			      C 	;jmp	short @f
			      C 		; br 1f
 05E6  EB 10		      C 	jmp	short rw0 ; 27/01/2022
			      C 
 05E8			      C syswrite: ; < write to file >
			      C 	; 27/01/2022
			      C 	; 23/05/2013
			      C 	; 'syswrite' is given a buffer to write onto an output file
			      C 	; and the number of characters to write. If finds the file
			      C 	; from the file descriptor located in *u.r0 (r0). This file 
			      C 	; descriptor is returned from a successful open or create call
			      C 	; (sysopen or syscreat). The i-number of file is obtained via
			      C 	; 'rw1' and buffer is written on the output file via 'write'.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syswrite; buffer; nchars
			      C 	; Arguments:
			      C 	;	buffer - location of contiguous bytes to be written.
			      C 	;	nchars - number of characters to be written.
			      C 	; Inputs: *u.r0 - file descriptor (& arguments)
			      C 	; Outputs: *u.r0 - number of bytes written.	
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'syswrite' system call has three arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 3 is used
			      C 	;	to get syswrite system call arguments from the user;
			      C 	;	* 1st argument, file descriptor is in BX register
			      C 	;	* 2nd argument, buffer address/offset in CX register
			      C 	;	* 3rd argument, number of bytes is in DX register
			      C 	;
			      C 	;	AX register (will be restored via 'u.r0') will return
			      C 	;	to the user with number of bytes written. 
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg' routine gets these
			      C 	;	      arguments in these registers;
			      C 	;	      (BX= file descriptor)
			      C 	;	      (CX= buffer address in user's program segment)	
			      C 	;	      (DX= number of bytes)
			      C 	;	      then
			      C 	;	      * file descriptor (in BX) is moved into AX
			      C 	;	      * buffer address (in CX) is moved into 'u.base'.
			      C 	;	      * byte count (in DX) is moved into 'u.count'.	
			      C 	;
 05E8  E8 0016		      C 	call	rw1
			      C 		; jsr r0,rw1 / get i-number in r1 of file to write
 05EB  F6 C4 80		      C         test	ah, 80h
			      C 		; tst r1 / positive i-number ?
			      C         ;jz	error
			      C 		; bge error1 / yes, error 1 
			      C 			   ; / negative i-number means write
			      C 	; 27/01/2022
 05EE  75 03		      C 	jnz	short @f
 05F0			      C rw_error:
 05F0  E9 FD00		      C 	jmp	error
 05F3			      C @@:
 05F3  F7 D8		      C         neg	ax
			      C 		; neg r1 / make it positive
 05F5  E8 0DFA		      C 	call	writei
			      C         	; jsr r0,writei / write data
			      C ;@@: ; 1:
			      C 	; 27/01/2022
 05F8			      C rw0:
 05F8  A1 27C2 R	      C         mov	ax, word ptr [u.nread]
 05FB  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 		; mov u.nread,*u.r0 / put no. of bytes transferred
			      C 				  ; / into (u.r0)
 05FE  E9 FD0F		      C 	jmp	sysret
			      C         	; br sysret1
			      C 
			      C 	; 27/01/2022
 0601			      C rw1:	; 23/05/2013 
			      C 	; 'rw1' returns i-number of the file for 'sysread' & 'syswrite'.
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;      'arg' routine is different than 'arg' in original Unix v1.
			      C 	;mov	ax, 3 ; number of arguments
			      C 	;call	arg
			      C 	; 24/05/2013
			      C 	; System call registers: bx, cx, dx (through 'sysenter')
 0601  89 0E 27BE R	      C 	mov	word ptr [u.base], cx ; buffer address/offset 
			      C 				      ;	(in the user's program segment)
 0605  89 16 27C0 R	      C 	mov	word ptr [u.count], dx 
			      C 		;
			      C 		; jsr r0,arg; u.base / get buffer pointer
			      C         	; jsr r0,arg; u.count / get no. of characters
			      C 	;;mov	ax, bx ; file descriptor
			      C 		; mov *u.r0,r1 / put file descriptor 
			      C 		             ; / (index to u.fp table) in r1
			      C 	;; call	getf
			      C         ; BX = File descriptor
			      C 	;call	getf1 ; calling point in 'getf' from 'rw1'
			      C 	;	; jsr r0,getf / get i-number of the file in r1
			      C 	; AX = I-number of the file ; negative i-number means write
			      C 	;
			      C 	;retn
			      C         ;	; rts r0
			      C 	; 27/01/2022
 0609  E9 05F4		      C 	jmp	getf1
			      C 
 060C			      C sysopen: ;<open file>
			      C 	; 27/01/2022
			      C 	; 27/05/2013
			      C 	; 24/05/2013
			      C 	; 22/05/2013
			      C 	; 'sysopen' opens a file in following manner:
			      C 	;    1) The second argument in a sysopen says whether to
			      C 	;	open the file ro read (0) or write (>0).
			      C 	;    2) I-node of the particular file is obtained via 'namei'.
			      C 	;    3) The file is opened by 'iopen'.
			      C 	;    4) Next housekeeping is performed on the fsp table
			      C 	;	and the user's open file list - u.fp.
			      C 	;	a) u.fp and fsp are scanned for the next available slot.
			      C 	;	b) An entry for the file is created in the fsp table.
			      C 	;	c) The number of this entry is put on u.fp list.
			      C 	;	d) The file descriptor index to u.fp list is pointed
			      C 	;	   to by u.r0.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysopen; name; mode
			      C 	; Arguments:
			      C 	;	name - file name or path name
			      C 	;	mode - 0 to open for reading
			      C 	;	       1 to open for writing
			      C 	; Inputs: (arguments)
			      C 	; Outputs: *u.r0 - index to u.fp list (the file descriptor)
			      C 	;		  is put into r0's location on the stack.	
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysopen' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysopen system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, mode is in CX register
			      C 	;
			      C 	;	AX register (will be restored via 'u.r0') will return
			      C 	;	to the user with the file descriptor/number 
			      C 	;	(index to u.fp list).
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.)		 	
			      C 	
			      C 	;call	arg2
			      C 	; * name - 'u.namep' points to address of file/path name
			      C 	;          in the user's program segment ('u.segmnt')
			      C 	;          with offset in BX register (as sysopen argument 1).
			      C 	; * mode - sysopen argument 2 is in CX register 
			      C 	;          which is on top of stack.
			      C 	;
			      C 		; jsr r0,arg2 / get sys args into u.namep and on stack
			      C 	; 24/05/2013 
			      C        	; system call registers: bx, cx (through 'sysenter')
			      C 
 060C  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 0610  51		      C 	push	cx
 0611  E8 0619		      C 	call	namei
			      C 		; jsr r0,namei / i-number of file in r1
			      C      	;and	ax, ax
			      C 	;;jz	error ; File not found
			      C 	;jc	error ; 27/05/2013
			      C 		; br  error2 / file not found
			      C 	; 27/01/2022
 0614  73 03		      C 	jnc	short @f
 0616  E9 FCDA		      C 	jmp	error
 0619			      C @@:
 0619  5A		      C    	pop	dx ; mode
 061A  52		      C 	push	dx
			      C 	;or	dx, dx
 061B  0A D2		      C 	or	dl, dl
			      C 		; tst (sp) / is mode = 0 (2nd arg of call; 
			      C 		         ; / 0 means, open for read)
 061D  74 02		      C 	jz	short @f
			      C 		; beq 1f / yes, leave i-number positive
 061F  F7 D8		      C 	neg	ax
			      C         	; neg r1 / open for writing so make i-number negative
 0621			      C @@: ;1:
 0621  E8 1043		      C 	call	iopen
			      C 		;jsr r0,iopen / open file whose i-number is in r1
 0624  5A		      C 	pop	dx
			      C 	;and	dx, dx
 0625  22 D2		      C 	and	dl, dl
			      C         	; tst (sp)+ / pop the stack and test the mode
 0627  74 02		      C 	jz	short @f
			      C         	; beq op1 / is open for read op1
 0629			      C op0:
 0629  F7 D8		      C 	neg	ax
			      C         	; neg r1 
			      C 		     ;/ make i-number positive if open for writing [???]
			      C 	;; NOTE: iopen always make i-number positive.
			      C 	;; Here i-number becomes negative again
			      C 	;; perhaps iclose then makes it positive ??? E. Tan [22/05/2013]
 062B			      C @@: ;op1:
 062B  33 F6		      C         xor     si, si
			      C         	; clr r2 / clear registers
 062D  33 DB		      C         xor     bx, bx
			      C 		; clr r3
 062F			      C @@: ;1: / scan the list of entries in fsp table
 062F  38 9C 27AC R	      C         cmp     byte ptr [SI]+u.fp, bl ; 0
			      C 		; tstb u.fp(r2) / test the entry in the u.fp list
 0633  76 09		      C         jna	short @f
			      C 		; beq 1f / if byte in list is 0 branch
 0635  46		      C         inc     si
			      C 		; inc r2 / bump r2 so next byte can be checked
 0636  83 FE 0A		      C         cmp     si, 10
			      C 		; cmp r2,$10. / reached end of list?
 0639  72 F4		      C 	jb	short @b
			      C 		; blt 1b / no, go back
 063B  E9 FCB5		      C 	jmp	error
			      C         	; br error2 / yes, error (no files open)
 063E			      C @@: ; 1:
 063E  83 BF 2894 R 00	      C         cmp     word ptr [BX]+fsp, 0
			      C 		; tst fsp(r3) / scan fsp entries
 0643  76 0C		      C         jna     short @f
			      C 		; beq 1f / if 0 branch
 0645  83 C3 08		      C         add     bx, 8
			      C 		; add $8.,r3 / add 8 to r3 
			      C 			; / to bump it to next entry mfsp table
 0648  81 FB 0190	      C         cmp     bx, nfiles*8
			      C 		; cmp r3,$[nfiles*8.] / done scanning
 064C  72 F0		      C 	jb	short @b
			      C        		; blt 1b / no, back
 064E  E9 FCA2		      C 	jmp	error
			      C         	; br error2 / yes, error
 0651			      C @@: ; 1: / r2 has index to u.fp list; r3, has index to fsp table
 0651  89 87 2894 R	      C         mov     word ptr [BX]+fsp, ax
			      C 		; mov r1,fsp(r3) / put i-number of open file 
			      C 			; / into next available entry in fsp table,
 0655  8B 3E 26C2 R	      C 	mov	di, word ptr [cdev] ; word ? byte ?
 0659  89 BF 2896 R	      C         mov     word ptr [BX]+fsp+2, di
			      C 		; mov cdev,fsp+2(r3) / put # of device in next word
 065D  33 FF		      C         xor	di, di
 065F  89 BF 2898 R	      C         mov     word ptr [BX]+fsp+4, di
			      C 		; clr fsp+4(r3)
 0663  89 BF 289A R	      C         mov     word ptr [BX]+fsp+6, di
			      C        		; clr fsp+6(r3) / clear the next two words
 0667  D1 EB		      C         shr     bx, 1
			      C 		; asr r3
 0669  D1 EB		      C         shr     bx, 1
			      C 		; asr r3 / divide by 8 
 066B  D1 EB		      C         shr     bx, 1
			      C 		; asr r3 ; / to get number of the fsp entry-1
			      C         ;inc    bx
 066D  FE C3		      C         inc     bl        
			      C         	; inc r3 / add 1 to get fsp entry number
 066F  88 9C 27AC R	      C         mov     byte ptr [SI]+u.fp, bl
			      C 		; movb r3,u.fp(r2) / move entry number into 
			      C 			; / next available slot in u.fp list
 0673  89 36 27A8 R	      C         mov     word ptr [u.r0], si
			      C 		; mov r2,*u.r0 / move index to u.fp list 
			      C 			     ; / into r0 loc on stack
 0677  E9 FC96		      C         jmp	sysret
			      C 		; br sysret2
			      C 
 067A			      C syscreat: ; < create file >
			      C 	; 27/05/2013
			      C 	; 'syscreat' called with two arguments; name and mode.
			      C 	; u.namep points to name of the file and mode is put
			      C 	; on the stack. 'namei' is called to get i-number of the file.		
			      C 	; If the file aready exists, it's mode and owner remain 
			      C 	; unchanged, but it is truncated to zero length. If the file
			      C 	; did not exist, an i-node is created with the new mode via
			      C 	; 'maknod' whether or not the file already existed, it is
			      C 	; open for writing. The fsp table is then searched for a free
			      C 	; entry. When a free entry is found, proper data is placed
			      C 	; in it and the number of this entry is put in the u.fp list.
			      C 	; The index to the u.fp (also know as the file descriptor)
			      C 	; is put in the user's r0. 			
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syscreate; name; mode
			      C 	; Arguments:
			      C 	;	name - name of the file to be created
			      C 	;	mode - mode of the file to be created
			      C 	; Inputs: (arguments)
			      C 	; Outputs: *u.r0 - index to u.fp list 
			      C 	;		   (the file descriptor of new file)
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'syscreate' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get syscreate system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, mode is in CX register
			      C 	;
			      C 	;	AX register (will be restored via 'u.r0') will return
			      C 	;	to the user with the file descriptor/number 
			      C 	;	(index to u.fp list).
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.		 	
			      C 	
			      C 	;call	arg2
			      C 	; * name - 'u.namep' points to address of file/path name
			      C 	;          in the user's program segment ('u.segmnt')
			      C 	;          with offset in BX register (as sysopen argument 1).
			      C 	; * mode - sysopen argument 2 is in CX register 
			      C 	;          which is on top of stack.
			      C 	;
			      C         	; jsr r0,arg2 / put file name in u.namep put mode 
			      C 			    ; / on stack
 067A  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx ; file name address
 067E  51		      C 	push	cx ; mode
 067F  E8 05AB		      C 	call 	namei        	
			      C 		; jsr r0,namei / get the i-number
			      C         ;and	ax, ax
			      C 	;jz	short @f	       	
 0682  72 0B		      C 	jc	short @f
			      C 		; br  2f / if file doesn't exist 2f
 0684  F7 D8		      C 	neg 	ax
			      C         	; neg r1 / if file already exists make i-number 
			      C 		       ; / negative (open for writing)
 0686  E8 0FDE		      C 	call	iopen
			      C         	; jsr r0,iopen /
 0689  E8 0BE4		      C 	call	itrunc
			      C         	; jsr r0,itrunc / truncate to 0 length
 068C  59		      C 	pop	cx ; pop mode (did not exist in original Unix v1 !?)
 068D  EB 9A		      C 	jmp	short op0
			      C         	; br op0
 068F			      C @@: ; 2: / file doesn't exist
 068F  58		      C 	pop	ax
			      C         	; mov (sp)+,r1 / put the mode in r1
 0690  32 E4		      C 	xor	ah, ah	
			      C         	; bic $!377,r1 / clear upper byte
 0692  E8 0754		      C 	call 	maknod
			      C         	; jsr r0,maknod / make an i-node for this file
 0695  A1 27C8 R	      C 	mov	ax, word ptr [u.dirbuf]
			      C         	; mov u.dirbuf,r1 / put i-number 
			      C 			        ; / for this new file in r1
 0698  EB 8F		      C         jmp     short op0
			      C         	; br op0 / open the file
			      C 
 069A			      C sysmkdir: ; < make directory >
			      C 	; 27/01/2022 (BugFix)
			      C 	; 02/08/2013
			      C 	; 27/05/2013
			      C 	; 'sysmkdir' creates an empty directory whose name is
			      C 	; pointed to by arg 1. The mode of the directory is arg 2.	
			      C 	; The special entries '.' and '..' are not present.
			      C 	; Errors are indicated if the directory already exists or		
			      C 	; user is not the super user. 
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysmkdir; name; mode
			      C 	; Arguments:
			      C 	;	name - points to the name of the directory
			      C 	;	mode - mode of the directory
			      C 	; Inputs: (arguments)
			      C 	; Outputs: -
			      C 	;    (sets 'directory' flag to 1; 
			      C 	;    'set user id on execution' and 'executable' flags to 0)
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysmkdir' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysmkdir system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, mode is in CX register
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.		 	
			      C 	
			      C ; / make a directory
			      C 
			      C 	;call	arg2
			      C 	; * name - 'u.namep' points to address of file/path name
			      C 	;          in the user's program segment ('u.segmnt')
			      C 	;          with offset in BX register (as sysopen argument 1).
			      C 	; * mode - sysopen argument 2 is in CX register 
			      C 	;          which is on top of stack.
			      C 
			      C 		; jsr r0,arg2 / put file name in u.namep put mode 
			      C 			    ; / on stack
 069A  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 069E  51		      C 	push	cx
 069F  E8 058B		      C 	call	namei
			      C         	; jsr r0,namei / get the i-number
			      C         	;     br .+4 / if file not found branch around error
			      C 	;;xor 	ax, ax
			      C 	;;jnz	error
			      C 	;jnc	error	
			      C 		; br  error2 / directory already exists (error)
			      C 	; 27/01/2022
 06A2  72 03		      C 	jc	short @f
 06A4  E9 FC4C		      C 	jmp	error
 06A7			      C @@:
 06A7  80 3E 27DC R 00	      C 	cmp	byte ptr [u.uid_], 0 ; 02/08/2013
			      C         	;tstb u.uid / is user the super user
			      C 	;jna	error
			      C         	;bne error2 / no, not allowed
			      C 	; 27/01/2022 (BugFix)
 06AC  76 03		      C 	jna	short @f ; super user (can make directory)
 06AE  E9 FC42		      C 	jmp	error
 06B1			      C @@:
 06B1  58		      C 	pop	ax
			      C         	;mov (sp)+,r1 / put the mode in r1
 06B2  83 E0 CF		      C 	and	ax, 0FFCFh ; 1111111111001111b
			      C         	;bic $!317,r1 / all but su and ex
			      C 	;or	ax, 4000h ; 1011111111111111b
 06B5  80 CC 40		      C 	or	ah, 40h ; Set bit 14 to 1
			      C         	;bis $40000,r1 / directory flag
 06B8  E8 072E		      C 	call	maknod
			      C         	;jsr r0,maknod / make the i-node for the directory
 06BB			      C @@:
 06BB  E9 FC52		      C 	jmp	sysret
			      C         	;br sysret2 /
			      C 
 06BE			      C sysclose: ;<close file>
			      C 	; 27/01/2022
			      C 	; 26/05/2013
			      C 	; 22/05/2013
			      C 	; 'sysclose', given a file descriptor in 'u.r0', closes the
			      C 	; associated file. The file descriptor (index to 'u.fp' list)
			      C 	; is put in r1 and 'fclose' is called.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysclose
			      C 	; Arguments:
			      C 	;	-  
			      C 	; Inputs: *u.r0 - file descriptor
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;	 The user/application program puts file descriptor
			      C 	;        in BX register as 'sysclose' system call argument.
			      C 	; 	 (argument transfer method 1)
			      C 
			      C ; / close the file
			      C 	;;mov	ax, 1 ; one/single argument, put argument in BX
			      C 	;;call	arg
			      C 	;mov 	bx, word ptr [u.sp_] ; points to user's BP register
			      C 	;add 	bx, 6 ; bx now points to BX on stack
			      C 	;mov 	ax, word ptr [BX] 
			      C 		; mov *u.r0,r1 / move index to u.fp list into r1
 06BE  8B C3		      C 	mov 	ax, bx ; 26/05/2013
 06C0  E8 0506		      C 	call 	fclose
			      C 		; jsr r0,fclose / close the file
			      C 	;jc	error
			      C                	; br error2 / unknown file descriptor
			      C 	; 27/01/2022
			      C 	;jnc	short @f
 06C3  73 F6		      C 	jnc	short @b ; jmp sysret
 06C5  E9 FC2B		      C 	jmp	error
			      C ;@@:
			      C 	;jmp	sysret
			      C 		; br sysret2
			      C 
 06C8			      C sysemt:
			      C 	; 27/01/2022
			      C 	; 10/04/2014 Bugfix [u.uid --> u.uid_]
			      C 	; 18/01/2014
			      C 	; 10/12/2013
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	'Enable Multi Tasking' system call instead 
			      C 	;	of 'Emulator Trap' in original UNIX v1 for PDP-11.
			      C 	;
			      C 	; Retro UNIX 8086 v1 feature only!
			      C 	;	Using purpose: Kernel will start without time-out
			      C 	;	(internal clock/timer) functionality.
			      C 	;	Then etc/init will enable clock/timer for
			      C 	;	multi tasking. (Then it will not be disabled again
			      C 	;	except hardware reset/restart.)
			      C 	;
			      C 
 06C8  80 3E 27DC R 00	      C 	cmp	byte ptr [u.uid_], 0   ; BugFix u.uid --> u.uid_
			      C 	;ja	error
			      C 	; 27/01/2022
 06CD  76 03		      C 	jna	short @f ; super user
 06CF  E9 FC21		      C 	jmp	error
 06D2			      C @@:
 06D2  06		      C 	push	es
			      C 
 06D3  33 C0		      C 	xor 	ax, ax
 06D5  8E C0		      C 	mov 	es, ax ; 0
 06D7  BF 0070		      C 	mov 	di, 28*4 ; INT 1Ch vector - offset
			      C 	
			      C 	; 18/01/2014
 06DA  FA		      C 	cli
			      C 
 06DB  23 DB		      C 	and	bx, bx
 06DD  74 0C		      C 	jz	short emt_2
			      C 
			      C 	; Enable INT 1Ch time-out functionality.
 06DF  B8 0FC6 R	      C 	mov	ax, offset clock
 06E2			      C emt_1:
 06E2  AB		      C 	stosw   ; offset
 06E3  8C C8		      C 	mov	ax, cs
 06E5  AB		      C 	stosw	; segment
			      C 
			      C 	; 18/01/2014
 06E6  FB		      C 	sti
			      C 
 06E7  07		      C 	pop	es
 06E8  E9 FC25		      C 	jmp	sysret
 06EB			      C emt_2:
			      C 	; Disable INT 1Ch time-out functionality.
 06EB  B8 06F0 R	      C 	mov	ax, offset emt_iret
 06EE  EB F2		      C 	jmp	short emt_1	
			      C 
 06F0			      C emt_iret:
 06F0  CF		      C 	iret
			      C 
			      C 	; Original UNIX v1 'sysemt' routine
			      C ;sysemt:
			      C         ;
			      C 	;jsr    r0,arg; 30 / put the argument of the sysemt call 
			      C 			 ; / in loc 30
			      C         ;cmp    30,$core / was the argument a lower address 
			      C 			; / than core
			      C         ;blo    1f / yes, rtssym
			      C         ;cmp    30,$ecore / no, was it higher than "core" 
			      C 			; / and less than "ecore"
			      C         ;blo    2f / yes, sysret2
			      C ;1:
			      C         ;mov    $rtssym,30
			      C ;2:
			      C         ;br     sysret2
			      C 
 06F1			      C sysilgins:
			      C 	; 03/06/2013,
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	not a valid system call ! (not in use)
			      C 	;
 06F1  E9 FBFF		      C 	jmp	error
			      C 	;jmp 	sysret
			      C 
			      C 	; Original UNIX v1 'sysemt' routine
			      C ;sysilgins: / calculate proper illegal instruction trap address
			      C         ;jsr    r0,arg; 10 / take address from sysilgins call
			      C 			  ;/ put it in loc 8.,
			      C         ;cmp    10,$core / making it the illegal instruction 
			      C 		       ; / trap address
			      C         ;blo    1f / is the address a user core address?  
			      C 		; / yes, go to 2f
			      C         ;cmp    10,$ecore
			      C         ;blo    2f
			      C ;1:
			      C         ;mov    $fpsym,10 / no, make 'fpsum' the illegal 
			      C 		    ; / instruction trap address for the system
			      C ;2:
			      C         ;br     sysret2 / return to the caller via 'sysret'
			      C 
 06F4			      C sysmdate: ; < change the modification time of a file >
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 03/06/2013
			      C 	; 'sysmdate' is given a file name. It gets inode of this 
			      C 	; file into core. The user is checked if he is the owner 
			      C 	; or super user. If he is neither an error occurs.
			      C 	; 'setimod' is then called to set the i-node modification
			      C 	; byte and the modification time, but the modification time
			      C 	; is overwritten by whatever get put on the stack during
			      C 	; a 'systime' system call. This calls are restricted to
			      C 	; the super user.		
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysmdate; name
			      C 	; Arguments:
			      C 	;	name - points to the name of file
			      C 	; Inputs: (arguments)
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	 The user/application program puts address 
			      C 	;	 of the file name in BX register 
			      C 	;	 as 'sysmdate' system call argument.
			      C 	;
			      C ; / change the modification time of a file
			      C 		; jsr r0,arg; u.namep / point u.namep to the file name
 06F4  89 1E 27BA R	      C         mov	word ptr [u.namep], bx
 06F8  E8 0532		      C 	call	namei
			      C 		; jsr r0,namei / get its i-number
			      C 	;jc	error       
			      C 		; br error2 / no, such file
			      C 	; 27/01/2022
 06FB  72 1E		      C 	jc	short sysmdate_err
 06FD  E8 0A86		      C 	call	iget
			      C 		; jsr r0,iget / get i-node into core
 0700  A0 27DC R	      C 	mov	al, byte ptr [u.uid_] ; 02/08/2013
 0703  3A 06 25ED R	      C 	cmp	al, byte ptr [i.uid]
			      C         	; cmpb u.uid,i.uid / is user same as owner
 0707  74 04		      C 	je	short @f
			      C         	; beq 1f / yes
 0709  22 C0		      C 	and	al, al
			      C 		; tstb u.uid / no, is user the super user
			      C 	;jnz	error
			      C 		; bne error2 / no, error
			      C 	; 27/01/2022
 070B  75 0E		      C 	jnz	short sysmdate_err
 070D			      C @@: ;1:
 070D  E8 0B3B		      C 	call	setimod
			      C         	; jsr r0,setimod / fill in modification data,
			      C 		               ; / time etc.
			      C  	; Retro UNIX 8086 v1 modification !
 0710  BE 2720 R	      C 	mov	si, offset p_time
 0713  BF 2604 R	      C 	mov	di, offset i.mtim
 0716  A5		      C 	movsw
 0717  A5		      C 	movsw
			      C 		; mov 4(sp),i.mtim / move present time to
			      C         	; mov 2(sp),i.mtim+2 / modification time
 0718  E9 FBF5		      C         jmp	sysret
			      C 		; br sysret2
			      C 
			      C 	; 27/01/2022
 071B			      C sysmdate_err:
 071B			      C sysstty_err:
 071B  E9 FBD5		      C 	jmp	error
			      C 
			      C 	; 01/02/2022
			      C ;@@:
			      C ;	retn
			      C 
 071E			      C sysstty: ; < set tty status and mode >
			      C 	; 02/02/2022
			      C 	; 01/02/2022
			      C 	; 30/01/2022 (clear screen)
			      C 	; 27/01/2022
			      C 	; 12/07/2014
			      C 	; 04/07/2014
			      C 	; 26/06/2014
			      C 	; 15/04/2014
			      C 	; 18/01/2014
			      C 	; 17/01/2014
			      C 	; 16/01/2014
			      C 	; 14/01/2014
			      C 	; 13/01/2014
			      C 	; 12/01/2014
			      C 	; 07/12/2013
			      C 	; 04/12/2013
			      C 	; 30/10/2013
			      C 	; 24/10/2013
			      C 	; 03/09/2013
			      C 	; 19/08/2013
			      C 	; 15/08/2013 (set console tty)
			      C 	; 11/08/2013
			      C 	; 16/07/2013
			      C 	; 15/07/2013
			      C 	; 02/06/2013
			      C 	;
			      C 	; 'sysstty' sets the status and mode of the typewriter 
			      C 	; whose file descriptor is in (u.r0).
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysstty; arg
			      C 	; Arguments:
			      C 	;	arg - address of 3 consecutive words that contain
			      C 	;	      the source of status data	
			      C 	; Inputs: ((*u.r0 - file descriptor & argument))
			      C 	; Outputs: ((status in address which is pointed to by arg))
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	'sysstty' system call will set the tty
			      C 	;	(clear keyboard buffer and set cursor position)
			      C 	;	 in following manner:
			      C 	;   NOTE: All of tty setting functions are here (16/01/2014)
			      C 	;
			      C 	; Inputs:
			      C 	;	BX = 0 --> means
			      C 	;	   If CH = 0 
			      C 	;	      set console tty for (current) process
			      C 	;	      CL = tty number (0 to 9)
			      C 	;	      (If ch = 0, character will not be written)			
			      C 	;          If CH > 0	
			      C 	;	      set cursor position or comm. parameters only
			      C 	;             If CL = FFh
			      C 	;	        set cursor position for console tty
			      C 	;             or CL = tty number (0 to 9)
			      C 	;	      CH = character will be written
			      C 	;	        at requested cursor position (in DX)	
			      C 	;             (For tty numbers 0 to 7, if CH = FFh, character
			      C 	;	      will not be written)
			      C 	;	   DX = cursor position for tty number 0 to 7.	
			      C   	;		(only tty number 0 to 7) 
			      C 	;          DL = communication parameters (for serial ports) 
			      C 	;	        (only for COM1 and COM2 serial ports)
			      C 	;	   DH < 0FFh -> DL is valid, initialize serial port
			      C 	;			or set cursor position	
			      C 	;	   DH = 0FFh -> DL is not valid
			      C 	;		do not set serial port parameters 
			      C 	;		or do not set cursor position
			      C 	;
			      C 	;	BX > 0 --> points to name of tty
			      C 	;    	   CH > 0 -->
			      C 	;		CL = character will be written in current 
			      C 	;            	cursor position (for tty number from 0 to 7)
			      C 	;	     	or character will be sent to serial port
			      C 	;	     	(for tty number 8 or 9)
			      C 	;		CH = color of the character if tty number < 8.
			      C 	;    	   CH = 0 --> Do not write a character, 
			      C 	;		set mode (tty 8 to 9) or 
			      C 	;		set current cursor positions (tty 0 to 7) only. 
			      C 	;   	   DX = cursor position for tty number 0 to 7.
			      C 	;    	   DH = FFh --> Do not set cursor pos (or comm. params.)
			      C 	;		(DL is not valid)
			      C 	;	   DL = communication parameters 
			      C 	;		for tty number 8 or 9 (COM1 or COM2).
			      C 	;
			      C 	;	30/01/2022
			      C 	;	If CH = 0 & DX = 0FFFFh -> 
			      C 	;	   clear screen (video page) & set cursor pos to 0,0.
			      C 	;	   (for tty number 0 to 7, CL <= 7)
			      C 	;	   (if CL = 0FFh -> clear console tty)		
			      C 	; Outputs:
			      C 	;	cf = 0 -> OK
			      C 	;	     AL = tty number (0 to 9)
			      C 	;	     AH = line status if tty number is 8 or 9
			      C 	;	     AH = process number (of the caller) 	
			      C 	;	cf = 1 means error (requested tty is not ready)
			      C 	;	     AH = FFh if the tty is locked 
			      C 	;		  (owned by another process)
			      C 	;	        = process number (of the caller) 
			      C 	;		  (if < FFh and tty number < 8)
			      C 	;	     AL = tty number (0FFh if it does not exist)
			      C 	;	     AH = line status if tty number is 8 or 9
			      C 	;	NOTE: Video page will be cleared if cf = 0.
			      C 	;
			      C 	; 30/01/2022
 071E  B8 FFFF		      C 	mov	ax, 0FFFFh
			      C 	; 14/01/2014
			      C 	;mov	word ptr [u.r0], 0FFFFh
			      C 	; 30/01/2022
 0721  A3 27A8 R	      C 	mov	word ptr [u.r0], ax ; 0FFFFh ; set error return
 0724  FE C1		      C 	inc	cl  ; 0FFh -> 0, 7 -> 8
 0726  3B D0		      C 	cmp	dx, ax ; 0FFFFh
 0728  75 1E		      C 	jne	short @f
			      C 	; clear video page
			      C 	; (CH must be 0)
 072A  0A ED		      C 	or	ch, ch
 072C  75 ED		      C 	jnz	short sysstty_err ; invalid parameters
 072E  80 F9 08		      C 	cmp	cl, 8 ; > tty7 (serial port?)
 0731  77 E8		      C 	ja	short sysstty_err ; invalid parameters
 0733  22 C9		      C 	and	cl, cl
 0735  75 11		      C 	jnz	short @f ; actual tty (video page) number + 1
 0737  8A 0E 27DF R	      C 	mov	cl, byte ptr [u.uno] ; process number
 073B  8B F1		      C 	mov	si, cx
 073D  8A 8C 2669 R	      C 	mov	cl, byte ptr [SI]+p.ttyc-1 ; current/console tty
 0741  80 F9 07		      C 	cmp	cl, 7
 0744  77 4A		      C 	ja	short sysstty_err_s ; serial port !	 
			      C 	; here CL contains (actual) tty number (tty0 to tty7) 
 0746  FE C1		      C 	inc	cl  ; 0 -> 1, 7 -> 8 
 0748			      C @@:
 0748  FE C9		      C 	dec	cl  ; 8 -> 7, 1 -> 0
			      C 	; cl = video page (tty) number
 074A  23 DB		      C 	and	bx, bx
			      C         ;jnz	sysstty_6
 074C  74 03		      C 	jz	short @f
 074E  E9 009A		      C 	jmp	sysstty_6
 0751			      C @@:
			      C 	; set console tty
			      C 	; 17/01/2014
 0751  80 F9 09		      C 	cmp	cl, 9
 0754  76 11		      C 	jna	short sysstty_0
 0756  0A ED		      C 	or	ch, ch
			      C 	;jz	error
			      C 	; 27/01/2022
 0758  74 C1		      C 	jz	short sysstty_err
 075A  80 F9 FF		      C 	cmp	cl, 0FFh
			      C 	;jb	error
			      C 	; 27/01/2022
 075D  72 BC		      C 	jb	short sysstty_err
 075F  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 0763  8A 8F 2669 R	      C 	mov	cl, byte ptr [BX]+p.ttyc-1 ; current/console tty
 0767			      C sysstty_0:
 0767  80 F9 08		      C 	cmp	cl, 8
 076A  72 10		      C 	jb	short sysstty_2
			      C 	;
 076C  80 FE FF		      C 	cmp	dh, 0FFh
 076F  74 0B		      C 	je	short sysstty_2
			      C 		; set communication parameters for serial ports
 0771  BE 279A R	      C 	mov	si, offset com1p
			      C 	; 12/07/2014
 0774  80 F9 09		      C 	cmp	cl, 9
 0777  72 01		      C 	jb	short sysstty_1
 0779  46		      C 	inc	si
 077A			      C sysstty_1:	
 077A  88 14		      C 	mov	byte ptr [SI], dl ; comm. parameters
 077C			      C sysstty_2:
 077C  52		      C 	push	dx
 077D  51		      C 	push	cx
 077E  32 D2		      C 	xor 	dl, dl	; sysstty call sign
 0780  8A C1		      C 	mov	al, cl
 0782  A2 27A8 R	      C 	mov	byte ptr [u.r0], al
			      C 	; 30/01/2022
 0785  98		      C 	cbw
			      C 	; ah = 0
 0786  E8 0F3D		      C 	call	ottyp
 0789  59		      C 	pop	cx
 078A  5A		      C 	pop	dx
			      C 	;
			      C 	;jc	error
			      C 	; 27/01/2022
 078B  73 09		      C 	jnc	short @f
 078D			      C sysstty_error:
 078D  E9 FB63		      C 	jmp	error
 0790			      C sysstty_err_s:
			      C 	; 30/01/2022
 0790  88 0E 27A8 R	      C 	mov	byte ptr [u.r0], cl ; serial port's tty number
 0794  EB F7		      C 	jmp	short sysstty_error
 0796			      C @@:
			      C 	; 30/01/2022
 0796  8A C5		      C 	mov	al, ch
			      C 	; 02/02/2022
 0798  C6 06 288C R 07	      C 	mov	byte ptr [color], 07h ; default color
 079D			      C sysstty_18:	; 01/02/2022
 079D  32 FF		      C 	xor	bh, bh
			      C 	; 17/01/2014
 079F  22 ED		      C 	and	ch, ch 	; set cursor position 
			      C 			; or comm. parameters ONLY
 07A1  75 10		      C 	jnz	short sysstty_3
			      C 	; 30/01/2022
 07A3  83 FA FF		      C 	cmp	dx, 0FFFFh
 07A6  72 03		      C 	jb	short @f
			      C 	; clear screen (video page)
 07A8  E9 00C5		      C 	jmp	sysstty_14
 07AB			      C @@:
 07AB  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 07AF  88 8F 2669 R	      C 	mov	byte ptr [BX]+p.ttyc-1, cl ; current/console tty
 07B3			      C sysstty_3:
			      C 	; 16/01/2014
			      C 	;mov	al, ch ; character  ; 0 to FFh
 07B3  80 F9 07		      C 	cmp	cl, 7
			      C 	;jna	short sysstty_9
			      C 	; 30/01/2022
 07B6  77 03		      C 	ja	short sysstty_12
			      C 	; 02/02/2022
			      C 	;mov	byte ptr [color], 07h ; default color
 07B8  E9 008B		      C 	jmp	sysstty_9
 07BB			      C sysstty_12:
			      C 	;; BX = 0, CL = 8 or CL = 9
			      C 	; (Set specified serial port as console tty port)
			      C 	; CH = character to be written
			      C 	; 15/04/2014
			      C 	; CH = 0 --> initialization only
			      C 	; AL = character
			      C 	; 26/06/2014
 07BB  88 0E 27E2 R	      C 	mov	byte ptr [u.ttyn], cl
			      C 	; 12/07/2014
 07BF  8A E1		      C 	mov	ah, cl ; tty number (8 or 9)
 07C1  22 C0		      C 	and	al, al
 07C3  74 05		      C 	jz	short sysstty_4 ; al = ch = 0
			      C  	; 04/07/2014
 07C5  E8 1356		      C 	call 	sndc
			      C 	; 12/07/2014
 07C8  EB 0A		      C 	jmp	short sysstty_5
 07CA			      C sysstty_4:
			      C 	; 12/07/2014
 07CA  86 E0		      C 	xchg 	ah, al ; al = 0 -> al = ah, ah = 0
 07CC  2C 08		      C 	sub	al, 8
 07CE  8B D0		      C 	mov	dx, ax ; 0 or 1
 07D0  B4 03		      C 	mov	ah, 3  ; Get serial port status
 07D2  CD 14		      C 	int	14h
 07D4			      C sysstty_5:
 07D4  88 26 27A9 R	      C 	mov	byte ptr [u.r0]+1, ah ; line status
 07D8  9C		      C 	pushf
 07D9  32 D2		      C 	xor	dl, dl ; sysstty call sign
 07DB  A0 27E2 R	      C 	mov	al, byte ptr [u.ttyn] ; 26/06/2014
 07DE  98		      C 	cbw	; ax = tty number (ah=0)
 07DF  E8 1002		      C 	call	cttyp
 07E2  9D		      C 	popf
			      C 	;jc	error
			      C 	; 27/01/2022
 07E3  72 03		      C 	jc	short @f
 07E5  E9 FB28		      C 	jmp	sysret
 07E8			      C @@:
 07E8  E9 FB08		      C 	jmp	error
			      C 
 07EB			      C sysstty_6:
 07EB  52		      C 	push	dx
 07EC  51		      C 	push	cx
 07ED  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 07F1  E8 0439		      C 	call	namei
 07F4  59		      C 	pop	cx
 07F5  5A		      C 	pop	dx
			      C 	;jc	error
			      C 	; 27/01/2022
 07F6  72 F0		      C 	jc	short @b ; jmp error
 07F8  83 F8 13		      C 	cmp	ax, 19 ; inode number of /dev/COM2
			      C 	;ja	error
			      C 	; 27/01/2022
 07FB  77 EB		      C 	ja	short @b ; jmp error
 07FD  3C 0A		      C 	cmp	al, 10 ; /dev/tty0 .. /dev/tty7
			      C 		       ; /dev/COM1, /dev/COM2
 07FF  72 04		      C 	jb	short sysstty_7
 0801  2C 0A		      C 	sub	al, 10
 0803  EB 0E		      C 	jmp	short sysstty_8
			      C 
 0805			      C sysstty_7:
 0805  3C 01		      C 	cmp	al, 1 ; /dev/tty
			      C 	;jne	error ; 30/01/2022
			      C 	; 27/01/2022
 0807  75 DF		      C 	jne	short @b ; jmp error
 0809  32 FF		      C 	xor	bh, bh
 080B  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 080F  8A 87 2669 R	      C 	mov	al, byte ptr [BX]+p.ttyc-1 ; current/console tty
 0813			      C sysstty_8:
 0813  A2 27A8 R	      C 	mov	byte ptr [u.r0], al
 0816  52		      C 	push	dx
 0817  50		      C 	push	ax
 0818  51		      C 	push	cx	
 0819  E8 0EAA		      C 	call	ottyp
 081C  59		      C 	pop	cx
 081D  58		      C 	pop	ax
 081E  5A		      C 	pop	dx
			      C 	;jc	error
			      C 	; 27/01/2022
 081F  72 C7		      C 	jc	short @b ; jmp error
			      C 	; 12/07/2014
 0821  86 C1		      C 	xchg	al, cl
 0823  80 F9 07		      C 	cmp	cl, 7
			      C 	;;ja	sysstty_12
			      C 	;; 27/01/2022
			      C 	;;jna	short @f
			      C 	;;jmp	sysstty_12
			      C 	;ja	short sysstty_12
			      C 	; 30/01/2022
 0826  76 17		      C 	jna	short sysstty_16
			      C ;@@:
 0828  80 FE FF		      C 	cmp	dh, 0FFh
 082B  74 0B		      C 	je	short @f ; do not set communication parameters
			      C 	; set communication parameters for serial port(s)
 082D  BE 279A R	      C 	mov	si, offset com1p
 0830  80 F9 09		      C 	cmp	cl, 9
 0833  72 01		      C 	jb	short sysstty_17
 0835  46		      C 	inc	si
 0836			      C sysstty_17:	
 0836  88 14		      C 	mov	byte ptr [SI], dl ; comm. parameters
 0838			      C @@:
			      C 	; 30/01/2022
 0838  0A ED		      C 	or	ch, ch
 083A  74 29		      C 	jz	short sysstty_11 ; don't send char to terminal
			      C 	; send char to (serial port) terminal
			      C 	; al = character
			      C 	; cl = tty number (8 or 9)
 083C  E9 FF7C		      C 	jmp	sysstty_12 ; (tty8 or tty9)
 083F			      C sysstty_16:
			      C 	; (tty0 to tty7)
			      C 	; 16/01/2014
			      C 	;xor	bh, bh
			      C 	; 30/01/2022
 083F  88 2E 288C R	      C 	mov	byte ptr [color], ch ; color (&r attribute)
			      C 	; 01/02/2022
			      C 	; al = character
			      C 	; cl = tty number
 0843  E9 FF57		      C 	jmp	sysstty_18 ; 02/02/2022
 0846			      C sysstty_9: 	; tty 0 to tty 7
			      C 	; al = character
 0846  80 FE FF		      C 	cmp	dh, 0FFh ; Do not set cursor position
 0849  74 09		      C 	je	short sysstty_10
 084B  51		      C 	push	cx
 084C  50		      C 	push	ax	
 084D  8A D9		      C 	mov	bl, cl ; (tty number = video page number)
			      C 	;xor	bh, bh
 084F  E8 1378		      C 	call	set_cpos
 0852  58		      C 	pop	ax
 0853  59		      C 	pop	cx
 0854			      C sysstty_10: 
			      C 	; 17/01/2014
 0854  FE C5		      C 	inc	ch
 0856  74 0D		      C 	jz      short sysstty_11 ; ch = FFh
 0858  FE CD		      C 	dec	ch
 085A  74 09		      C 	jz	short sysstty_11 ; ch = 0
			      C 		; ch > 0 and ch < FFh
			      C 	; write a character at current cursor position
			      C 	;mov	ah, 07h ; ah = 7 (color/attribute), al = char
			      C 	; 30/01/2022
 085C  8A 26 288C R	      C 	mov	ah, byte ptr [color]
			      C 	; 12/07/2014
 0860  51		      C 	push	cx
 0861  E8 1495		      C 	call	write_c_current
 0864  59		      C 	pop	cx
 0865			      C sysstty_11:
			      C 	; 30/01/2022
			      C 	; (close /dev/tty? file)
			      C 	; 18/01/2014
 0865  8A C1		      C 	mov	al, cl
 0867			      C sysstty_13:	; 30/01/2022
 0867  98		      C 	cbw
			      C 	; 14/01/2014
 0868  32 D2		      C 	xor	dl, dl ; sysstty call sign
 086A  E8 0F77		      C 	call	cttyp
 086D  E9 FAA0		      C 	jmp	sysret
			      C 
 0870			      C sysstty_14:
			      C 	; 30/01/2022
			      C 	; ch = 0
			      C 	; cl = video page
			      C 	;
			      C 	;cmp	dx, 0FFFFh
			      C 	;jne	short sysstty_11
			      C 	
			      C 	; dx = 0FFFFh
			      C 	; clear screen (video page)
			      C 	
			      C 	; 30/01/2022
			      C 	; clear screen
			      C 	;
			      C 	; (modified registers: ax, bx, cx, dx, si, di)
 0870			      C wttyc:
			      C 	;xor	dx, dx ; column 0, row 0
 0870  42		      C 	inc	dx ; 0
			      C 	;
 0871  8A D9		      C 	mov 	bl, cl ; CL = tty number (0 to 7)
			      C 
			      C ;	shl 	bl, 1 
			      C ;	xor	bh, bh
			      C ;	mov 	al, byte ptr [BX+ttyl]
			      C ;		; AL = lock value (0 or process number)
			      C ;	or	al, al
			      C ;	jz	short @f
			      C ;	cmp	al, byte ptr [u.uno] ; process number
			      C ;	jne	short sysstty_15
			      C ;		; only the owner can clear its video page
			      C ;	xor	al, al ; 0
			      C ;@@:
			      C ;	;mov	bl, cl		
			      C ;	shr	bl, 1 
			      C 
 0873  32 C0		      C 	xor	al, al	; 0
 0875  B7 07		      C 	mov 	bh, 07h	; attribute/color (default)
			      C 
			      C 	; scroll_up input:
			      C 	;
			      C 	; al = line count (0 or 1) ((0 == clear video page))
			      C 	; 	((al = 1 for write_tty (putc) procedure))
			      C 	; bl = video page number (0 to 7)
			      C 	; bh = attribute to be used on blanked line
			      C 
 0877  E8 1420		      C 	call	scroll_up ; clear video page (al=0)
			      C 
			      C 	; (modified registers: ax, cx, dx, si, di)
			      C 
			      C 	; bl = video page number (0 to 7)
 087A  33 D2		      C 	xor	dx, dx ; column 0, row 0
 087C  E8 134B		      C 	call	set_cpos
			      C 	;
 087F  8A C3		      C 	mov	al, bl
 0881  8A 26 27DF R	      C 	mov	ah, [u.uno]
 0885  A3 27A8 R	      C 	mov	[u.r0], ax
 0888  EB DD		      C 	jmp	short sysstty_13
			      C 
			      C ;sysstty_15:
			      C ;	; 30/01/2022
			      C ;	; permission (denied) error
			      C ;	;xor	dl, dl ; sysstty call sign
			      C ;	mov	al, cl
			      C ;	sub	ah, ah ; 0
			      C ;	call	cttyp
			      C ;	jmp	error
			      C 	
			      C 	; Original UNIX v1 'sysstty' routine:
			      C ; gtty:
			      C ;   / set mode of typewriter; 3 consequtive word arguments
			      C         ;jsr    r0,gtty / r1 will have offset to tty block, 
			      C 	; 		/ r2 has source
			      C         ;mov    r2,-(sp)
			      C         ;mov    r1,-(sp) / put r1 and r2 on the stack
			      C ;1: / flush the clist wait till typewriter is quiescent
			      C         ;mov    (sp),r1 / restore r1 to tty block offset
			      C         ;movb   tty+3(r1),0f / put cc offset into getc argument
			      C         ;mov    $240,*$ps / set processor priority to 5
			      C         ;jsr    r0,getc; 0:../ put character from clist in r1
			      C         ;       br .+4 / list empty, skip branch
			      C         ;br     1b / get another character until list is empty
			      C         ;mov    0b,r1 / move cc offset to r1
			      C         ;inc    r1 / bump it for output clist
			      C         ;tstb   cc(r1) / is it 0
			      C         ;beq    1f / yes, no characters to output
			      C  	;mov    r1,0f / no, put offset in sleep arg
			      C         ;jsr    r0,sleep; 0:.. / put tty output process to sleep
			      C         ;br     1b / try to calm it down again
			      C ;1:
			      C         ;mov    (sp)+,r1
			      C         ;mov    (sp)+,r2 / restore registers
			      C 	;mov    (r2)+,r3 / put reader control status in r3
			      C         ;beq    1f / if 0, 1f
			      C         ;mov    r3,rcsr(r1) / move r.c. status to reader
			      C         ;                   / control status register
			      C ;1:
			      C         ;mov    (r2)+,r3 / move pointer control status to r3
			      C         ;beq    1f / if 0 1f
			      C         ;mov    r3,tcsr(r1) / move p.c. status to printer 
			      C 	;		    / control status reg
			      C ;1:
			      C         ;mov    (r2)+,tty+4(r1) / move to flag byte of tty block
			      C         ;jmp    sysret2 / return to user
			      C 
 088A			      C sysgtty: ; < get tty status >
			      C 	; 28/06/2015
			      C 	; 12/07/2014
			      C 	; 22/04/2014
			      C         ; 26/01/2014
			      C 	; 17/01/2014
			      C 	; 16/01/2014
			      C 	; 07/12/2013
			      C 	; 04/12/2013
			      C 	; 03/09/2013
			      C 	; 15/08/2013
			      C 	; 16/07/2013
			      C 	; 02/06/2013
			      C 	; 30/05/2013
			      C 	; 'sysgtty' gets the status of tty in question. 
			      C 	; It stores in the three words addressed by it's argument
			      C 	; the status of the typewriter whose file descriptor
			      C 	; in (u.r0).
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysgtty; arg
			      C 	; Arguments:
			      C 	;	arg - address of 3 words destination of the status
			      C 	; Inputs: ((*u.r0 - file descriptor))
			      C 	; Outputs: ((status in address which is pointed to by arg))
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	'sysgtty' system call will return status of tty
			      C 	;	(keyboard, serial port and video page status)
			      C 	;	 in following manner:
			      C 	;
			      C 	; Inputs:
			      C 	;	BX = 0 --> means 
			      C 	;	     CH = 0 -->	'return status of the console tty' 
			      C 	;	                 for (current) process
			      C 	;	     CL = 0 --> return keyboard status (tty 0 to 7)
			      C 	;	     CL = 1 --> return video page status (tty 0 to 7)	
			      C 	;	     CH > 0 -->	tty number + 1
			      C 	;
			      C 	;	BX > 0 --> points to name of tty
			      C 	;	     CL = 0 --> return keyboard status
			      C 	;	     CL = 1 --> return video page status
			      C 	;	     CH = undefined		 
			      C 	;
			      C 	; Outputs:
			      C 	;	cf = 0 ->
			      C 	;
			      C 	;	     AL = tty number from 0 to 9
			      C 	;		  (0 to 7 is also the video page of the tty)	
			      C 	;	     AH = 0 if the tty is free/unused
			      C 	;	     AH = the process number of the caller 
			      C  	;	     AH = FFh if the tty is locked by another process
			      C 	;
			      C 	;	  (if calling is for serial port status)
			      C 	;	     BX = serial port status if tty number is 8 or 9
			      C 	;		  (BH = modem status, BL = Line status)
			      C 	;	     CX = 0FFFFh (if data is ready)
			      C 	;	     CX = 0 (if data is not ready or undefined)		
			      C 	;
			      C 	;	  (if calling is for keyboard status)
			      C 	;	     BX = current character in tty/keyboard buffer
			      C 	;		  (BH = scan code, BL = ascii code)
			      C 	;		  (BX=0 if there is not a waiting character)
			      C 	;	     CX  is undefined
			      C 	;
			      C 	;	  (if calling is for video page status)	
			      C 	;	     BX = cursor position on the video page
			      C 	;		  if tty number < 8
			      C 	;		  (BH = row, BL = column)
			      C 	;	     CX = current character (in cursor position)
			      C 	;		  on the video page of the tty 
			      C 	;		  if tty number < 8
			      C 	;		  (CH = color, CL = character)
			      C 	;	
			      C 	;	cf = 1 means error (requested tty is not ready)
			      C 	;
			      C 	;	     AH = FFh if the caller is not owner of
			      C 	;		  specified tty or console tty
			      C 	;	     AL = tty number (0FFh if it does not exist)
			      C 	;	     BX, CX are undefined if cf = 1
			      C 	;
			      C 	;	  (If tty number is 8 or 9)
			      C 	;	     AL = tty number 
			      C 	;	     AH = the process number of the caller 
			      C 	;	     BX = serial port status
			      C 	;  		 (BH = modem status, BL = Line status)
			      C 	;	     CX = 0
			      C 	;
			      C 		
 088A			      C sysgtty_0:
 088A			      C gtty:   ; get (requested) tty number
			      C 	; 27/01/2022
			      C 	; 28/06/2015
			      C 	; 12/07/2014
			      C 	; 22/04/2014 
			      C 	; 15/04/2014
			      C         ; 26/01/2014
			      C 	; 17/01/2014
			      C 	; 16/01/2014
			      C 	; 07/12/2013
			      C 	; 04/12/2013
			      C 	; 03/09/2013
			      C 	; 19/08/2013
			      C 	; 16/07/2013
			      C 	; 02/06/2013
			      C 	; 30/05/2013 
			      C 	; Retro UNIX 8086 v1 modification ! 
			      C 	;
			      C 	; ((Modified registers: AX, BX, CX, DX, SI, DI, BP))
			      C 	;
			      C 	; 16/01/2014
 088A  C7 06 27A8 R FFFF      C 	mov 	word ptr [u.r0], 0FFFFh
 0890  80 F9 01		      C 	cmp	cl, 1
 0893  76 03 E9 FA5B	      C 	ja	error
			      C 	;	
 0898  23 DB		      C 	and	bx, bx
 089A  74 22		      C 	jz	short sysgtty_1
			      C 	;
 089C  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 08A0  E8 038A		      C 	call	namei
			      C 	;jc 	error
			      C 	; 27/01/2022
 08A3  73 03		      C 	jnc	short @f
 08A5  E9 FA4B		      C 	jmp	error
 08A8			      C @@:
 08A8  32 FF		      C 	xor	bh, bh
 08AA  83 F8 01		      C 	cmp	ax, 1
 08AD  76 1B		      C 	jna	short sysgtty_2
 08AF  83 E8 0A		      C 	sub	ax, 10
 08B2  83 F8 09		      C 	cmp	ax, 9
 08B5  76 03 E9 FA39	      C 	ja	error
 08BA  8A E8		      C 	mov	ch, al
 08BC  EB 18		      C 	jmp	short sysgtty_4
 08BE			      C sysgtty_1:
			      C 	; 16/01/2014
 08BE  80 FD 0A		      C 	cmp	ch, 10
			      C 	;ja	error
			      C 	; 27/01/2022
 08C1  76 03		      C 	jna	short @f
 08C3  E9 FA2D		      C 	jmp	error
 08C6			      C @@:
 08C6  FE CD		      C 	dec	ch ; 0 -> FFh (negative)
 08C8  79 0A		      C 	jns	short sysgtty_3 ; not negative
			      C 	;
 08CA			      C sysgtty_2:
			      C 	; get tty number of console tty
 08CA  8A 26 27DF R	      C 	mov	ah, byte ptr [u.uno]
 08CE  8A DC		      C 	mov 	bl, ah
			      C 	;xor	bh, bh
 08D0  8A AF 2669 R	      C 	mov	ch, byte ptr [BX]+p.ttyc-1
 08D4			      C sysgtty_3:
 08D4  8A C5		      C 	mov	al, ch
 08D6			      C sysgtty_4:
 08D6  A2 27A8 R	      C 	mov	byte ptr [u.r0], al
			      C 	;cmp	ch, 9
			      C 	;ja	error
 08D9  8B 2E 27A4 R	      C 	mov	bp, word ptr [u.sp_] ; 28/06/2015
 08DD  80 FD 08		      C 	cmp	ch, 8 ; cmp al, 8
 08E0  72 2E		      C 	jb	short sysgtty_6
			      C 	;
			      C 	; 12/07/2014
 08E2  BA 0000		      C 	mov	dx, 0
 08E5  74 02		      C 	je	short sysgtty_5
 08E7  FE C2		      C 	inc	dl
 08E9			      C sysgtty_5:
			      C 	; 12/07/2014
 08E9  B4 03		      C 	mov	ah, 3 ; get serial port status
 08EB  CD 14		      C 	int	14h
 08ED  86 E0		      C 	xchg	ah, al
 08EF  89 46 06		      C 	mov	word ptr [BP]+6, ax ; serial port status
 08F2  8A 26 27DF R	      C 	mov	ah, byte ptr [u.uno]
 08F6  88 26 27A9 R	      C 	mov	byte ptr [u.r0]+1, ah
 08FA  C7 46 08 0000	      C 	mov	word ptr [BP]+8, 0 ; data status (0 = not ready)	
 08FF  A8 80		      C 	test	al, 80h
			      C 	;jnz	error
			      C 	; 27/01/2022
 0901  74 03		      C 	jz	short @f
 0903  E9 F9ED		      C 	jmp	error
 0906			      C @@:
 0906  A8 01		      C 	test	al, 1
			      C 	;jz	sysret
			      C 	; 27/01/2022
 0908  74 03		      C 	jz	short  @f
 090A  FF 4E 08		      C 	dec	word ptr [BP]+8 ; data status (FFFFh = ready)
 090D			      C @@:	
 090D  E9 FA00		      C 	jmp	sysret
 0910			      C sysgtty_6:
 0910  A2 27E2 R	      C 	mov	byte ptr [u.ttyn], al ; tty number
			      C 	;xor	bh, bh
 0913  8A D8		      C 	mov 	bl, al ; tty number (0 to 7)
 0915  D0 E3		      C 	shl 	bl, 1  ; aligned to word
			      C 	; 22/04/2014
 0917  81 C3 277A R	      C         add     bx, offset ttyl
 091B  8A 27		      C  	mov	ah, byte ptr [BX]
 091D  3A 26 27DF R	      C 	cmp	ah, byte ptr [u.uno]
 0921  74 04		      C 	je	short sysgtty_7
 0923  22 E4		      C 	and	ah, ah
			      C 	;jz	short sysgtty_7
 0925  75 04		      C 	jnz	short sysgtty_8
			      C 	;mov	ah, 0FFh
 0927			      C sysgtty_7:
 0927  88 26 27A9 R	      C 	mov	byte ptr [u.r0]+1, ah
 092B			      C sysgtty_8:
 092B  0A C9		      C 	or	cl, cl
 092D  75 0B		      C 	jnz	short sysgtty_9
 092F  B0 01		      C 	mov	al, 1  ; test a key is available
 0931  E8 1190		      C 	call	getc
 0934  89 46 06		      C 	mov	word ptr [BP]+6, ax ; bx, character
 0937  E9 F9D6		      C 	jmp	sysret
 093A			      C sysgtty_9:
 093A  8A 1E 27E2 R	      C 	mov	bl, byte ptr [u.ttyn]
			      C 	; bl = video page number
 093E  E8 140A		      C 	call 	get_cpos
			      C 	; dx = cursor position
 0941  89 56 06		      C 	mov	word ptr [BP]+6, dx ; bx
			      C 	;mov	bl, byte ptr [u.ttyn]
			      C 	; bl = video page number
 0944  E8 140F		      C 	call	read_ac_current
			      C 	; ax = character and attribute/color
 0947  89 46 08		      C 	mov	word ptr [BP]+8, ax ; cx
 094A  E9 F9C3		      C 	jmp	sysret
			      C 
			      C ; Original UNIX v1 'sysgtty' routine:
			      C ; sysgtty:
			      C         ;jsr    r0,gtty / r1 will have offset to tty block,
			      C 	;	       / r2 has destination
			      C         ;mov    rcsr(r1),(r2)+ / put reader control status 
			      C 	;                     / in 1st word of dest
			      C         ;mov    tcsr(r1),(r2)+ / put printer control status
			      C 	;                     / in 2nd word of dest
			      C         ;mov    tty+4(r1),(r2)+ / put mode in 3rd word
			      C         ;jmp    sysret2 / return to user
			      C 	
			      C ; Original UNIX v1 'gtty' routine:
			      C ; gtty:
			      C         ;jsr    r0,arg; u.off / put first arg in u.off
			      C         ;mov    *u.r0,r1 / put file descriptor in r1
			      C         ;jsr    r0,getf / get the i-number of the file
			      C         ;tst    r1 / is it open for reading
			      C         ;bgt    1f / yes
			      C         ;neg    r1 / no, i-number is negative, 
			      C 	;          / so make it positive
			      C ;1:
			      C         ;sub    $14.,r1 / get i-number of tty0
			      C         ;cmp    r1,$ntty-1 / is there such a typewriter
			      C         ;bhis   error9 / no, error
			      C         ;asl    r1 / 0%2
			      C         ;asl    r1 / 0%4 / yes
			      C         ;asl    r1 / 0%8 / multiply by 8 so r1 points to 
			      C 	;	       ; / tty block
			      C         ;mov    u.off,r2 / put argument in r2
			      C         ;rts    r0 / return
			      C 
				include u2.asm ; u2.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U2.ASM (include u2.asm) //// UNIX v1 -> u2.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 11/05/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 10/05/2022 namei
			      C ; 09/05/2022 sysstat, sysfstat
			      C ; 29/04/2022 syschmod (bugfix)
			      C ; 30/01/2022 compact kernel (moving buffers to bss section)
			      C ; 27/01/2022 (optimized code)
			      C ; 24/03/2014 sysbreak
			      C ; 12/01/2014 fclose
			      C ; 06/12/2013 sysexec
			      C ; 19/11/2013 sysbreak
			      C ; 18/11/2013 getf (getf1)
			      C ; 24/10/2013 sysexec
			      C ; 03/09/2013 sysexec (u.intr, u.quit reset -> enabled)
			      C ; 05/08/2013 fclose, seektell
			      C ; 02/08/2013 maknod, (u.uid -> u.uid_)
			      C ; 01/08/2013 mkdir
			      C ; 31/07/2013 u.namei_r -> namei_r, maknod
			      C ; 30/07/2013 fclose
			      C ; 28/07/2013 namei (u.namei_r)
			      C ; 26/07/2013 namei (namei_r)
			      C ; 25/07/2013 sysexec (arguments)
			      C ; 24/07/2013 sysexec
			      C ; 22/07/2013 sysexec, namei
			      C ; 18/07/2013 sysexec, namei
			      C ; 17/07/2013 maknod (inode->i)
			      C ; 09/07/2013 namei (rootdir)
			      C ; 07/07/2013 sysseek, systell, sysintr, sysquit, syssetuid, sysgetuid	
			      C ; 07/07/2013 syschmod, syschown
			      C ; 20/06/2013 syschmod, syschown, systime, sysstime, sysbreak
			      C ; 19/06/2013 syslink, sysunlink, sysstat, sysfstat, syschdir
			      C ; 04/06/2013 sysexec
			      C ; 03/06/2013 sysexec	
			      C ; 27/05/2013 namei (stc)
			      C ; 23/05/2013 getf1 
			      C ; 02/05/2013 maknod
			      C ; 29/04/2013 mkdir	
			      C ; 25/04/2013 anyi
			      C ; 24/04/2013 namei
			      C ; 19/04/2013 fclose
			      C ; 11/03/2013
			      C 
 094D			      C syslink:
			      C 	; 27/01/2022
			      C 	; 19/06/2013
			      C 	; 'syslink' is given two arguments, name 1 and name 2.
			      C 	; name 1 is a file that already exists. name 2 is the name
			      C 	; given to the entry that will go in the current directory.
			      C 	; name2 will then be a link to the name 1 file. The i-number
			      C 	; in the name 2 entry of current directory is the same
			      C 	; i-number for the name 1 file.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syslink; name 1; name 2
			      C 	; Arguments:
			      C 	;	name 1 - file name to which link will be created.
			      C 	;	name 2 - name of entry in current directory that
			      C 	;		 links to name 1.
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'syslink' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get syslink system call arguments from the user;
			      C 	;	* 1st argument, name 1 is pointed to by BX register
			      C 	;	* 2nd argument, name 2 is pointed to by CX register
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.)		 	
			      C 	
			      C ; / name1, name2
			      C 	;call	arg2
			      C 	;	jsr r0,arg2 / u.namep has 1st arg u.off has 2nd
 094D  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 0951  51		      C 	push	cx
 0952  E8 02D8		      C 	call	namei
			      C 		; jsr r0,namei / find the i-number associated with
			      C 			     ; / the 1st path name
			      C      	;;and	ax, ax
			      C 	;;jz	error ; File not found
			      C 	;jc	error 
			      C 		; br error9 / cannot be found
			      C 	; 27/01/2022
 0955  72 31		      C 	jc	short @f
 0957  E8 082C		      C 	call	iget
			      C 		; jsr r0,iget / get the i-node into core
 095A  8F 06 27BA R	      C 	pop	word ptr [u.namep] ; cx
			      C 		; mov (sp)+,u.namep / u.namep points to 2nd name
 095E  50		      C 	push	ax
			      C 		; mov r1,-(sp) / put i-number of name1 on the stack
			      C 			    ; / (a link to this file is to be created)
 095F  FF 36 26C2 R	      C 	push	word ptr [cdev]
			      C 		; mov cdev,-(sp) / put i-nodes device on the stack
 0963  E8 0025		      C 	call	isdir
			      C 		; jsr r0,isdir / is it a directory
 0966  E8 02C4		      C 	call	namei
			      C 		; jsr r0,namei / no, get i-number of name2
			      C 	;jnc	error
			      C 		; br .+4   / not found 
			      C 			 ; / so r1 = i-number of current directory
			      C 			 ; / ii = i-number of current directory
			      C 		; br error9 / file already exists., error
			      C 	; 27/01/2022
 0969  73 1D		      C 	jnc	short @f
 096B  59		      C 	pop	cx
 096C  3B 0E 26C2 R	      C 	cmp	cx, word ptr [cdev]
			      C 		; cmp (sp)+,cdev / u.dirp now points to 
			      C 			       ; / end of current directory
			      C 	;jne	error
			      C 	        ; bne error9
			      C 	; 27/01/2022
 0970  75 16		      C 	jne	short @f
 0972  58		      C 	pop	ax
 0973  50		      C 	push	ax
 0974  A3 27C8 R	      C 	mov	word ptr [u.dirbuf], ax
			      C 		; mov (sp),u.dirbuf / i-number of name1 into u.dirbuf
 0977  E8 005B		      C 	call	mkdir
			      C 		; jsr r0,mkdir / make directory entry for name2 
			      C 		 	     ; / in current directory
 097A  58		      C 	pop	ax
			      C 		; mov (sp)+,r1 / r1 has i-number of name1
 097B  E8 0808		      C 	call	iget
			      C 		; jsr r0,iget / get i-node into core
 097E  FE 06 25EC R	      C 	inc	byte ptr [i.nlks]
			      C 		; incb i.nlks / add 1 to its number of links
 0982  E8 08C6		      C 	call	setimod
			      C 		; jsr r0,setimod / set the i-node modified flag
 0985  E9 F988		      C 	jmp	sysret
			      C 
			      C 	; 27/01/2022
 0988			      C @@:
 0988  E9 F968		      C 	jmp	error
			      C 
 098B			      C isdir:
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 04/05/2013
			      C 	; 'isdir' check to see if the i-node whose i-number is in r1
			      C 	;  is a directory. If it is, an error occurs, because 'isdir'
			      C 	;  called by syslink and sysunlink to make sure directories
			      C 	;  are not linked. If the user is the super user (u.uid=0),
			      C 	; 'isdir' does not bother checking. The current i-node
			      C 	;  is not disturbed.			
			      C 	;		
			      C 	; INPUTS ->
			      C 	;    r1 - contains the i-number whose i-node is being checked.
			      C 	;    u.uid - user id
			      C 	; OUTPUTS ->
			      C 	;    r1 - contains current i-number upon exit
			      C 	;    	 (current i-node back in core) 
			      C 	;	
			      C 	; ((AX = R1))
			      C 	;
			      C         ;    ((Modified registers: AX, DX, BX, CX, SI, DI, BP))  
			      C 	;
			      C 
			      C 	; / if the i-node whose i-number is in r1 is a directory 
			      C 	; / there is an error unless super user made the call
			      C 	
 098B  80 3E 27DC R 00	      C 	cmp	byte ptr [u.uid_], 0 
			      C 		; tstb u.uid / super user
 0990  76 12		      C 	jna	short @f
			      C 		; beq 1f / yes, don't care
 0992  FF 36 26BE R	      C 	push	word ptr [ii]
			      C 		; mov ii,-(sp) / put current i-number on stack
 0996  E8 07ED		      C 	call	iget
			      C 		; jsr r0,iget / get i-node into core (i-number in r1)
			      C 	; 27/01/2022
 0999  F6 06 25EB R 40	      C 	test	byte ptr [i.flgs+1], 40h
			      C 	;test 	word ptr [i.flgs], 4000h ; Bit 14 : Directory flag
			      C 		; bit $40000,i.flgs / is it a directory
			      C 	;jnz	error
			      C 		; bne error9 / yes, error
			      C 	; 27/01/2022
 099E  75 E8		      C 	jnz	short @b
 09A0  58		      C 	pop	ax
			      C 		; mov (sp)+,r1 / no, put current i-number in r1 (ii)
 09A1  E8 07E2		      C 	call	iget
			      C 		; jsr r0,iget / get it back in
 09A4			      C @@: ; 1:
 09A4  C3		      C 	retn
			      C 		; rts r0
			      C 
 09A5			      C sysunlink:
			      C 	; 27/01/2022
			      C 	; 19/06/2013
			      C 	; 'sysunlink' removes the entry for the file pointed to by
			      C 	; name from its directory. If this entry was the last link
			      C 	; to the file, the contents of the file are freed and the
			      C 	; file is destroyed. If, however, the file was open in any
			      C 	; process, the actual destruction is delayed until it is 
			      C 	; closed, even though the directory entry has disappeared.
			      C 	; 
			      C 	; The error bit (e-bit) is set to indicate that the file	
			      C 	; does not exist or that its directory can not be written.
			      C 	; Write permission is not required on the file itself.
			      C 	; It is also illegal to unlink a directory (except for
			      C 	; the superuser).
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysunlink; name
			      C 	; Arguments:
			      C 	;	name - name of directory entry to be removed 
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;	 The user/application program puts address of the name
			      C 	;        in BX register as 'sysunlink' system call argument.
			      C 	; 	 (argument transfer method 1)
			      C 
			      C ; / name - remove link name
			      C 	;;mov	ax, 1 ; one/single argument, put argument in BX
			      C 	;;call	arg
			      C 	;mov 	bp, word ptr [u.sp_] ; points to user's BP register
			      C 	;add 	bp, 6 ; bx now points to BX on stack
			      C 	;mov 	bx, word ptr [BP]
 09A5  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
			      C 		;jsr r0,arg; u.namep / u.namep points to name
 09A9  E8 0281		      C 	call	namei
			      C 		; jsr r0,namei / find the i-number associated 
			      C 			     ; / with the path name
			      C 	;jc	error
			      C 		; br error9 / not found
			      C 	; 27/01/2022
 09AC  73 03		      C 	jnc	short @f
 09AE  E9 F942		      C 	jmp	error
 09B1			      C @@:
 09B1  50		      C 	push	ax
			      C 		; mov r1,-(sp) / put its i-number on the stack
 09B2  E8 FFD6		      C 	call	isdir
			      C 		; jsr r0,isdir / is it a directory
 09B5  33 C0		      C 	xor 	ax, ax
 09B7  A3 27C8 R	      C 	mov	word ptr [u.dirbuf], ax ; 0
			      C 		; clr u.dirbuf / no, clear the location that will
			      C 			   ; / get written into the i-number portion
			      C 			 ; / of the entry
 09BA  83 2E 27BC R 0A	      C 	sub	word ptr [u.off], 10
			      C 		; sub $10.,u.off / move u.off back 1 directory entry
 09BF  E8 0048		      C 	call	wdir
			      C 		; jsr r0,wdir / free the directory entry
 09C2  58		      C 	pop	ax
			      C 		; mov (sp)+,r1 / get i-number back
 09C3  E8 07C0		      C 	call	iget
			      C 		; jsr r0,iget / get i-node
 09C6  E8 0882		      C 	call	setimod
			      C 		; jsr r0,setimod / set modified flag
 09C9  FE 0E 25EC R	      C 	dec	byte ptr [i.nlks]
			      C 		; decb i.nlks / decrement the number of links
			      C 	;jnz	sysret
			      C 	;	; bgt sysret9 / if this was not the last link
			      C 			    ; / to file return
			      C 	; 27/01/2022
 09CD  75 03		      C 	jnz	short @f
			      C 	;
			      C 	; AX = r1 = i-number
 09CF  E8 04E8		      C 	call	anyi
			      C 		; jsr r0,anyi / if it was, see if anyone has it open.
			      C 			 ; / Then free contents of file and destroy it.
 09D2			      C @@:
 09D2  E9 F93B		      C 	jmp	sysret
			      C 		; br sysret9
			      C 
 09D5			      C mkdir:
			      C 	; 01/08/2013
			      C 	; 29/04/2013
			      C 	; 'mkdir' makes a directory entry from the name pointed to
			      C 	; by u.namep into the current directory.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.namep - points to a file name 
			      C 	;	           that is about to be a directory entry.
			      C 	;    ii - current directory's i-number.	
			      C 	; OUTPUTS ->
			      C 	;    u.dirbuf+2 - u.dirbuf+10 - contains file name. 
			      C 	;    u.off - points to entry to be filled 
			      C 	;	     in the current directory		
			      C 	;    u.base - points to start of u.dirbuf.
			      C 	;    r1 - contains i-number of current directory 
			      C 	;	
			      C 	; ((AX = R1)) output
			      C 	;
			      C 	;    (Retro UNIX Prototype : 11/11/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: AX, DX, BX, CX, SI, DI, BP))  
			      C 	;
			      C 
 09D5  B9 0004		      C 	mov 	cx, 4
 09D8  33 C0		      C 	xor 	ax, ax
 09DA  BF 27CA R	      C         mov     di, offset u.dirbuf+2
 09DD  8B F7		      C 	mov	si, di
 09DF  F3/ AB		      C 	rep 	stosw
			      C 		; jsr r0,copyz; u.dirbuf+2; u.dirbuf+10. / clear this
 09E1  8B FE		      C 	mov	di, si
 09E3  8B 36 27BA R	      C 	mov	si, word ptr [u.namep]
			      C 		; mov u.namep,r2 / r2 points to name of directory entry
			      C 		; mov $u.dirbuf+2,r3 / r3 points to u.dirbuf+2
 09E7			      C mkdir_1: ; 1: 
			      C 	; / put characters in the directory name in u.dirbuf+2 - u.dirbuf+10
			      C 	; 01/08/2013
 09E7  0E		      C 	push	cs ; push ds
 09E8  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt]
 09EB  8E D8		      C 	mov	ds, ax
 09ED			      C @@:	
 09ED  AC		      C 	lodsb
			      C 		; movb (r2)+,r1 / move character in name to r1
 09EE  22 C0		      C 	and 	al, al
 09F0  74 11		      C 	jz 	short mkdir_2 	  
			      C 		; beq 1f / if null, done
 09F2  3C 2F		      C 	cmp	al, '/'
			      C 		; cmp r1,$'/ / is it a "/"?
 09F4  74 09		      C 	je	short @f
			      C 	;je	error
			      C 		; beq error9 / yes, error
 09F6  81 FF 27D2 R	      C         cmp     di, offset u.dirbuf+10
			      C 		; cmp r3,$u.dirbuf+10. / have we reached the last slot for
			      C 				     ; / a char?
 09FA  74 F1		      C 	je	short @b
			      C 	;je	short mkdir_1
			      C 		; beq 1b / yes, go back
 09FC  AA		      C 	stosb
			      C 		; movb r1,(r3)+ / no, put the char in the u.dirbuf
			      C 	; 01/08/2013
 09FD  EB EE		      C 	jmp 	short @b
			      C 	; jmp 	short mkdir_1
			      C 		; br 1b / get next char
 09FF			      C @@:
			      C 	; 01/08/2013
 09FF  1F		      C 	pop	ds
 0A00  E9 F8F0		      C 	jmp	error
			      C 
 0A03			      C mkdir_2: ; 1:
			      C 	; 01/08/2013
 0A03  1F		      C 	pop	ds
			      C 	;
 0A04  A1 27B8 R	      C 	mov	ax, word ptr [u.dirp]
 0A07  A3 27BC R	      C 	mov	word ptr [u.off], ax
			      C 		; mov u.dirp,u.off / pointer to empty current directory
			      C 				 ; / slot to u.off
 0A0A			      C wdir: 	; 27/01/2022
			      C 	; 29/04/2013
 0A0A  C7 06 27BE R 27C8 R    C         mov     word ptr [u.base], offset u.dirbuf
			      C 		; mov $u.dirbuf,u.base / u.base points to created file name
 0A10  C7 06 27C0 R 000A      C         mov     word ptr [u.count], 10
			      C 		; mov $10.,u.count / u.count = 10
 0A16  A1 26BE R	      C 	mov	ax, word ptr [ii] 
			      C 		; mov ii,r1 / r1 has i-number of current directory
 0A19  B2 01		      C 	mov	dl, 1 ; owner flag mask ; RETRO UNIX 8086 v1 modification !
 0A1B  E8 080A		      C 	call 	access
			      C 		; jsr r0,access; 1 / get i-node and set its file up 
			      C 				 ; / for writing
			      C 	; AX = i-number of current directory
			      C 	; 01/08/2013
 0A1E  FE 06 26FA R	      C 	inc     byte ptr [mkdir_w] ; the caller is 'mkdir' sign	
			      C 	;call	writei
			      C 	;	; jsr r0,writei / write into directory
			      C 	;retn	
			      C 	;	; rts r0
			      C 	; 27/01/2022
 0A22  E9 09CD		      C 	jmp	writei
			      C 
 0A25			      C sysexec:
			      C 	; 28/01/2022
			      C 	; 27/01/2022
			      C 	; 06/12/2013
			      C 	; 24/10/2013
			      C 	; 22/09/2013
			      C 	; 03/09/2013
			      C 	; 02/08/2013
			      C 	; 25/07/2013
			      C 	; 24/07/2013
			      C 	; 22/07/2013
			      C 	; 18/07/2013
			      C 	; 03/06/2013
			      C 	; 'sysexec' initiates execution of a file whose path name if
			      C 	; pointed to by 'name' in the sysexec call. 
			      C 	; 'ssysexec' performs the following operations:
			      C 	;    1. obtains i-number of file to be executed via 'namei'.
			      C 	;    2. obtains i-node of file to be exceuted via 'iget'.
			      C 	;    3. sets trap vectors to system routines.
			      C 	;    4. loads arguments to be passed to executing file into
			      C 	;	highest locations of user's core
			      C 	;    5. puts pointers to arguments in locations immediately
			      C 	;	following arguments.
			      C 	;    6.	saves number of arguments in next location.
			      C 	;    7. intializes user's stack area so that all registers
			      C 	;	will be zeroed and the PS is cleared and the PC set
			      C 	;	to core when 'sysret' restores registers 
			      C 	;	and does an rti.
			      C 	;    8. inializes u.r0 and u.sp
			      C 	;    9. zeros user's core down to u.r0
			      C 	;   10.	reads executable file from storage device into core
			      C 	;	starting at location 'core'.
			      C 	;   11.	sets u.break to point to end of user's code with
			      C 	;	data area appended.
			      C 	;   12.	calls 'sysret' which returns control at location
			      C 	;	'core' via 'rti' instruction. 		  		
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysexec; namep; argp
			      C 	; Arguments:
			      C 	;	namep - points to pathname of file to be executed
			      C 	;	argp  - address of table of argument pointers
			      C 	;	argp1... argpn - table of argument pointers
			      C 	;	argp1:<...0> ... argpn:<...0> - argument strings
			      C 	; Inputs: (arguments)
			      C 	; Outputs: -	
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	user/application segment and system/kernel segment
			      C 	;	are different and sysenter/sysret/sysrele routines
			      C 	;	are different (user's registers are saved to 
			      C 	;	and then restored from system's stack.)
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.)		 	
			      C 	
			      C 	;call	arg2
			      C 	; * name - 'u.namep' points to address of file/path name
			      C 	;          in the user's program segment ('u.segmnt')
			      C 	;          with offset in BX register (as sysopen argument 1).
			      C 	; * argp - sysexec argument 2 is in CX register 
			      C 	;          which is on top of stack.
			      C 	;
			      C 		; jsr r0,arg2 / arg0 in u.namep,arg1 on top of stack
 0A25  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx ; argument 1
 0A29  51		      C 	push	cx	; argument 2
 0A2A  E8 0200		      C 	call	namei
			      C 		; jsr r0,namei / namei returns i-number of file 
			      C 			     ; / named in sysexec call in r1
			      C 	;jc	error
			      C 	;	; br error9
			      C 	; 27/01/2022
 0A2D  73 03		      C 	jnc	short @f
 0A2F  E9 F8C1		      C 	jmp	error
 0A32			      C @@:
 0A32  E8 0751		      C 	call	iget
			      C 		; jsr r0,iget / get i-node for file to be executed
			      C 	; 27/01/2022
 0A35  F6 06 25EA R 10	      C 	test	byte ptr [i.flgs], 10h
			      C 	;test 	word ptr [i.flgs], 10h
			      C 		; bit $20,i.flgs / is file executable
			      C 	;jz	error
			      C 		; beq error9
			      C 	; 27/01/2022
 0A3A  75 03		      C 	jnz	short @f
 0A3C  E9 F8B4		      C 	jmp	error
 0A3F			      C @@:
 0A3F  E8 0C25		      C 	call	iopen
			      C 		; jsr r0,iopen / gets i-node for file with i-number
			      C 			     ; / given in r1 (opens file)
			      C 	; AX = i-number of the file
			      C 	; 28/01/2022
 0A42  F6 06 25EA R 20	      C 	test	byte ptr [i.flgs], 20h
			      C 	;test	word ptr [i.flgs], 20h
			      C 		; bit $40,i.flgs / test user id on execution bit
 0A47  74 0F		      C 	jz	short sysexec_1
			      C 		; beq 1f
 0A49  80 3E 27DC R 00	      C 	cmp 	byte ptr [u.uid_], 0 ; 02/08/2013
			      C 		; tstb u.uid / test user id
 0A4E  76 08		      C 	jna	short sysexec_1
			      C 		; beq 1f / super user
 0A50  8A 0E 25ED R	      C 	mov	cl, byte ptr [i.uid]
 0A54  88 0E 27DC R	      C 	mov	byte ptr [u.uid_], cl ; 02/08/2013
			      C 		; movb i.uid,u.uid / put user id of owner of file
			      C 				 ; / as process user id
 0A58			      C sysexec_1: ; 1:
			      C 	; 22/07/2013
 0A58  E8 FB6E		      C 	call	segm_sw  ; User segment switch
			      C 	; BX = New user segment ; 24/07/2013
			      C 	;
 0A5B  59		      C 	pop	cx
			      C 		; mov (sp)+,r5 / r5 now contains address of list of 
			      C 			     ; / pointers to arguments to be passed
			      C 		; mov $1,u.quit / u.quit determines handling of quits;
			      C 			      ; / u.quit = 1 take quit
			      C 		; mov $1,u.intr / u.intr determines handling of 
			      C 			     ; / interrupts; u.intr = 1 take interrupt
			      C 		; mov $rtssym,30 / emt trap vector set to take 
			      C 			       ; / system routine
			      C 		; mov $fpsym,*10 / reserved instruction trap vector 
			      C 			       ; / set to take system routine
			      C 	; 24/07/2013
 0A5C  BC 3F0E R	      C 	mov	sp, sstack ; offset sstack	
			      C 		; mov $sstack,sp / stack space used during swapping
			      C 	;push	cx
			      C 		; mov r5,-(sp) / save arguments pointer on stack
 0A5F  BF 7FC0		      C 	mov	di, ecore
			      C 		; mov $ecore,r5 / r5 has end of core
			      C 	;mov	bp, core
 0A62  33 ED		      C 	xor	bp, bp  ; core = 0
			      C 		; mov $core,r4 / r4 has start of users core
 0A64  89 2E 27BE R	      C 	mov	word ptr [u.base], bp
			      C 		; mov r4,u.base / u.base has start of users core
			      C 	;
			      C 	; 24/07/2013
 0A68  8E C3		      C 	mov	es, bx ; new user segment 
			      C 		; If the caller is a user, es = word ptr [u.segmnt]
			      C 		; If the caller is system (sysexec for '/etc/init')
			      C 		;     es = csgmnt and word ptr [u.segmnt] = cs
 0A6A  8B 16 27E0 R	      C 	mov	dx, word ptr [u.segmnt]
 0A6E  8E DA		      C 	mov	ds, dx
			      C 	;
 0A70  8B D9		      C 	mov	bx, cx
			      C 		; mov (sp),r2 / move arguments list pointer into r2
 0A72			      C sysexec_2: ; 1:
			      C 	; AX = i-number of the file (at return of 'iopen' call)
 0A72  8B 17		      C 	mov	dx, word ptr [BX]
 0A74  23 D2		      C 	and	dx, dx
 0A76  74 04		      C 	jz	short @f	
			      C 		; tst (r2)+ / argument char = "nul"
			      C 		; bne 1b
 0A78  43		      C 	inc	bx
 0A79  43		      C 	inc	bx
 0A7A  EB F6		      C 	jmp	short sysexec_2
 0A7C			      C @@:
			      C 	; tst -(r2) / decrement r2 by 2; r2 has addr of end of 
			      C 		  ; / argument pointer list
 0A7C			      C sysexec_3: ; 1:
			      C 	     ; / move arguments to bottom of users core
 0A7C  4B		      C 	dec	bx
 0A7D  4B		      C 	dec	bx
			      C 	;mov	si, word ptr [BX]
			      C 		;; mov -(r2),r3 / (r3) last non zero argument ptr
 0A7E  3B D9		      C 	cmp	bx, cx
			      C 		; cmp r2,(sp) / is r2 = beginning of argument
			      C 			    ; / ptr list
 0A80  72 20		      C 	jb	short sysexec_6
			      C 		; blo 1f / branch to 1f when all arguments
			      C 		       ; / are moved
 0A82  8B 37		      C 	mov	si, word ptr [BX]
			      C 		; mov -(r2),r3 / (r3) last non zero argument ptr
 0A84			      C sysexec_4: ; 2:
 0A84  8A 14		      C 	mov	dl, byte ptr [SI]
 0A86  22 D2		      C 	and	dl, dl
			      C 		; tstb (r3)+
 0A88  74 03		      C 	jz	short sysexec_5
 0A8A  46		      C 	inc	si
 0A8B  EB F7		      C 	jmp	short sysexec_4
			      C 		; bne 2b / scan argument for \0 (nul)
 0A8D			      C sysexec_5: ; 2:
 0A8D  4F		      C 	dec	di
 0A8E  26: 88 15	      C 	mov	byte ptr ES:[DI], dl ; 24/07/2013	
			      C 		; movb -(r3),-(r5) / move argument char 
			      C 				 ; / by char starting at "ecore"
 0A91  3B 37		      C 	cmp	si, word ptr [BX]
			      C 		; cmp r3,(r2) / moved all characters in 
			      C 			    ; / this argument
			      C 		; bhi 2b / branch 2b if not
 0A93  76 05		      C 	jna	short @f
 0A95  4E		      C 	dec	si
 0A96  8A 14		      C 	mov	dl, byte ptr [SI]
 0A98  EB F3		      C 	jmp	short sysexec_5
 0A9A			      C @@:
 0A9A  26: 89 7E 00	      C 	mov	word ptr ES:[BP], di ; 24/07/2013
 0A9E  45		      C 	inc	bp
 0A9F  45		      C 	inc	bp	
			      C 		; mov r5,(r4)+ / move r5 into top of users core;
			      C 			     ; / r5 has pointer to nth arg
 0AA0  EB DA		      C 	jmp	sysexec_3
			      C 		; br 1b / string
 0AA2			      C sysexec_6: ; 1:
 0AA2  4F		      C 	dec	di
 0AA3  4F		      C 	dec	di ; 24/10/2013
			      C 	;mov	byte ptr ES:[DI], 0 ; 24/07/2013
			      C 		; clrb -(r5)
 0AA4  D1 EF		      C 	shr	di, 1
 0AA6  D1 E7		      C 	shl	di, 1
			      C 		; bic $1,r5 / make r5 even, r5 points to 
			      C 			; / last word of argument strings
			      C 	;mov	si, core
 0AA8  33 F6		      C 	xor	si, si ; core = 0
			      C 		; mov $core,r2
 0AAA  26: 89 35	      C 	mov	word ptr ES:[DI], si ; 24/07/2013
 0AAD			      C sysexec_7: ; 1: / move argument pointers into core following 
			      C 	      ; / argument strings
 0AAD  3B F5		      C 	cmp	si, bp
			      C 		; cmp r2,r4
 0AAF  73 0C		      C 	jnb	short sysexec_8
			      C 		; bhis 1f / branch to 1f when all pointers
			      C 			; / are moved
 0AB1  26: 8B 14	      C 	mov	dx, word ptr ES:[SI] ; 25/07/2013
 0AB4  46		      C 	inc	si
 0AB5  4F		      C 	dec	di
 0AB6  46		      C 	inc	si
 0AB7  4F		      C 	dec	di
 0AB8  26: 89 15	      C 	mov	word ptr ES:[DI], dx ; 24/07/2013
			      C 		; mov (r2)+,-(r5)
 0ABB  EB F0		      C 	jmp	short sysexec_7
			      C 		; br 1b
 0ABD			      C sysexec_8: ; 1:
			      C 	;sub 	bp, core ; core  = 0
			      C 		; sub $core,r4 / gives number of arguments *2
 0ABD  D1 ED		      C 	shr	bp, 1
			      C 		; asr r4 / divide r4 by 2 to calculate 
			      C 		       ; / the number of args stored
 0ABF  4F		      C 	dec	di
 0AC0  4F		      C 	dec	di
 0AC1  26: 89 2D	      C 	mov	word ptr ES:[DI], bp ; 24/07/2013
			      C 		; mov r4,-(r5) / save number of arguments ahead
			      C 			     ; / of the argument pointers
 0AC4  33 C9		      C 	xor	cx, cx
 0AC6  9C		      C 	pushf	
 0AC7  5A		      C 	pop	dx
 0AC8  4F		      C 	dec	di
 0AC9  4F		      C 	dec	di
			      C 	; 24/07/2013 (ES:[DI])
 0ACA  26: 89 15	      C 	mov	word ptr ES:[DI], dx ; FLAGS (for 'IRET')
			      C 		; clr -(r5) / popped into ps when rti in 
			      C 			  ; / sysrele is executed
 0ACD  8C C3		      C 	mov	bx, es	; 24/07/2013
 0ACF  4F		      C 	dec	di
 0AD0  4F		      C 	dec	di
 0AD1  26: 89 1D	      C 	mov	word ptr ES:[DI], bx ; CS (for 'IRET')
			      C 	;mov	cx, core ; core = 0
 0AD4  4F		      C 	dec	di
 0AD5  4F		      C 	dec	di
 0AD6  26: 89 0D	      C 	mov	word ptr ES:[DI], cx ; IP (for 'IRET')	
			      C 		; mov $core,-(r5) / popped into pc when rti 
			      C 		                ; / in sysrele is executed
			      C 		;mov r5,0f / load second copyz argument
			      C 		;tst -(r5) / decrement r5
			      C 	;
 0AD9  8C CB		      C 	mov	bx, cs
 0ADB  8E DB		      C 	mov	ds, bx
			      C 	;
 0ADD  89 0E 27A8 R	      C 	mov	word ptr [u.r0], cx ; ax = 0
 0AE1  89 3E 27A6 R	      C 	mov	word ptr [u.usp], di
 0AE5  57		      C 	push	di ; user's stack pointer
 0AE6  51		      C 	push	cx ; dx = 0
 0AE7  51		      C 	push	cx ; cx = 0
 0AE8  51		      C 	push	cx ; bx = 0
 0AE9  51		      C 	push	cx ; si = 0
 0AEA  51		      C 	push	cx ; di = 0
 0AEB  51		      C 	push	cx ; bp = 0
 0AEC  89 26 27A4 R	      C 	mov	word ptr [u.sp_], sp
 0AF0  8B CF		      C 	mov	cx, di
			      C 	; 24/07/2013
 0AF2  33 FF		      C 	xor	di, di ; 0
 0AF4  50		      C 	push	ax ; i-number
 0AF5  33 C0		      C 	xor	ax, ax ; 0
 0AF7  D1 E9		      C 	shr	cx, 1  ; cx/2 -> word count
			      C 	; ES = word ptr [u.segmnt] or csgmnt
 0AF9  F3/ AB		      C 	rep	stosw  ; clear user's core/memory segment
 0AFB  8C C0		      C 	mov	ax, es ; 24/07/2013
 0AFD  A3 27E0 R	      C 	mov 	word ptr [u.segmnt], ax ; 24/07/2013
 0B00  8E C3		      C 	mov	es, bx ;  es = ds = cs
 0B02  58		      C 	pop	ax ; i-number
			      C 		; mov r5,u.r0 /
			      C 		; sub $16.,r5 / skip 8 words
			      C 		; mov r5,u.sp / assign user stack pointer value, 
			      C 		;             / effectively zeroes all regs
			      C 			    ; / when sysrele is executed
			      C 		; jsr r0,copyz; core; 0:0 / zero user's core
 0B03  89 0E 27C4 R	      C 	mov	word ptr [u.break_], cx ; 0
			      C 		; clr u.break
			      C 		; mov r5,sp / point sp to user's stack
 0B07  C7 06 27C0 R 000C      C 	mov	word ptr [u.count], 12
			      C 		; mov $14,u.count
 0B0D  C7 06 27B6 R 27BC R    C 	mov	word ptr [u.fofp], offset u.off
			      C 		; mov $u.off,u.fofp
 0B13  89 0E 27BC R	      C 	mov	word ptr [u.off], cx ; 0
			      C 		; clr u.off / set offset in file to be read to zero
			      C 	; AX = i-number of the executable file
 0B17  E8 07D9		      C 	call	readi
			      C 		; jsr r0,readi / read in first six words of 
			      C 			; / user's file, starting at $core
 0B1A  8B 0E 27A6 R	      C 	mov	cx, word ptr [u.usp]
			      C 		; mov sp,r5 / put users stack address in r5
 0B1E  83 E9 28		      C 	sub	cx, core+40 ; 40 bytes will be reserved 
			      C 			    ;          for user stack
			      C 		; sub $core+40.,r5 / subtract $core +40, 
			      C 				; / from r5 (leaves number of words
			      C 				; / less 26 available for
			      C 			     	; / program in user core
 0B21  89 0E 27C0 R	      C 	mov	word ptr [u.count], cx
			      C 		; mov r5,u.count /
 0B25  8B 1E 27E0 R	      C 	mov	bx, word ptr [u.segmnt]
 0B29  8E C3		      C 	mov	es, bx
			      C 	;mov	bx, core ; 0
 0B2B  33 DB		      C 	xor 	bx, bx ; 0
 0B2D  26: 81 3F 0AEB	      C 	cmp	word ptr ES:[BX], 0AEBh ; EBh, 0Ah -> jump to +12
			      C 		; cmp core,$405 / br .+14 is first instruction 
			      C 			      ; / if file is standard a.out format
 0B32  75 32		      C 	jne	short	sysexec_9
			      C 		; bne 1f / branch, if not standard format
 0B34  80 C3 02		      C 	add	bl, 2
			      C 	;add	cx, word ptr ES:[BX]+2
 0B37  26: 03 0F	      C 	add	cx, word ptr ES:[BX]
			      C 		; mov core+2,r5 / put 2nd word of users program in r5;
			      C 			      ; / number of bytes in program text
 0B3A  8C DA		      C 	mov	dx, ds
 0B3C  8E C2		      C 	mov	es, dx
			      C 	;
 0B3E  83 E9 0C		      C 	sub	cx, 12
			      C 		; sub $14,r5 / subtract 12
 0B41  3B 0E 27C0 R	      C 	cmp	cx, word ptr [u.count]
			      C 		; cmp r5,u.count /
 0B45  7F 1F		      C 	jg	short sysexec_9
			      C 		; bgt 1f / branch if r5 greater than u.count
 0B47  89 0E 27C0 R	      C 	mov	word ptr [u.count], cx
			      C 		; mov r5,u.count
 0B4B  53		      C 	push	bx
 0B4C  E8 07A4		      C 	call	readi
			      C 		; jsr r0,readi / read in rest of user's program text
 0B4F  8B 1E 27E0 R	      C 	mov	bx, word ptr [u.segmnt]
 0B53  8E C3		      C 	mov	es, bx
 0B55  5B		      C 	pop	bx
			      C 	;mov	cx,  word ptr ES:[BX]+8
 0B56  80 C3 06		      C 	add	bl, 6 ; 2+6 = 8	
 0B59  26: 8B 0F	      C 	mov	cx, word ptr ES:[BX]
			      C 	;
 0B5C  8C DB		      C 	mov	bx, ds
 0B5E  8E C3		      C 	mov	es, bx
			      C 	;
 0B60  89 0E 27C2 R	      C 	mov	word ptr [u.nread], cx
			      C 		; add core+10,u.nread / add size of user data area 
			      C 		                    ; / to u.nread
 0B64  EB 03		      C 	jmp	short sysexec_10
			      C 		; br 2f
 0B66			      C sysexec_9: ; 1:
 0B66  E8 078A		      C 	call	readi
			      C 		; jsr r0,readi / read in rest of file
 0B69			      C sysexec_10: ; 2:
 0B69  8B 0E 27C2 R	      C 	mov	cx, word ptr [u.nread]
 0B6D  83 C1 0C		      C 	add	cx, core+12 ; 18/07/2013
			      C 	;mov	word ptr [u.break_], cx
			      C 		; mov u.nread,u.break / set users program break to end of 
			      C 				    ; / user code
			      C 	;add	word ptr [u.break_], core+12 ; 12
			      C 		; add $core+14,u.break / plus data area
 0B70  89 0E 27C4 R	      C 	mov	word ptr [u.break_], cx ; 18/07/2013
 0B74  E8 0C1E		      C 	call	iclose
			      C 		; jsr r0,iclose / does nothing
			      C 	;;mov	sp , word ptr [u.sp_]
			      C 	;
			      C 	; 06/12/2013
 0B77  33 C0		      C 	xor 	ax, ax
 0B79  FE C0		      C 	inc	al
 0B7B  A3 27D4 R	      C 	mov	word ptr [u.intr], ax ; 1 (interrupt/time-out is enabled)
 0B7E  A3 27D6 R	      C 	mov	word ptr [u.quit], ax ; 1 ('crtl+brk' signal is enabled)
			      C 	;
 0B81  E9 F78C		      C 	jmp	sysret
			      C 		; br sysret3 / return to core image at $core
			      C 
 0B84			      C sysfstat:
			      C 	; 09/05/2022
			      C 	;	([idev] return in ax)
			      C 	;	0 = root device
			      C 	;	1 = mounted device (>0)
			      C 	; 27/01/2022
			      C 	; 19/06/2013
			      C 	; 'sysfstat' is identical to 'sysstat' except that it operates
			      C 	; on open files instead of files given by name. It puts the
			      C 	; buffer address on the stack, gets the i-number and
			      C 	; checks to see if the file is open for reading or writing.
			      C 	; If the file is open for writing (i-number is negative)
			      C 	; the i-number is set positive and a branch into 'sysstat'
			      C 	; is made.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysfstat; buf
			      C 	; Arguments:
			      C 	;	buf - buffer address
			      C 	;
			      C 	; Inputs: *u.r0 - file descriptor
			      C 	; Outputs: buffer is loaded with file information
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;       'sysfstat' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysfstat system call arguments from the user;
			      C 	;	* 1st argument, file descriptor is in BX register
			      C 	;	* 2nd argument, buf is pointed to by CX register
			      C 
			      C ; / set status of open file
			      C 	;call	arg2
			      C 		; jsr r0,arg; u.off / put buffer address in u.off
 0B84  51		      C 	push	cx
			      C 		; mov u.off,-(sp) / put buffer address on the stack
			      C 		; mov ax, word ptr [u.r0]
			      C 		; mov *u.r0,r1 / put file descriptor in r1
			      C 		;jsr r0,getf / get the files i-number
			      C 	; BX = file descriptor (file number)
 0B85  E8 0078		      C 	call	getf1
 0B88  23 C0		      C 	and	ax, ax ; i-number of the file
			      C 		; tst	r1 / is it 0?
			      C 	;jz	error
			      C 		; beq error3 / yes, error
			      C 	; 27/01/2022
 0B8A  75 03		      C 	jnz	short @f
 0B8C  E9 F764		      C 	jmp	error
 0B8F			      C @@:
 0B8F  80 FC 80		      C 	cmp	ah, 80h
 0B92  72 11		      C 	jb	short @f
			      C 		; bgt 1f / if i-number is negative (open for writing)
 0B94  F7 D8		      C 	neg	ax
			      C 		; neg r1 / make it positive, then branch
 0B96  EB 0D		      C 	jmp	short @f
			      C 		; br 1f / to 1f
 0B98			      C sysstat:
			      C 	; 09/05/2022
			      C 	;	([idev] return in ax)
			      C 	;	0 = root device
			      C 	;	1 = mounted device (>0)
			      C 	; 27/01/2022
			      C 	; 19/06/2013
			      C 	; 'sysstat' gets the status of a file. Its arguments are the
			      C 	; name of the file and buffer address. The buffer is 34 bytes
			      C 	; long and information about the file placed in it.	
			      C 	; sysstat calls 'namei' to get the i-number of the file.
			      C 	; Then 'iget' is called to get i-node in core. The buffer
			      C 	; is then loaded and the results are given in the UNIX
			      C 	; Programmers Manual sysstat (II).	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysstat; name; buf
			      C 	; Arguments:
			      C 	;	name - points to the name of the file
			      C 	;	buf - address of a 34 bytes buffer
			      C 	; Inputs: -
			      C 	; Outputs: buffer is loaded with file information
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysstat' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysstat system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, buf is pointed to by CX register
			      C 	;
			      C 	;	NOTE: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	      arguments which were in these registers;
			      C 	;	      but, it returns by putting the 1st argument
			      C 	;	      in 'u.namep' and the 2nd argument
			      C 	;	      on top of stack. (1st argument is offset of the
			      C 	;	      file/path name in the user's program segment.)		 	
			      C 	
			      C ; / ; name of file; buffer - get files status
			      C 	;call	arg2
			      C 		; jsr r0,arg2 / get the 2 arguments
 0B98  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 0B9C  51		      C 	push	cx
 0B9D  E8 008D		      C 	call	namei
			      C 		; jsr r0,namei / get the i-number for the file
			      C 	;jc	error
			      C 		; br error3 / no such file, error
			      C 	; 27/01/2022
 0BA0  73 03		      C 	jnc	short @f
 0BA2  E9 F74E		      C 	jmp	error
 0BA5			      C @@: ; 1:
 0BA5  E8 05DE		      C 	call	iget
			      C 		; jsr r0,iget / get the i-node into core
 0BA8  8B 36 27E0 R	      C 	mov	si, word ptr [u.segmnt]
 0BAC  5F		      C 	pop	di
			      C 		; mov (sp)+,r3 / move u.off to r3 (points to buffer)
 0BAD  8E C6		      C 	mov	es, si	
 0BAF  AB		      C 	stosw
			      C 		; mov r1,(r3)+ / put i-number in 1st word of buffer
			      C 	;mov	si, offset inode
 0BB0  BE 25EA R	      C 	mov	si, offset i
			      C 		; mov $inode,r2 / r2 points to i-node
 0BB3			      C @@: ; 1:
 0BB3  A5		      C 	movsw
			      C 		; mov (r2)+,(r3)+ / move rest of i-node to buffer
 0BB4  81 FE 260A R	      C 	cmp	si, offset i + 32
			      C 		; cmp r2,$inode+32 / done?
 0BB8  75 F9		      C 	jne	short @b
			      C 		; bne 1b / no, go back
 0BBA  8C D8		      C 	mov	ax, ds
 0BBC  8E C0		      C 	mov	es, ax
			      C 
			      C 	;;;
			      C 	; 09/05/2022
			      C 	;*** additional feature *** -retro unix only- 
			      C 	;
			      C 	; !! return device number -of current inode- in ax !!
			      C 	;
			      C 	; (modification reason/purpose:
			      C 	; to improve 'pwd' command's pathname output/result
			      C 	; and to correct 'cp' command's 'can not copy file itself'
			      C 	; error due to same inode numbers in root file system
			      C 	; and mounted file system.)
			      C 	;
 0BBE  32 E4		      C 	xor	ah, ah
 0BC0  A0 26C0 R	      C 	mov	al, byte ptr [idev] ; byte ptr [cdev]
 0BC3  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 	;;;  
			      C 
 0BC6  E9 F747		      C 	jmp	sysret
			      C 		; br sysret3 / return through sysret
			      C 
 0BC9			      C fclose:
			      C 	; 12/01/2014
			      C 	; 05/08/2013
			      C 	; 30/07/2013
			      C 	; 19/04/2013
			      C 	; Given the file descriptor (index to the u.fp list)
			      C 	; 'fclose' first gets the i-number of the file via 'getf'.
			      C 	; If i-node is active (i-number > 0) the entry in 
			      C 	; u.fp list is cleared. If all the processes that opened
			      C 	; that file close it, then fsp etry is freed and the file
			      C 	; is closed. If not a return is taken. 
			      C 	; If the file has been deleted while open, 'anyi' is called
			      C 	; to see anyone else has it open, i.e., see if it is appears
			      C 	; in another entry in the fsp table. Upon return from 'anyi'
			      C 	; a check is made to see if the file is special.	
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - contains the file descriptor (value=0,1,2...)
			      C 	;    u.fp - list of entries in the fsp table
			      C 	;    fsp - table of entries (4 words/entry) of open files.	 
			      C 	; OUTPUTS ->
			      C 	;    r1 - contains the same file descriptor
			      C 	;    r2 - contains i-number
			      C 	;
			      C 	; ((AX = R1))
			      C 	; ((Modified registers: DX, BX, CX, SI, DI, BP))
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification : CF = 1
			      C 	;              if i-number of the file is 0. (error)  	
			      C 	;
 0BC9  8B D0		      C 	mov	dx, ax ; **
 0BCB  50		      C 	push	ax ; ***
			      C 		; mov r1,-(sp) / put r1 on the stack (it contains 
			      C 			     ; / the index to u.fp list)
 0BCC  E8 002F		      C 	call	getf
			      C 		; jsr r0,getf / r1 contains i-number, 
			      C 			    ; / cdev has device =, u.fofp 
			      C 			    ; / points to 3rd word of fsp entry
 0BCF  83 F8 01		      C 	cmp	ax, 1 ; r1
			      C 		; tst r1 / is inumber 0?
 0BD2  72 28		      C 	jb	short fclose_2
			      C 		; beq 1f / yes, i-node not active so return
			      C 		; tst (r0)+ / no, jump over error return
 0BD4  8B DA		      C 	mov	bx, dx ; **
 0BD6  8B D0		      C 	mov 	dx, ax ; *
			      C 		; mov r1,r2 / move i-number to r2 ;*
			      C 		; mov (sp),r1 / restore value of r1 from the stack
			      C 			    ; / which is index to u.fp ; **
 0BD8  C6 87 27AC R 00	      C 	mov	byte ptr [BX]+u.fp, 0 ; 30/07/2013
			      C 		; clrb u.fp(r1) / clear that entry in the u.fp list
 0BDD  8B 1E 27B6 R	      C 	mov	bx, word ptr [u.fofp]
			      C 		; mov u.fofp,r1 / r1 points to 3rd word in fsp entry
 0BE1			      C @@:
 0BE1  FE 4F 02		      C 	dec	byte ptr [BX]+2
			      C 		; decb 2(r1) / decrement the number of processes 
			      C 			   ; / that have opened the file
 0BE4  79 16		      C 	jns	short fclose_2 ; jump if not negative (jump if bit 7 is 0)	 
			      C 		; bge 1f / if all processes haven't closed the file, return
			      C 	;
 0BE6  52		      C 	push	dx ;*
			      C 		; mov r2,-(sp) / put r2 on the stack (i-number)
 0BE7  33 C0		      C 	xor	ax, ax ; 0
 0BE9  89 47 FC		      C 	mov	word ptr [BX]-4, ax ; 0
			      C 		; clr -4(r1) / clear 1st word of fsp entry
			      C 	; 12/1/2014 (removing Retro UNIX 8086 v1 modification, 30/7/2013)
			      C 	;	    (returning to original unix v1 code)	
 0BEC  8A 47 03		      C 	mov	al, byte ptr [BX]+3
			      C 		; tstb	3(r1) / has this file been deleted
 0BEF  22 C0		      C 	and	al, al
 0BF1  74 05		      C 	jz	short fclose_1
			      C 		; beq 2f / no, branch
 0BF3  8B C2		      C 	mov	ax, dx ; *
			      C 		; mov r2,r1 / yes, put i-number back into r1
			      C 	; AX = inode number
 0BF5  E8 02C2		      C 	call	anyi
			      C 		; jsr r0,anyi / free all blocks related to i-number
			      C 			    ; / check if file appears in fsp again
 0BF8			      C fclose_1: ; 2:
 0BF8  58		      C 	pop	ax ; *
			      C 		; mov (sp)+,r1 / put i-number back into r1
 0BF9  E8 0B99		      C 	call	iclose ; close if it is special file 
			      C 		; jsr r0,iclose / check to see if its a special file
 0BFC			      C fclose_2: ; 1:
 0BFC  58		      C 	pop	ax ; ***
			      C 		; mov (sp)+,r1 / put index to u.fp back into r1
 0BFD  C3		      C 	retn
			      C 		; rts r0
			      C 
 0BFE			      C getf:	
			      C 	; 30/01/2022
			      C 	; 27/01/2022
			      C 	; 18/11/2013 (mov ax, bx)
			      C 	; 19/04/2013
			      C 	; / get the device number and the i-number of an open file
 0BFE  8B D8		      C 	mov	bx, ax
 0C00			      C getf1: ;; Calling point from 'rw1' (23/05/2013)
 0C00  83 FB 0A		      C 	cmp	bx, 10
			      C 		; cmp r1,$10. / user limited to 10 open files
			      C         ;jnb	error
			      C 		; bhis error3 / u.fp is table of users open files, 
			      C 			    ; / index in fsp table
			      C 	; 27/01/2022
 0C03  72 03		      C 	jb	short @f
 0C05  E9 F6EB		      C 	jmp	error
 0C08			      C @@:	
 0C08  8A 9F 27AC R	      C 	mov	bl, byte ptr [BX]+u.fp
			      C 		; movb	u.fp(r1),r1 / r1 contains number of entry 
			      C 		                  ; / in fsp table
 0C0C  0A DB		      C 	or	bl, bl
 0C0E  75 03		      C 	jnz	short @f ; 18/11/2013
			      C 	;jz	short @f
			      C 		; beq 1f / if its zero return
			      C 	; 18/11/2013
 0C10  8B C3		      C 	mov	ax, bx ; 0
 0C12  C3		      C 	retn
 0C13			      C @@:	
 0C13  D1 E3		      C 	shl	bx, 1
			      C 		; asl r1
 0C15  D1 E3		      C 	shl	bx, 1
			      C 		; asl r1 / multiply by 8 to get index into 
			      C 		       ; / fsp table entry
 0C17  D1 E3		      C 	shl 	bx, 1
			      C 		; asl r1
			      C 	; 30/01/2022
 0C19  81 C3 2890 R	      C 	add	bx, fsp-4 ; add bx, offset fsp - 4
			      C 		; add $fsp-4,r1 / r1 is pointing at the 3rd word 
			      C 			      ; / in the fsp entry
 0C1D  89 1E 27B6 R	      C 	mov	word ptr [u.fofp], bx
			      C 		; mov r1,u.fofp / save address of 3rd word 
			      C 			      ; / in fsp entry in u.fofp
 0C21  4B		      C 	dec	bx
 0C22  4B		      C 	dec	bx
 0C23  8B 07		      C 	mov	ax, word ptr [BX]
			      C 	;mov	byte ptr [cdev], al ; ;;Retro UNIX 8086 v1 ! 
 0C25  A3 26C2 R	      C 	mov	word ptr [cdev], ax ; ;;in fact (!) 
			      C 				    ; ;;dev number is in 1 byte
			      C 		; mov -(r1),cdev / remove the device number  cdev
 0C28  4B		      C 	dec	bx
 0C29  4B		      C 	dec	bx
 0C2A  8B 07		      C 	mov	ax, word ptr [BX]
			      C 		; mov -(r1),r1 / and the i-number  r1
			      C ;@@:	; 1:
 0C2C  C3		      C 	retn
			      C 		; rts r0
			      C 
 0C2D			      C namei:
			      C 	; 11/05/2022
			      C 	; 10/05/2022 (mounted directory path, '..' method) 
			      C 	; 27/01/2022
			      C 	; 31/07/2013
			      C 	; 28/07/2013
			      C 	; 26/07/2013 (namei_r)
			      C 	; 22/07/2013
			      C 	; 18/07/2013
			      C 	; 09/07/2013 mov ax, word ptr [rootdir]
			      C 	; 27/05/2013 (cf=1 return for indicating 'file not found')
			      C 	; 24/04/2013
			      C 	; 'namei' takes a file path name and returns i-number of
			      C 	; the file in the current directory or the root directory
			      C 	; (if the first character of the pathname is '/').	
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.namep - points to a file path name
			      C 	;    u.cdir - i-number of users directory
			      C 	;    u.cdev - device number on which user directory resides	
			      C 	; OUTPUTS ->
			      C 	;    r1 - i-number of file
			      C 	;    cdev
			      C 	;    u.dirbuf - points to directory entry where a match 
			      C 	;               occurs in the search for file path name.
			      C 	;	        If no match u.dirb points to the end of 
			      C 	;               the directory and r1 = i-number of the current
			      C 	;	        directory.	
			      C 	; ((AX = R1))
			      C 	;
			      C 	;    (Retro UNIX Prototype : 07/10/2012 - 05/01/2013, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, BX, CX, SI, DI, BP))  
			      C 	;
			      C 
			      C 	;;push	es ; Retro UNIX 8086 v1 Feature only !
 0C2D  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt] ; Retro UNIX 8086 v1 Feature only !
 0C30  8E C0		      C 	mov	es, ax ; Retro UNIX 8086 v1 Feature only !
			      C 
 0C32  A1 27AA R	      C 	mov	ax, word ptr [u.cdir]
			      C 		; mov u.cdir,r1 / put the i-number of current directory
			      C 			      ; / in r1
 0C35  8B 16 27DA R	      C 	mov	dx, word ptr [u.cdrv]
 0C39  89 16 26C2 R	      C 	mov	word ptr [cdev], dx ; NOTE: Retro UNIX 8086 v1 
			      C 				    ; device/drive number is in 1 byte, 
			      C 				    ; not in 1 word!
			      C 		; mov u.cdev,cdev / device number for users directory 
			      C 				; / into cdev
 0C3D  33 D2		      C 	xor	dx, dx ; 18/07/2013
 0C3F  8B 36 27BA R	      C 	mov	si, word ptr [u.namep]
 0C43  26: 80 3C 2F	      C 	cmp	byte ptr ES:[SI], '/'
			      C 		; cmpb *u.namep,$'/ / is first char in file name a /
 0C47  75 0C		      C 	jne	short namei_1
			      C 		; bne 1f
 0C49  46		      C 	inc 	si  ; go to next char
 0C4A  89 36 27BA R	      C 	mov 	word ptr [u.namep], si
			      C 		; inc u.namep / go to next char
 0C4E  A1 26F0 R	      C 	mov	ax, word ptr [rootdir] ; 09/07/2013 (mov ax, rootdir)
			      C 		; mov rootdir,r1 / put i-number of rootdirectory in r1
			      C 	;xor	dx, dx
 0C51  89 16 26C2 R	      C 	mov	word ptr [cdev], dx
			      C 		; clr cdev / clear device number
 0C55			      C namei_1: ; 1:
			      C 	;; 18/07/2013
 0C55  26: 8A 14	      C 	mov	dl, byte ptr ES:[SI]
 0C58  8C C9		      C 	mov	cx, cs
 0C5A  8E C1		      C         mov 	es, cx
 0C5C  22 D2		      C 	and	dl, dl
 0C5E  74 54		      C         jz      short nig
			      C 	;;		
			      C 	;cmp	byte ptr ES:[SI], dl ; 0
			      C 		; tstb *u.namep / is the character in file name a nul
			      C 	;;jna	nig
			      C 		; beq nig / yes, end of file name reached; 
			      C 			; / branch to "nig"
 0C60			      C namei_2: ; 1:
			      C 	;mov	dx, 2
 0C60  B2 02		      C 	mov	dl, 2 ; user flag (read, non-owner)
 0C62  E8 05C3		      C 	call	access
			      C 		; jsr r0,access; 2 / get i-node with i-number r1
			      C 	; 'access' will not return here if user has not "r" permission !
			      C 	; 27/01/2022
 0C65  F6 06 25EB R 40	      C 	test	byte ptr [i.flgs+1], 40h
			      C 	;test 	word ptr [i.flgs], 4000h
			      C 		; bit $40000,i.flgs / directory i-node?
			      C 	;jz 	error
			      C 		; beq error3 / no, got an error
			      C 	; 27/01/2022
 0C6A  75 03		      C 	jnz	short @f
 0C6C  E9 F684		      C 	jmp	error
 0C6F			      C @@:
 0C6F  A1 25EE R	      C 	mov	ax, word ptr [i.size_]
 0C72  A3 27B8 R	      C 	mov	word ptr [u.dirp], ax
			      C 		; mov i.size,u.dirp / put size of directory in u.dirp
 0C75  33 C0		      C 	xor	ax, ax
 0C77  A3 27BC R	      C 	mov	word ptr [u.off], ax ; 0
			      C 		; clr u.off / u.off is file offset used by user
 0C7A  C7 06 27B6 R 27BC R    C 	mov	word ptr [u.fofp], offset u.off
			      C 		; mov $u.off,u.fofp / u.fofp is a pointer to 
			      C 				  ; / the offset portion of fsp entry
 0C80			      C namei_3: ; 2:
 0C80  C7 06 27BE R 27C8 R    C 	mov	word ptr [u.base], offset u.dirbuf
			      C 		; mov $u.dirbuf,u.base / u.dirbuf holds a file name 
			      C 				    ; / copied from a directory
 0C86  C7 06 27C0 R 000A      C 	mov 	word ptr [u.count], 10 	
			      C  		; mov $10.,u.count / u.count is byte count 
			      C 				 ; / for reads and writes
 0C8C  A1 26BE R	      C 	mov 	ax, word ptr [ii]
			      C 
			      C 	; 31/07/2013
 0C8F  FE 06 26F9 R	      C  	inc     byte ptr [namei_r] ; the caller is 'namei' sign	
			      C         ; 28/07/2013 nameir -> u.nameir
			      C         ; 26/07/2013
			      C         ;;inc     byte ptr [u.namei_r] ; the caller is 'namei' sign
 0C93  E8 065D		      C 	call	readi 
			      C 	; ES = DS after 'readi' !
			      C 		; jsr r0,readi / read 10. bytes of file 
			      C 		      ; with i-number (r1); i.e. read a directory entry
 0C96  8B 0E 27C2 R	      C 	mov 	cx, word ptr [u.nread]
 0C9A  0B C9		      C 	or 	cx, cx
			      C 		; tst u.nread
 0C9C  74 13		      C 	jz	short nib
			      C 		; ble nib / gives error return
			      C 	;
 0C9E  8B 1E 27C8 R	      C 	mov 	bx, word ptr [u.dirbuf]
 0CA2  23 DB		      C 	and 	bx, bx       
			      C 		; tst u.dirbuf /
 0CA4  75 0F		      C 	jnz	short namei_4
			      C 		; bne 3f / branch when active directory entry 
			      C 		       ; / (i-node word in entry non zero)
 0CA6  A1 27BC R	      C 	mov	ax, word ptr [u.off]
 0CA9  83 E8 0A		      C 	sub	ax, 10
 0CAC  A3 27B8 R	      C 	mov	word ptr [u.dirp], ax
			      C 		; mov u.off,u.dirp
			      C 		; sub $10.,u.dirp
 0CAF  EB CF		      C 	jmp	short namei_3
			      C 		; br 2b
			      C 	; 18/07/2013
 0CB1			      C nib: 
 0CB1  33 C0		      C 	xor	ax, ax
 0CB3  F9		      C 	stc
 0CB4			      C nig:
 0CB4  C3		      C 	retn
			      C 
 0CB5			      C namei_4: ; 3:
 0CB5  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt] ; Retro UNIX 8086 v1 Feature only !
			      C 	;
 0CB8  8B 36 27BA R	      C 	mov 	si, word ptr [u.namep]
			      C 		; mov u.namep,r2 / u.namep points into a file name string
 0CBC  BF 27CA R	      C 	mov 	di, offset u.dirbuf + 2
			      C 		; mov $u.dirbuf+2,r3 / points to file name of directory entry
 0CBF  BA 27D2 R	      C 	mov 	dx, offset u.dirbuf + 10
			      C 	; AX = user segment
 0CC2  8E D8		      C 	mov	ds, ax ; Retro UNIX 8086 v1 Feature only !
 0CC4			      C namei_5: ; 3:
 0CC4  AC		      C 	lodsb   ; mov al, byte ptr [SI] ; inc si  (al = r4)
			      C 		; movb (r2)+,r4 / move a character from u.namep string into r4
 0CC5  0A C0		      C  	or 	al, al
 0CC7  74 11		      C 	jz 	short namei_6
			      C 		; beq 3f / if char is nul, then the last char in string
			      C 			; / has been moved
 0CC9  3C 2F		      C 	cmp	al, '/'
			      C 		; cmp r4,$'/ / is char a </>
 0CCB  74 0D		      C 	je 	short namei_6
			      C 		; beq 3f	
 0CCD  3B FA		      C 	cmp 	di, dx ; offset u_dirbuf + 10
			      C 		; cmp r3,$u.dirbuf+10. / have I checked
			      C 				     ; / all 8 bytes of file name
 0CCF  74 F3		      C 	je 	short namei_5
			      C 		; beq 3b
 0CD1  AE		      C 	scasb	
			      C 		; cmpb (r3)+,r4 / compare char in u.namep string to file name 
			      C 			      ; / char read from directory
 0CD2  74 F0		      C 	je 	short namei_5
			      C 		; beq 3b / branch if chars match
 0CD4  8C C8		      C 	mov	ax, cs ; Retro UNIX 8086 v1 Feature only !
 0CD6  8E D8		      C 	mov	ds, ax ; Retro UNIX 8086 v1 Feature only !
 0CD8  EB A6		      C         jmp     short namei_3 ; 2b
			      C 		; br 2b / file names do not match go to next directory entry
 0CDA			      C namei_6: ; 3:
			      C 	; 22/07/2013
 0CDA  8C C9		      C 	mov	cx, cs ; Retro UNIX 8086 v1 Feature only !
 0CDC  8E D9		      C 	mov	ds, cx ; Retro UNIX 8086 v1 Feature only !
			      C 	;
 0CDE  3B FA		      C 	cmp	di, dx
			      C 		; cmp r3,$u.dirbuf+10. / if equal all 8 bytes were matched
 0CE0  74 06		      C 	je	short namei_7
			      C 		; beq 3f
 0CE2  8A 25		      C 	mov 	ah, byte ptr [DI]
			      C 	;inc 	di 
 0CE4  22 E4		      C 	and 	ah, ah
			      C 		; tstb (r3)+ /
 0CE6  75 98		      C         jnz     short namei_3
			      C 		; bne 2b
 0CE8			      C namei_7: ; 3
 0CE8  89 36 27BA R	      C 	mov 	word ptr [u.namep], si
			      C 		; mov r2,u.namep / u.namep points to char 
			      C 			       ; / following a / or nul
			      C 	;mov 	bx, word ptr [u.dirbuf]
			      C 		; mov u.dirbuf,r1 / move i-node number in directory 
			      C 				; / entry to r1
			      C 	;;;;
			      C 	; 11/05/2022
			      C 	; 10/05/2022 - Retro UNIX (8086/386) feature only !
			      C 	; ! 'pwd' utility modification !
			      C 	; ((if directory entry name is a dotdot)))
			      C 	;; check if it is mounted device's root directory inode
			      C 	; and if so, replace it with parent dir inode number
			      C 	;  of mounting directory in [mntp].
			      C 
 0CEC  83 FB 29		      C 	cmp	bx, 41 ; root directory inode number
 0CEF  75 2A		      C 	jne	short namei_8
			      C 
 0CF1  3B 1E 26BE R	      C 	cmp	bx, word ptr [ii] ; for root dir, '.' & '..' is 41
 0CF5  75 24		      C 	jne	short namei_8 ; not root dir (of mounted dev)
			      C 
			      C 	;cmp	byte ptr [idev], bh ; 0
 0CF7  38 3E 26C2 R	      C 	cmp	byte ptr [cdev], bh ; 0
			      C 				; 0 = root fs, dev num in [rdev]
			      C 				; 1 = mounted, dev num in [mdev]
 0CFB  76 1E		      C 	jna	short namei_8
			      C 
			      C 	; dotdot (parent directory link) check
 0CFD  81 3E 27CA R 2E2E      C 	cmp	word ptr [u.dirbuf+2], '..'
 0D03  75 16		      C 	jne	short namei_8
 0D05  80 3E 27CC R 00	      C 	cmp	byte ptr [u.dirbuf+4], 0
 0D0A  75 0F		      C 	jne	short namei_8
			      C 	
			      C 	; (This may not be necessary because [idev] = 1
			      C 	; and [mnti] is expected as a sub dir inode number)
 0D0C  39 1E 26EC R	      C 	cmp	word ptr [mnti], bx ; 41
 0D10  76 09		      C 	jna	short namei_8
			      C 	; 11/05/2022
			      C 	; change inumber to parent dir inum of mount directory
 0D12  8B 1E 288E R	      C 	mov	bx, word ptr [mntp]
 0D16  C6 06 26C2 R 00	      C 	mov	byte ptr [cdev], 0 ; root fs
 0D1B			      C namei_8:
			      C 	;;;;
			      C 
 0D1B  22 C0		      C 	and 	al, al
			      C 		; tst r4 / if r4 = 0 the end of file name reached,
			      C 		      ;  / if r4 = </> then go to next directory
 0D1D  8B C3		      C 	mov 	ax, bx
			      C 	;jnz	namei_2 
			      C 	;	; bne 1b
			      C 	; 27/01/2022
			      C 	;jz	short @f ; retn
 0D1F  74 93		      C 	jz	short nig  ; retn
 0D21  E9 FF3C		      C 	jmp	namei_2
			      C 	
			      C 	; AX = i-number of the file
			      C ;;nig:
			      C 	;;pop	es ; Retro UNIX 8086 v1 Feature only !
			      C 	; 27/01/2022
			      C ;@@:
			      C ;	retn
			      C 		; tst (r0)+ / gives non-error return
			      C ;;nib:
			      C ;;	xor	ax, ax ; Retro UNIX 8086 v1 modification !
			      C 		       ; ax = 0 -> file not found 
			      C 	;;pop	es ; Retro UNIX 8086 v1 Feature only !
			      C ;;	stc	; 27/05/2013
			      C ;;	retn
			      C 		; rts r0
			      C 
 0D24			      C syschdir:
			      C 	; 03/02/2022
			      C 	; 27/01/2022
			      C 	; 19/06/2013
			      C 	; 'syschdir' makes the directory specified in its argument
			      C 	; the current working directory.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syschdir; name
			      C 	; Arguments:
			      C 	;	name - address of the path name of a directory
			      C 	;	       terminated by nul byte.	
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;	 The user/application program puts address of 
			      C 	;	 the path name in BX register as 'syschdir' 
			      C 	; 	 system call argument.
			      C 	; 	 (argument transfer method 1)
			      C 
			      C ; / makes the directory specified in the argument
			      C ; / the current directory
			      C 	;;mov	ax, 1 ; one/single argument, put argument in BX
			      C 	;;call	arg
			      C 	;mov 	bp, word ptr [u.sp_] ; points to user's BP register
			      C 	;add 	bp, 6 ; bx now points to BX on stack
			      C 	;mov 	bx, word ptr [BP]
 0D24  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
			      C 		;jsr r0,arg; u.namep / u.namep points to path name
 0D28  E8 FF02		      C 	call	namei
			      C 		; jsr r0,namei / find its i-number
			      C 	;jc	error
			      C 		; br error3
			      C 	; 27/01/2022
 0D2B  73 03		      C 	jnc	short @f
 0D2D			      C syschdir_err:
 0D2D  E9 F5C3		      C 	jmp	error
 0D30			      C @@:
			      C 	; 03/02/2022
 0D30  B2 02		      C 	mov	dl, 2  ; read access ; 03/02/2022 (BugFix)
 0D32  E8 04F3		      C 	call	access
			      C 		; jsr r0,access; 2 / get i-node into core
			      C 	; 27/01/2022
 0D35  F6 06 25EB R 40	      C 	test	byte ptr [i.flgs+1], 40h
			      C 	;test	word ptr [i.flgs], 4000h
			      C 		; bit $40000,i.flgs / is it a directory?
			      C 	;jz	error 
			      C 		; beq error3 / no error
			      C 	; 27/01/2022
 0D3A  74 F1		      C 	jz	short syschdir_err
			      C 
 0D3C  A3 27AA R	      C 	mov	word ptr [u.cdir], ax
			      C 		; mov r1,u.cdir / move i-number to users 
			      C 			      ; / current directory
 0D3F  A1 26C2 R	      C 	mov	ax, word ptr [cdev]
 0D42  A3 27DA R	      C 	mov	word ptr [u.cdrv], ax
			      C 		; mov cdev,u.cdev / move its device to users 
			      C 			        ; / current device
 0D45  E9 F5C8		      C 	jmp	sysret
			      C 		; br sysret3
			      C 	
 0D48			      C syschmod: ; < change mode of file >
			      C 	; 29/04/2022 (bugfix)
			      C 	; 27/01/2022
			      C 	; 07/07/2013
			      C 	; 20/06/2013
			      C 	; 'syschmod' changes mode of the file whose name is given as
			      C 	; null terminated string pointed to by 'name' has it's mode 
			      C 	; changed to 'mode'.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syschmod; name; mode
			      C 	; Arguments:
			      C 	;	name - address of the file name
			      C 	;	       terminated by null byte.
			      C 	;	mode - (new) mode/flags < attributes >
			      C 	;	
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'syschmod' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get syschmod system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, mode is in CX register
			      C 	;
			      C 	; Mode bits (Flags):
			      C 	;	bit 0 - write permission for non-owner (1)
			      C 	;	bit 1 - read permission for non-owner (2)
			      C 	;	bit 2 - write permission for owner (4)
			      C 	;	bit 3 - read permission for owner (8)
			      C 	;	bit 4 - executable flag (16) 	
			      C 	;	bit 5 - set user ID on execution flag (32) 
			      C 	;	bit 6,7,8,9,10,11 are not used (undefined)
			      C 	;	bit 12 - large file flag (4096)
			      C 	;	bit 13 - file has modified flag (always on) (8192)
			      C 	;	bit 14 - directory flag (16384)
			      C 	;	bit 15 - 'i-node is allocated' flag (32768)
			      C 
			      C ; / name; mode
 0D48  E8 000F		      C 	call	isown
			      C 		;jsr r0,isown / get the i-node and check user status
			      C 	; 27/01/2022
 0D4B  F6 06 25EB R 40	      C 	test	byte ptr [i.flgs+1], 40h
			      C 	;test	word ptr [i.flgs], 4000h
			      C 		; bit $40000,i.flgs / directory?
 0D50  74 02		      C 	jz	short @f
			      C 		; beq 2f / no
			      C 	; AL = (new) mode
 0D52  24 CF		      C 	and	al, 0CFh ; 11001111b (clears bit 4 & 5)
			      C 		; bic $60,r2 / su & ex / yes, clear set user id and 
			      C 			   ; / executable modes
 0D54			      C @@: ; 2:
 0D54  A2 25EA R	      C 	mov	byte ptr [i.flgs], al	
			      C 		; movb r2,i.flgs / move remaining mode to i.flgs
			      C 	;jmp	short @f
			      C 	;	; br 1f  ; (jmp sysret4)
			      C 	; 29/04/2022
 0D57  E9 F5B6		      C 	jmp	sysret
 0D5A			      C isown:
			      C 	; 27/01/2022
			      C 	; 07/07/2013
			      C 	; 27/05/2013
			      C 	; 04/05/2013
			      C 	; 'isown' is given a file name (the 1st argument).
			      C 	;  It find the i-number of that file via 'namei' 
			      C 	;  then gets the i-node into core via 'iget'.
			      C 	;  It then tests to see if the user is super user. 
			      C 	;  If not, it cheks to see if the user is owner of 
			      C 	;  the file. If he is not an error occurs.
			      C 	;  If user is the owner 'setimod' is called to indicate
			      C 	;  the inode has been modificed and the 2nd argument of
			      C 	;  the call is put in r2.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    arguments of syschmod and syschown calls
			      C 	; OUTPUTS ->
			      C 	;    u.uid - id of user
			      C 	;    imod - set to a 1
			      C 	;    r2 - contains second argument of the system call				 	
			      C 	;
			      C 	;   ((AX=R2) output as 2nd argument))
			      C 	;
			      C         ;    ((Modified registers: AX, DX, BX, CX, SI, DI, BP))  
			      C 	;
			      C 	;;call	arg2 
			      C 	;;	; jsr r0,arg2 / u.namep points to file name
			      C 	;; ! 2nd argument on top of stack !
			      C 	;; 07/07/2013
 0D5A  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx ;; 1st argument
 0D5E  51		      C 	push 	cx ;; 2nd argument
			      C 	;;
 0D5F  E8 FECB		      C 	call	namei
			      C 		; jsr r0,namei / get its i-number
			      C        
			      C 	; Retro UNIX 8086 v1 modification !
			      C        	; ax = 0 -> file not found 
			      C 	;;and	ax, ax
			      C 	;;jz	error
			      C 	;jc	error ; 27/05/2013
			      C 		; br error3
			      C 	; 27/01/2022
 0D62  73 03		      C 	jnc	short @f
 0D64			      C isown_err:
 0D64  E9 F58C		      C 	jmp	error
 0D67			      C @@:
 0D67  E8 041C		      C 	call	iget
			      C 		; jsr r0,iget / get i-node into core
 0D6A  A0 27DC R	      C 	mov	al, byte ptr [u.uid_] ; 02/08/2013
 0D6D  0A C0		      C 	or	al, al
			      C 		; tstb u.uid / super user?
 0D6F  74 06		      C 	jz	short @f
			      C 		; beq 1f / yes, branch
 0D71  3A 06 25ED R	      C 	cmp	al, byte ptr [i.uid]
			      C 		; cmpb i.uid,u.uid / no, is this the owner of
			      C 				 ; / the file
			      C 	;jne	error
			      C 		; beq 1f / yes
			      C 		; jmp error3 / no, error
			      C 	; 27/01/2022
 0D75  75 ED		      C 	jne	short isown_err
 0D77			      C @@: ; 1:
 0D77  E8 04D1		      C 	call	setimod
			      C 		; jsr r0,setimod / indicates 
			      C 		;	       ; / i-node has been modified
 0D7A  58		      C 	pop	ax ; 2nd argument
			      C 		; mov (sp)+,r2 / mode is put in r2 
			      C 		       ; / (u.off put on stack with 2nd arg)
 0D7B  C3		      C 	retn
			      C 		; rts r0
			      C 
 0D7C			      C syschown: ; < change owner of file >
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 07/07/2013
			      C 	; 20/06/2013
			      C 	; 'syschown' changes the owner of the file whose name is given
			      C 	; as null terminated string pointed to by 'name' has it's owner
			      C 	; changed to 'owner'
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syschown; name; owner
			      C 	; Arguments:
			      C 	;	name - address of the file name
			      C 	;	       terminated by null byte.
			      C 	;	owner - (new) owner (number/ID)
			      C 	;	
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'syschown' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get syschown system call arguments from the user;
			      C 	;	* 1st argument, name is pointed to by BX register
			      C 	;	* 2nd argument, owner number is in CX register
			      C 	;
			      C ; / name; owner
 0D7C  E8 FFDB		      C 	call	isown
			      C 		; jsr r0,isown / get the i-node and check user status
 0D7F  80 3E 27DC R 00	      C 	cmp 	byte ptr [u.uid_], 0 ; 02/08/2013 
			      C 		; tstb u.uid / super user
 0D84  74 0A		      C 	jz	short @f
			      C 		; beq 2f / yes, 2f
 0D86  F6 06 25EA R 20	      C 	test	byte ptr [i.flgs], 20h ; 32
			      C 		; bit $40,i.flgs / no, set userid on execution?
			      C 	;jnz	error
			      C 		; bne 3f / yes error, could create Trojan Horses
			      C 	; 27/01/2022
 0D8B  74 03		      C 	jz	short @f
 0D8D  E9 F563		      C 	jmp	error
 0D90			      C @@: ; 2:
			      C 	; AL = owner (number/ID)
 0D90  A2 27DC R	      C 	mov	byte ptr [u.uid_], al ; 02/08/2013
			      C 		;  movb	r2,i.uid / no, put the new owners id 
			      C 			       ; / in the i-node
 0D93  E9 F57A		      C 	jmp	sysret
			      C 	; 1: 
			      C 		; jmp sysret4
			      C 	; 3:
			      C 		; jmp	error
			      C 
			      C ;;arg:    ; < get system call arguments >
			      C 	; 22/05/2013 'method 4' has been modified (corrected)
			      C 	; 04/05/2013
			      C 	; 'arg' extracts an argument for a routine whose call is 
			      C 	; of form:
			      C 	;	sys 'routine' ; arg1
			      C 	;		or
			      C 	;	sys 'routine' ; arg1 ; arg2
			      C 	;		or
			      C 	;	sys 'routine' ; arg1;...;arg10 (sys exec) 
			      C 	;	
			      C 	; RETRO UNIX 8086 v1 Modification !
			      C 	;	Retro Unix 8086 v1 system call argument 
			      C 	;	transfer methods:		
			      C 	;	1) Single argument in BX register
			      C 	;	   ('arg' routine is called with AX=1) 
			      C 	;	2) Two arguments, 
			      C 	;		1st argument in BX register
			      C 	;		2nd argument in CX register
			      C 	;	   ('arg' routine is called with AX=2) 	 	
			      C 	;	3) Three arguments
			      C 	;		3rd argument in DX register
			      C 	;	   ('arg' routine is called with AX=3) 
			      C 	;	4) Argument list address in BP register
			      C 	;	   ('arg' routine is called with AX=0) 
			      C 	; 'arg' routine will return arguments in same registers
			      C 	;  except method 4 will return current argument
			      C 	;  which is pointed by BP register and 'arg' will
			      C 	;  increase value of (user's) BP register (on stack)
			      C 	;  in order to point next argument. AX register will
			      C 	;  return address of current argument.						 			
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.sp+18 - contains a pointer to one of arg1..argn
			      C 	;	This pointers's value is actually the value of
			      C 	;	update pc at the the trap to sysent (unkni) is
			      C 	;	made to process the sys instruction
			      C 	;    r0 - contains the return address for the routine
			      C 	;	that called arg. The data in the word pointer 
			      C 	;	to by the return address is used as address
			      C 	;	in which the extracted argument is stored   		
			      C 	;    	
			      C 	; OUTPUTS ->
			      C 	;    'address' - contains the extracted argument 
			      C 	;    u.sp+18 - is incremented by 2 
			      C 	;    r1 - contains the extracted argument
			      C 	;    r0 - points to the next instruction to be
			      C 	;	 executed in the calling routine.
			      C 	;
			      C         ;    ((Modified registers: AX, DX, CX, BX)) 
			      C 
			      C ; Retro UNIX 8086 v1 modification !
			      C ; [ sysunlink, sysfstat, syschdir, sysbreak, sysseek (seektell),
			      C ;  sysintr, sysquit, rw1 (sysread, syswrite), sysemt, sysilgins
			      C ; sysmdate, gtty (sysgtty) etc. call arg.]
			      C ;
			      C ; Note: If all of system calls which call 'arg' routine will have 
			      C ; only 1 argument, this 'arg' routine may be simplified 
			      C ; and system calls with 2 arguments may be changed to use 'arg1'
			      C ; instead of 'arg' (04/05/2013). 	
			      C 
			      C ;;	mov 	bx, word ptr [u.sp_] ; points to user's BP register
			      C ;;	mov	cx, ax	
			      C ;;	or 	cx, cx
			      C ;;	jnz	short @f
			      C ;arg_bp: ; method 4
			      C ;;	mov	ax, word ptr [BX] ; value of BP register on stack
			      C 	; (sAX = uBP)
			      C ;;	mov	dx, ax
			      C 	; AX = 1st argument or current argument (method 4)
			      C ;;	inc	dx
			      C ;;	inc	dx
			      C ;;	mov	word ptr [BX], dx ; BP will point to next argument
			      C 	; (uBP = uBP+2)
			      C ;;	retn
			      C ; method 1, 2, 3
			      C ;;@@:
			      C ;;	add	bx, 6 ; bx now points to BX on stack
			      C ;,@@:		
			      C ;;	mov	dx, word ptr [BX]
			      C ;;	push	dx ; 1st or 2nd or 3rd argument (depends on CX) 
			      C ;;	dec	cx
			      C ;;	jz	short @f
			      C ;;	inc	bx
			      C ;;	inc	bx
			      C ;;	jmp	short @b	
			      C ;;@@:
			      C ;;	dec	ax
			      C ;;	jz	short @f
			      C ;;	pop	cx ; 2nd or 3rd argument (depends on value in AX) 
			      C ;;	dec	ax
			      C ;;	jz	short @f
			      C ;;	mov	dx, cx ; 3rd argument
			      C ;;	pop	cx ; 2nd argument	
			      C ;;@@:
			      C ;;	pop	bx ; 1st argument
			      C ;;	retn
			      C 
			      C ; UNIX v1 original 'arg' routine here:
			      C 		; mov u.sp,r1
			      C 		; mov *18.(r1),*(r0)+ / put argument of system call
			      C 				; / into argument of arg2
			      C 		; add $2,18.(r1) / point pc on stack 
			      C 			      ; / to next system argument
			      C 		; rts r0
			      C 
			      C ;;arg2:   ; < get system calls arguments - with file name pointer>
			      C 	; 22/05/2013 arg1 modified (corrected)
			      C 	; 04/05/2013
			      C 	; 'arg2' takes first argument in system call
			      C 	;  (pointer to name of the file) and puts it in location
			      C 	;  u.namep; takes second argument and puts it in u.off
			      C 	;  and on top of the stack
			      C 	;	
			      C 	; RETRO UNIX 8086 v1 Modification !
			      C 	;	Retro Unix 8086 v1 system call argument 
			      C 	;	transfer methods:		
			      C 	;	1) Single argument in BX register
			      C 	;	   ('arg' routine is called with AX=1) 
			      C 	;	2) Two arguments, 
			      C 	;		1st argument in BX register
			      C 	;		2nd argument in CX register
			      C 	;	   ('arg' routine is called with AX=2) 	 	
			      C 	;	3) Three arguments
			      C 	;		3rd argument in DX register
			      C 	;	   ('arg' routine is called with AX=3) 
			      C 	;	4) Argument list address in BP register
			      C 	;	   ('arg' routine is called with AX=0)
			      C 	; 'arg2' routine uses method 2 when calling 'arg' routine
			      C 	;  then puts 1st argument (BX) in u.namep and pushes
			      C 	;  2nd argument (CX) on stack.
			      C 	;  (Retro UNIX 8086 v1 does not put 2nd argument in u.off)
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.sp, r0
			      C 	;    	
			      C 	; OUTPUTS ->
			      C 	;    u.namep
			      C 	;    u.off 
			      C 	;    u.off pushed on stack
			      C 	;    r1
			      C 	;
			      C  	;    ((Modified registers: AX, DX, CX, BX)) 
			      C 	;
			      C ; arg2 (1) -- 04/05/2013 (1)
			      C ;	mov	ax, 2 ; two arguments, method 2
			      C ;	call	arg
			      C ;	; BX = 1st argument
			      C ;	; CX = 2nd argument
			      C 
			      C ; arg2 (modified for arg1 call) -- 04/05/2013 (2)
			      C 
			      C ; Retro UNIX 8086 v1 modification !
			      C ; Direct argument handling instead of using 'arg' call.
			      C ; [ sysexec, sysmount, sysopen, syslink, sysstat,
			      C ;  isown (syschmod, syschown),sysopen, syscreat, sysmkdir, sysmount
			      C ; call arg2 ]	
			      C 
			      C ;;	call	arg1 ; 04/05/2013
			      C ;;	mov	word ptr [u.namep], ax ; 1st argument
			      C ;;	pop	dx ; return address
			      C ;;	push	cx ; 2nd argument
			      C ;;	push	dx
			      C 	; warning ! 
			      C 	; ! Caller must pop 2nd argument on stack !  	
			      C ;;	retn
			      C 
			      C ;;arg1: ; Retro UNIX 8086 v1 feature only !
			      C 	; 22/05/2013 modified (corrected)
			      C ;;	mov 	bx, word ptr [u.sp_] ; points to user's BP register
			      C ;;	add	bx, 6
			      C ;,	mov	ax, [BX] ; points to user's BX register
			      C 	;(sAX = uBX)
			      C ;;	inc	bx
			      C ;;	inc	bx
			      C ;,	mov	cx, [BX] ; points to user's CX register
			      C 	;(sCX = uCX)
			      C ;	retn
			      C 
			      C ;; arg2 (2) -- 04/05/2013 (1)	
			      C ;	mov	word ptr [u.namep], bx ; file name pointer
			      C ;	;mov	word ptr [u.off], cx ; 2nd argument
			      C ;	pop	dx ; return address
			      C ;	push	cx
			      C ;	push	dx
			      C ;	; warning ! 
			      C ;	; ! Caller must pop 2nd argument on stack !  
			      C ;	retn 
			      C 	
			      C ; UNIX v1 original 'arg2' routine here:		
			      C 		; jsr	r0,arg; u.namep / u.namep contains value of
			      C 				; / first arg in sys call
			      C 		; jsr r0,arg; u.off / u.off contains value of 
			      C 				; / second arg in sys call
			      C 		; mov r0,r1 / r0 points to calling routine
			      C 		; mov (sp),r0 / put operation code back in r0
			      C 		; mov u.off,(sp) / put pointer to second argument 
			      C 				; / on stack
			      C 		; jmp (r1) / return to calling routine
			      C 
 0D96			      C systime:
			      C 	; 20/06/2013
			      C 	; 'systime' gets the time of the year.
			      C 	; The present time is put on the stack.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	systime
			      C 	; Arguments: -
			      C 	;	
			      C 	; Inputs: -
			      C 	; Outputs: sp+2, sp+4 - present time
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'systime' system call will return to the user
			      C 	;	with unix time (epoch) in DX:AX register pair
			      C 	;
			      C 	; 	!! Major modification on original Unix v1 'systime' 
			      C 	;	system call for PC compatibility !!		 	
			      C ; / get time of year
 0D96  E8 1675		      C 	call 	epoch
 0D99  A3 27A8 R	      C 	mov 	word ptr [u.r0], ax
 0D9C  8B 2E 27A4 R	      C 	mov	bp, word ptr [u.sp_]
 0DA0  83 C5 0A		      C 	add	bp, 10 ; points to the user's DX register
 0DA3  89 56 00		      C 	mov	word ptr [BP], dx
			      C 		; mov s.time,4(sp)
			      C 		; mov s.time+2,2(sp) / put the present time 
			      C 				   ; / on the stack
			      C 		; br sysret4
 0DA6  E9 F567		      C 	jmp	sysret 
			      C 
 0DA9			      C sysstime:
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 20/06/2013
			      C 	; 'sysstime' sets the time. Only super user can use this call.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysstime
			      C 	; Arguments: -
			      C 	;	
			      C 	; Inputs: sp+2, sp+4 - time system is to be set to.
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;	the user calls 'sysstime' with unix (epoch) time
			      C 	;	(to be set) is in CX:BX register pair as two arguments.
			      C 	; 
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysstime system call arguments from the user;
			      C 	;	* 1st argument, lowword of unix time is in BX register
			      C 	;	* 2nd argument, highword of unix time is in CX register		 	
			      C 	;
			      C 	; 	!! Major modification on original Unix v1 'sysstime' 
			      C 	;	system call for PC compatibility !!	
			      C ; / set time
 0DA9  80 3E 27DC R 00	      C 	cmp	byte ptr [u.uid_], 0 ; 02/08/2013
			      C 		; tstb u.uid / is user the super user
			      C 	;ja	error
			      C 		; bne error4 / no, error
 0DAE  76 03		      C 	jna	short @f
 0DB0  E9 F540		      C 	jmp	error
 0DB3			      C @@:
			      C 	; CX:BX = unix (epoch) time (from user)
 0DB3  8B D1		      C 	mov 	dx, cx
 0DB5  8B C3		      C 	mov	ax, bx
			      C 	; DX:AX = unix (epoch) time (to subroutine)
 0DB7  E8 1757		      C 	call 	set_date_time
			      C 	;call convert_from_epoch
			      C 	;call set_date_time
			      C 		; mov 4(sp),s.time
			      C 		; mov 2(sp),s.time+2 / set the system time
 0DBA  E9 F553		      C 	jmp	sysret
			      C 		; br sysret4
			      C 
 0DBD			      C sysbreak:
			      C 	; 24/03/2014
			      C 	; 19/11/2013
			      C 	; 20/06/2013
			      C 	; 'sysbreak' sets the programs break points. 
			      C 	; It checks the current break point (u.break) to see if it is
			      C 	; between "core" and the stack (sp). If it is, it is made an
			      C 	; even address (if it was odd) and the area between u.break
			      C 	; and the stack is cleared. The new breakpoint is then put
			      C 	;in u.break and control is passed to 'sysret'.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysbreak; addr
			      C 	; Arguments: -
			      C 	;	
			      C 	; Inputs: u.break - current breakpoint
			      C 	; Outputs: u.break - new breakpoint 
			      C 	;	area between old u.break and the stack (sp) is cleared.
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;	The user/application program puts breakpoint address
			      C 	;       in BX register as 'sysbreak' system call argument.
			      C 	; 	(argument transfer method 1)
			      C 	;
			      C 	;  NOTE: Beginning of core is 0 in Retro UNIX 8086 v1 !
			      C 	; 	((!'sysbreak' is not needed in Retro UNIX 8086 v1!))
			      C 	;  NOTE:
			      C 	; 	'sysbreak' clears extended part (beyond of previous
			      C 	;	'u.break' address) of user's memory for original unix's
			      C 	;	'bss' compatibility with Retro UNIX 8086 v1 (19/11/2013)
			      C 
			      C 	;cmp	word ptr [u.break], core
			      C 		; mov u.break,r1 / move users break point to r1
			      C 		; cmp r1,$core / is it the same or lower than core?
			      C 	;ja	short sysbreak_3
			      C 		; blos 1f / yes, 1f
 0DBD  8B 3E 27E4 R	      C 	mov	di, word ptr [u.break]
 0DC1  3B 3E 27A6 R	      C 	cmp	di, word ptr [u.usp]
			      C 		; cmp r1,sp / is it the same or higher 
			      C 			  ; / than the stack?
 0DC5  73 1B		      C         jnb     short sysbreak_3
			      C 		; bhis 1f / yes, 1f
 0DC7  A1 27E0 R	      C 	mov	ax, word ptr [u.segmnt]
 0DCA  8E C0		      C 	mov	es, ax
 0DCC  33 C0		      C 	xor	ax, ax
 0DCE  F7 C7 0001	      C 	test	di, 1
			      C 		; bit $1,r1 / is it an odd address
 0DD2  74 07		      C 	jz	short sysbreak_1
			      C 		; beq 2f / no, its even
 0DD4  AA		      C 	stosb
			      C 		; clrb (r1)+ / yes, make it even
 0DD5			      C sysbreak_0:  ; 2: / clear area between the break point and the stack
 0DD5  3B 3E 27A6 R	      C 	cmp	di, word ptr [u.usp] ; 24/03/2014
			      C 		; cmp r1,sp / is it higher or same than the stack
 0DD9  73 03		      C 	jnb	short sysbreak_2
			      C 		; bhis 1f / yes, quit
 0DDB			      C sysbreak_1:
 0DDB  AB		      C 	stosw
			      C 		; clr (r1)+ / clear word
 0DDC  EB F7		      C 	jmp 	short sysbreak_0
			      C 		; br 2b / go back
 0DDE			      C sysbreak_2: ; 1:
 0DDE  8C D8		      C 	mov	ax, ds
 0DE0  8E C0		      C 	mov	es, ax
 0DE2			      C sysbreak_3:
 0DE2  89 1E 27E4 R	      C 	mov	word ptr [u.break], bx
			      C 		; jsr r0,arg; u.break / put the "address" 
			      C 			; / in u.break (set new break point)
 0DE6  E9 F527		      C 	jmp	sysret
			      C 		; br sysret4 / br sysret
			      C 
 0DE9			      C maknod: 
			      C 	; 26/02/2022
			      C 	; 03/02/2022
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 31/07/2013
			      C 	; 17/07/2013
			      C 	; 02/05/2013
			      C 	; 'maknod' creates an i-node and makes a directory entry
			      C 	; for this i-node in the current directory.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - contains mode
			      C 	;    ii - current directory's i-number	
			      C 	;    	
			      C 	; OUTPUTS ->
			      C 	;    u.dirbuf - contains i-number of free i-node 
			      C 	;    i.flgs - flags in new i-node 
			      C 	;    i.uid - filled with u.uid
			      C 	;    i.nlks - 1 is put in the number of links
			      C 	;    i.ctim - creation time				
			      C 	;    i.ctim+2 - modification time
			      C 	;    imod - set via call to setimod
			      C 	;	
			      C 	; ((AX = R1)) input
			      C 	;
			      C 	;    (Retro UNIX Prototype : 
			      C 	;		30/10/2012 - 01/03/2013, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: AX, DX, BX, CX, SI, DI, BP))  
			      C 
			      C 	; / r1 contains the mode
 0DE9  80 CC 80		      C 	or 	ah, 80h ; 10000000b
			      C 		; bis $100000,r1 / allocate flag set
 0DEC  50		      C 	push	ax
			      C 		; mov r1,-(sp) / put mode on stack
			      C 	; 31/07/2013
 0DED  A1 26BE R	      C 	mov	ax, word ptr [ii] ; move current i-number to AX/r1
			      C 		; mov ii,r1 / move current i-number to r1
 0DF0  B2 01		      C 	mov	dl, 1 ; owner flag mask
 0DF2  E8 0433		      C 	call	access	
			      C 		; jsr r0,access; 1 / get its i-node into core
 0DF5  50		      C 	push	ax
			      C 		; mov r1,-(sp) / put i-number on stack
 0DF6  B8 0028		      C 	mov	ax, 40
			      C 		; mov $40.,r1 / r1 = 40
 0DF9			      C @@: ; 1: / scan for a free i-node (next 4 instructions)
 0DF9  40		      C 	inc	ax ; (next) inode number ; 26/02/2022
			      C 		; inc r1 / r1 = r1 + 1
 0DFA  E8 04BF		      C 	call	imap
			      C 		; jsr r0,imap / get byte address and bit position in 
			      C 			    ; /	inode map in r2 & m
			      C 
			      C 	; 26/02/2022 (Retro UNIX 8081 v1, 2022 modification)
			      C 	; -'imap' modification-
			      C 	; (cpu will not return here if the inode number overs 
			      C 	;  inode count, it will jump to error proc.) 
			      C 
			      C           ; DX (MQ) has a 1 in the calculated bit position
			      C           ; BX (R2) has byte address of the byte with allocation bit
 0DFD  84 17		      C 	test	byte ptr [BX], dl
			      C 		; bitb mq,(r2) / is the i-node active
 0DFF  75 F8		      C 	jnz	short @b
			      C 		; bne 1b / yes, try the next one
 0E01  08 17		      C 	or	byte ptr [BX], dl
			      C 		; bisb mq,(r2) / no, make it active 
			      C 			     ; / (put a 1 in the bit map)
 0E03  E8 0380		      C 	call	iget
			      C 		; jsr r0,iget / get i-node into core
			      C 	; 03/02/2022
 0E06  F6 06 25EB R 80	      C 	test	byte ptr [i.flgs+1], 80h
			      C 	;test	word ptr [i.flgs], 8000h 
			      C 		; tst i.flgs / is i-node already allocated
 0E0B  75 EC		      C 	jnz	short @b	
			      C 		; blt 1b / yes, look for another one
 0E0D  A3 27C8 R	      C 	mov	word ptr [u.dirbuf], ax
			      C 		; mov r1,u.dirbuf / no, put i-number in u.dirbuf
 0E10  58		      C 	pop	ax
			      C 		; mov (sp)+,r1 / get current i-number back
 0E11  E8 0372		      C 	call	iget
			      C 		; jsr r0,iget / get i-node in core
 0E14  E8 FBBE		      C 	call	mkdir
			      C 		; jsr r0,mkdir / make a directory entry 
			      C 			     ; / in current directory
 0E17  A1 27C8 R	      C 	mov	ax, word ptr [u.dirbuf]
			      C 		; mov u.dirbuf,r1 / r1 = new inode number
 0E1A  E8 0369		      C 	call	iget
			      C 		; jsr r0,iget / get it into core
			      C 		; jsr r0,copyz; inode; inode+32. / 0 it out
 0E1D  B9 0010		      C 	mov	cx, 16
 0E20  33 C0		      C 	xor	ax, ax ; 0
			      C 	;mov	di, offset inode 
 0E22  BF 25EA R	      C 	mov	di, offset i ; 17/07/2013
 0E25  F3/ AB		      C 	rep	stosw
			      C 	;
 0E27  8F 06 25EA R	      C 	pop	word ptr [i.flgs]
			      C 		; mov (sp)+,i.flgs / fill flags
 0E2B  8A 0E 27DC R	      C 	mov 	cl, byte ptr [u.uid_] ; 02/08/2013
 0E2F  88 0E 25ED R	      C 	mov 	byte ptr [i.uid], cl
			      C 		; movb u.uid,i.uid / user id	
 0E33  C6 06 25EC R 01	      C 	mov     byte ptr [i.nlks], 1
			      C 		; movb $1,i.nlks / 1 link
			      C 	
			      C 	;call	epoch	; Retro UNIX 8086 v1 modification !
			      C 	
			      C 	;mov	ax, word ptr [s.time]
			      C 	;mov	dx, word ptr [s.time]+2
			      C 	;mov 	word ptr [i.ctim], ax
			      C 	;mov 	word ptr [i.ctim]+2, dx
			      C 	 	; mov s.time,i.ctim / time created
			      C 	 	; mov s.time+2,i.ctim+2 / time modified
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; i.ctime=0, i.ctime+2=0 and
			      C         ; 'setimod' will set ctime of file via 'epoch'
			      C 	; 27/01/2022
			      C 	;call setimod
			      C 	;	; jsr r0,setimod / set modified flag
			      C 	;retn
			      C 		; rts r0 / return
 0E38  E9 0410		      C 	jmp	setimod
			      C 
 0E3B			      C sysseek: ; / moves read write pointer in an fsp entry
			      C 	; 05/08/2013
			      C 	; 07/07/2013
			      C 	; 'sysseek' changes the r/w pointer of (3rd word of in an
			      C 	; fsp entry) of an open file whose file descriptor is in u.r0.
			      C 	; The file descriptor refers to a file open for reading or
			      C 	; writing. The read (or write) pointer is set as follows:
			      C 	;	* if 'ptrname' is 0, the pointer is set to offset.
			      C 	;	* if 'ptrname' is 1, the pointer is set to its
			      C 	;	  current location plus offset.
			      C 	;	* if 'ptrname' is 2, the pointer is set to the
			      C 	;	  size of file plus offset.
			      C 	; The error bit (e-bit) is set for an undefined descriptor.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysseek; offset; ptrname
			      C 	; Arguments:
			      C 	;	offset - number of bytes desired to move 
			      C 	;		 the r/w pointer
			      C 	;	ptrname - a switch indicated above
			      C 	;
			      C 	; Inputs: r0 - file descriptor 
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysseek' system call has three arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 3 is used
			      C 	;	to get sysseek system call arguments from the user;
			      C 	;	* 1st argument, file descriptor is in BX (BL) register
			      C 	;	* 2nd argument, offset is in CX register
			      C 	;	* 3rd argument, ptrname/switch is in DX (DL) register	
			      C 	;	
			      C 
 0E3B  E8 0017		      C 	call	seektell
			      C 		; jsr r0,seektell / get proper value in u.count
			      C 	; AX = u.count
			      C 	; BX = *u.fofp
			      C 		; add u.base,u.count / add u.base to it
 0E3E  03 06 27BE R	      C 	add	ax, word ptr [u.base] ; add offset (u.base) to base
 0E42  89 07		      C 	mov	word ptr [BX], ax
			      C 		; mov u.count,*u.fofp / put result into r/w pointer
 0E44  E9 F4C9		      C 	jmp	sysret
			      C 		; br sysret4
			      C 
 0E47			      C systell: ; / get the r/w pointer
			      C 	; 05/08/2013
			      C 	; 07/07/2013
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	; ! 'systell' does not work in original UNIX v1,
			      C 	; 	    it returns with error !
			      C 	; Inputs: r0 - file descriptor 
			      C 	; Outputs: r0 - file r/w pointer
			      C 
			      C 	;xor	cx, cx ; 0
 0E47  BA 0001		      C 	mov	dx, 1 ; 05/08/2013
			      C 	;call 	seektell
 0E4A  E8 000C		      C 	call 	seektell0 ; 05/08/2013
			      C 	;mov	bx, word ptr [u.fofp]
 0E4D  8B 07		      C 	mov	ax, word ptr [BX]
 0E4F  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
 0E52  E9 F4BB		      C 	jmp	sysret
			      C 
			      C ; Original unix v1 'systell' system call:
			      C 		; jsr r0,seektell
			      C 		; br error4
			      C 
 0E55			      C seektell:
			      C 	; 27/01/2022
			      C 	; 05/08/2013 (return AX as base for offset)
			      C 	; 07/07/2013
			      C 	; 'seektell' puts the arguments from sysseek and systell
			      C 	; call in u.base and u.count. It then gets the i-number of
			      C 	; the file from the file descriptor in u.r0 and by calling
			      C 	; getf. The i-node is brought into core and then u.count
			      C 	; is checked to see it is a 0, 1, or 2.
			      C 	; If it is 0 - u.count stays the same
			      C 	;          1 - u.count = offset (u.fofp)
			      C 	;	   2 - u.count = i.size (size of file)
			      C 	; 	 		
			      C 	; !! Retro UNIX 8086 v1 modification:
			      C 	;	Argument 1, file descriptor is in BX;
			      C 	;	Argument 2, offset is in CX;
			      C 	;	Argument 3, ptrname/switch is in DX register.	
			      C 	;
			      C 	; mov 	ax, 3 ; Argument transfer method 3 (three arguments)	
			      C 	; call 	arg
			      C 	;
			      C 	; ((Return -> ax = base for offset (position= base+offset))
			      C 	;
 0E55  89 0E 27BE R	      C 	mov 	word ptr [u.base], cx ; offset
			      C 		; jsr r0,arg; u.base / puts offset in u.base
 0E59			      C seektell0:
 0E59  89 16 27C0 R	      C 	mov 	word ptr [u.count], dx
			      C 		; jsr r0,arg; u.count / put ptr name in u.count
			      C 	; mov	ax, bx
			      C 		; mov *u.r0,r1 / file descriptor in r1 
			      C 			     ; / (index in u.fp list)
			      C 	; call	getf
			      C 		; jsr r0,getf / u.fofp points to 3rd word in fsp entry
			      C 	; BX = file descriptor (file number)
 0E5D  E8 FDA0		      C 	call	getf1
 0E60  0B C0		      C 	or	ax, ax ; i-number of the file
			      C 		; mov r1,-(sp) / r1 has i-number of file, 
			      C 		             ; / put it on the stack
			      C 	;jz	error
			      C 		; beq error4 / if i-number is 0, not active so error
			      C 	; 27/01/2022
 0E62  75 03		      C 	jnz	short @f
 0E64  E9 F48C		      C 	jmp	error
 0E67			      C @@:
			      C 	;push	ax
 0E67  80 FC 80		      C 	cmp	ah, 80h
 0E6A  72 02		      C 	jb	short @f
			      C 		; bgt .+4 / if its positive jump
 0E6C  F7 D8		      C 	neg	ax
			      C 		; neg r1 / if not make it positive
 0E6E			      C @@:
 0E6E  E8 0315		      C 	call	iget
			      C 		; jsr r0,iget / get its i-node into core
 0E71  8B 1E 27B6 R	      C 	mov	bx, word ptr [u.fofp] ; 05/08/2013
 0E75  80 3E 27C0 R 01	      C 	cmp	byte ptr [u.count], 1
			      C 		; cmp u.count,$1 / is ptr name =1
 0E7A  77 05		      C 	ja	short @f
			      C 		; blt 2f / no its zero
 0E7C  74 07		      C 	je	short seektell_1
			      C 		; beq 1f / yes its 1
 0E7E  33 C0		      C 	xor	ax, ax
			      C 	;jmp	short seektell_2
 0E80  C3		      C 	retn
 0E81			      C @@:
 0E81  A1 25EE R	      C         mov     ax, word ptr [i.size_]
			      C                 ; mov i.size,u.count /  put number of bytes 
			      C                                    ; / in file in u.count
			      C 	;jmp	short seektell_2
			      C 		; br 2f
 0E84  C3		      C 	retn
 0E85			      C seektell_1: ; 1: / ptrname =1
			      C 	;mov	bx, word ptr [u.fofp]
 0E85  8B 07		      C 	mov	ax, word ptr [BX]
			      C 		; mov *u.fofp,u.count / put offset in u.count
			      C ;seektell_2: ; 2: / ptrname =0
			      C 	;mov	word ptr [u.count], ax
			      C 	;pop	ax 
			      C 		; mov (sp)+,r1 / i-number on stack  r1
 0E87  C3		      C 	retn
			      C 		; rts r0
			      C 
 0E88			      C sysintr: ; / set interrupt handling
			      C 	; 07/07/2013
			      C 	; 'sysintr' sets the interrupt handling value. It puts
			      C 	; argument of its call in u.intr then branches into 'sysquit'
			      C 	; routine. u.tty is checked to see if a control tty exists.
			      C 	; If one does the interrupt character in the tty buffer is
			      C 	; cleared and 'sysret'is called. If one does not exists
			      C 	; 'sysret' is just called.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysintr; arg
			      C 	; Argument:
			      C 	;	arg - if 0, interrupts (ASCII DELETE) are ignored.
			      C 	;	    - if 1, interrupts cause their normal result
			      C 	;		 i.e force an exit.
			      C 	;	    - if arg is a location within the program,
			      C 	;		control is passed to that location when
			      C 	;		an interrupt occurs.	
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysintr' system call sets u.intr to value of BX
			      C 	;	then branches into sysquit.
			      C 	;
 0E88  89 1E 27D4 R	      C 	mov	word ptr [u.intr], bx
			      C 	;jmp	short @f
			      C 		; jsr r0,arg; u.intr / put the argument in u.intr
			      C 		; br 1f / go into quit routine
 0E8C  E9 F481		      C 	jmp	sysret
			      C 
 0E8F			      C sysquit:
			      C 	; 07/07/2013
			      C 	; 'sysquit' turns off the quit signal. It puts the argument of
			      C 	; the call in u.quit. u.tty is checked to see if a control tty 
			      C 	; exists. If one does the interrupt character in the tty buffer
			      C 	; is cleared and 'sysret'is called. If one does not exists
			      C 	; 'sysret' is just called.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysquit; arg
			      C 	; Argument:
			      C 	;	arg - if 0, this call disables quit signals from the
			      C 	;		typewriter (ASCII FS)
			      C 	;	    - if 1, quits are re-enabled and cause execution to
			      C 	;		cease and a core image to be produced.
			      C 	;		 i.e force an exit.
			      C 	;	    - if arg is an addres in the program,
			      C 	;		a quit causes control to sent to that
			      C 	;		location.	
			      C 	; Inputs: -
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysquit' system call sets u.quit to value of BX
			      C 	;	then branches into 'sysret'.
			      C 	;
 0E8F  89 1E 27D6 R	      C 	mov	word ptr [u.quit], bx
 0E93  E9 F47A		      C 	jmp	sysret
			      C 		; jsr r0,arg; u.quit / put argument in u.quit
			      C 	;1:
			      C 		; mov u.ttyp,r1 / move pointer to control tty buffer
			      C 			      ; / to r1
			      C 		; beq sysret4 / return to user
			      C 		; clrb 6(r1)  / clear the interrupt character 
			      C 			    ; / in the tty buffer
			      C 		; br sysret4  / return to user
			      C 
			      C 	; 27/01/2022
 0E96			      C @@:
 0E96  E9 F45A		      C 	jmp	error
			      C 	
 0E99			      C syssetuid: ; / set process id
			      C 	; 27/01/2022
			      C 	; 02/08/2013
			      C 	; 07/07/2013
			      C 	; 'syssetuid' sets the user id (u.uid) of the current process
			      C 	; to the process id in (u.r0). Both the effective user and 
			      C 	; u.uid and the real user u.ruid are set to this. 
			      C 	; Only the super user can make this call.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syssetuid
			      C 	; Arguments: -
			      C 	;
			      C 	; Inputs: (u.r0) - contains the process id.
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       BL contains the (new) user ID of the current process
			      C 
			      C 		; movb *u.r0,r1 / move process id (number) to r1
 0E99  3A 1E 27DD R	      C 	cmp	bl, byte ptr [u.ruid] 
			      C 		; cmpb r1,u.ruid / is it equal to the real user 
			      C 			       ; / id number
 0E9D  74 0B		      C 	je	short @f
			      C 		; beq 1f / yes
 0E9F  80 3E 27DC R 00	      C 	cmp	byte ptr [u.uid_], 0 ; 02/08/2013
			      C 		; tstb u.uid / no, is current user the super user?
			      C 	;ja	error
			      C 		; bne error4 / no, error
			      C 	; 27/01/2022
 0EA4  77 F0		      C 	ja	short @b  ;j mp error
 0EA6  88 1E 27DD R	      C 	mov	byte ptr [u.ruid], bl
 0EAA			      C @@: ; 1:
 0EAA  88 1E 27DC R	      C 	mov	byte ptr [u.uid_], bl ; 02/08/2013
			      C 		; movb r1,u.uid / put process id in u.uid
			      C 		; movb r1,u.ruid / put process id in u.ruid
 0EAE  E9 F45F		      C 	jmp	sysret
			      C 		; br sysret4 / system return
			      C 	
 0EB1			      C sysgetuid: ; < get user id >
			      C 	; 07/07/2013
			      C 	; 'sysgetuid' returns the real user ID of the current process.
			      C 	; The real user ID identifies the person who is logged in,
			      C 	; in contradistinction to the effective user ID, which
			      C 	; determines his access permission at each moment. It is thus
			      C 	; useful to programs which operate using the 'set user ID'
			      C 	; mode, to find out who invoked them.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	syssetuid
			      C 	; Arguments: -
			      C 	;
			      C 	; Inputs: -
			      C 	; Outputs: (u.r0) - contains the real user's id.
			      C 	; ...............................................................
			      C 	;	
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       AL contains the real user ID at return.
			      C 	;
			      C 	;xor 	ah, ah
 0EB1  A0 27DD R	      C 	mov	al, byte ptr [u.ruid]
 0EB4  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 		; movb	u.ruid,*u.r0 / move the real user id to (u.r0)
 0EB7  E9 F456		      C 	jmp	sysret
			      C 		; br sysret4 / systerm return, sysret
 0EBA			      C anyi: 
			      C 	; 30/01/2022
			      C 	; 25/04/2013
			      C 	; 'anyi' is called if a file deleted while open.
			      C 	; "anyi" checks to see if someone else has opened this file.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - contains an i-number
			      C 	;    fsp - start of table containing open files
			      C 	;
			      C 	; OUTPUTS ->
			      C 	;    "deleted" flag set in fsp entry of another occurrence of
			      C 	;	   this file and r2 points 1st word of this fsp entry.
			      C 	;    if file not found - bit in i-node map is cleared
			      C 	;    			 (i-node is freed)
			      C 	;               all blocks related to i-node are freed
			      C 	;	        all flags in i-node are cleared
			      C 	; ((AX = R1)) input
			      C 	;
			      C 	;    (Retro UNIX Prototype : 02/12/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, CX, BX, SI, DI, BP))  
			      C 	;
			      C 		; / r1 contains an i-number
			      C 	; 30/01/2022
 0EBA  BB 2894 R	      C 	mov	bx, fsp ; mov bx, offset fsp
			      C 		; mov $fsp,r2 / move start of fsp table to r2
 0EBD			      C anyi_1: ; 1:
 0EBD  3B 07		      C 	cmp	ax, word ptr [BX]
			      C 		; cmp r1,(r2) / do i-numbers match?
 0EBF  74 27		      C 	je	short anyi_2
			      C 		; beq 1f / yes, 1f
 0EC1  F7 D8		      C 	neg	ax
			      C 		; neg r1 / no complement r1
 0EC3  3B 07		      C 	cmp	ax, word ptr [BX]
			      C 		; cmp r1,(r2) / do they match now?
 0EC5  74 21		      C 	je	short anyi_2
			      C 		; beq 1f / yes, transfer
			      C 		; / i-numbers do not match
 0EC7  83 C3 08		      C 	add	bx, 8
			      C 		; add $8,r2 / no, bump to next entry in fsp table
			      C 	; 30/01/2022
 0ECA  81 FB 2A24 R	      C 	cmp	bx, fsp+(nfiles*8)
			      C 	;cmp	bx, offset fsp + (nfiles*8)
			      C 		; cmp r2,$fsp+[nfiles*8] 
			      C 				; / are we at last entry in the table
 0ECE  72 ED		      C 	jb	short anyi_1
			      C 		; blt 1b / no, check next entries i-number
			      C 	;cmp	ax, 32768
 0ED0  80 FC 80		      C 	cmp	ah, 80h ; negative number check
			      C 		; tst r1 / yes, no match
			      C 		; bge .+4
 0ED3  72 02		      C 	jb	short @f
 0ED5  F7 D8		      C 	neg	ax
			      C 		; neg r1 / make i-number positive
 0ED7			      C @@:	
 0ED7  E8 03E2		      C 	call	imap
			      C 		; jsr r0,imap / get address of allocation bit 
			      C 			    ; / in the i-map in r2
			      C 	;; DL/DX (MQ) has a 1 in the calculated bit position
			      C         ;; BX (R2) has address of the byte with allocation bit
			      C  	; not	dx
 0EDA  F6 D2		      C 	not 	dl ;; 0 at calculated bit position, other bits are 1
			      C         ;and	word ptr [BX], dx
 0EDC  20 17		      C 	and 	byte ptr [BX], dl 
			      C 		; bicb mq,(r2) / clear bit for i-node in the imap
 0EDE  E8 038F		      C 	call	itrunc
			      C 		; jsr r0,itrunc / free all blocks related to i-node
 0EE1  C7 06 25EA R 0000      C  	mov 	word ptr [i.flgs], 0
			      C 		; clr i.flgs / clear all flags in the i-node
 0EE7  C3		      C 	retn
			      C 		;rts	r0 / return
 0EE8			      C anyi_2: ; 1: / i-numbers match
 0EE8  FE 47 07		      C 	inc 	byte ptr [BX]+7
			      C 		;incb 7(r2) / increment upper byte of the 4th word
			      C 		   ; / in that fsp entry (deleted flag of fsp entry)
 0EEB  C3		      C 	retn
			      C 		; rts r0
			      C 
				include u3.asm ; u3.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U3.ASM (include u0.asm) //// UNIX v1 -> u3.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 27/01/2022 ]  ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 27/01/2022
			      C ; 08/03/2014 wswap, rswap, swap
			      C ; 25/02/2014 swap
			      C ; 23/02/2014 putlu, swap
			      C ; 14/02/2014 swap ('SRUN' check), putlu (single level runq)
			      C ; 05/02/2014 swap (SSLEEP/SWAIT/SRUN, p.waitc)
			      C ; 23/10/2013 swap (consistency check), idle
			      C ; 10/10/2013 idle
			      C ; 24/09/2013 swap, wswap, rswap, tswap (consistency check)
			      C ; 20/09/2013 swap
			      C ; 30/08/2013 swap
			      C ; 09/08/2013 swap
			      C ; 08/08/2013 putlu, wswap, rswap
			      C ; 03/08/2013
			      C ; 01/08/2013
			      C ; 29/07/2013
			      C ; 24/07/2013
			      C ; 23/07/2013
			      C ; 09/07/2013
			      C ; 26/05/2013
			      C ; 24/05/2013
			      C ; 21/05/2013
			      C ; 17/05/2013
			      C ; 16/05/2013 swap
			      C ; 19/04/2013 swap, wrswap
			      C ; 14/04/2013 tswap, swap
			      C ; 10/04/2013
			      C ; 11/03/2013
			      C 
 0EEC			      C tswap:
			      C 	; 14/02/2014 single level runq
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 26/05/2013 (swap, putlu modifications)
			      C 	; 14/04/2013
			      C 	; time out swap, called when a user times out.
			      C 	; the user is put on the low priority queue.
			      C 	; This is done by making a link from the last user
			      C 	; on the low priority queue to him via a call to 'putlu'.
			      C 	; then he is swapped out.
			      C 	;
			      C 	; RETRO UNIX 8086 v1 modification ->
			      C 	;       'swap to disk' is replaced with 'change running segment'
			      C 	;	according to 8086 cpu (x86 real mode) architecture.
			      C 	;	pdp-11 was using 64KB uniform memory while IBM PC
			      C 	;	compatibles was using 1MB segmented memory 
			      C 	;	in 8086/8088 times.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.uno - users process number
			      C 	;    runq+4 - lowest priority queue
			      C 	; OUTPUTS ->
			      C 	;    r0 - users process number
			      C 	;    r2 - lowest priority queue address
			      C 	;
			      C 	; ((AX = R0, BX = R2)) output
			      C 	; ((Modified registers: DX, BX, CX, SI, DI))  	
			      C 	;
 0EEC  A0 27DF R	      C 	mov 	al, byte ptr [u.uno]
			      C 	       	; movb u.uno,r1 / move users process number to r1
			      C        	;mov 	bx, offset runq + 4
			      C 		; mov $runq+4,r2 
			      C 			; / move lowest priority queue address to r2
 0EEF  E8 0094		      C         call 	putlu
			      C 		; jsr r0,putlu / create link from last user on Q to 
			      C 		             ; / u.uno's user
 0EF2			      C swap:
			      C 	; 08/03/2014
			      C 	; 25/02/2014
			      C 	; 23/02/2014
			      C 	; 14/02/2014 single level runq
			      C 	; 05/02/2014 SSLEEP/SWAIT/SRUN, p.waitc
			      C 	; 23/10/2013 consistency check -> ok
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 20/09/2013 ('call idle' enabled again)
			      C 	; 30/08/2013
			      C 	; 09/08/2013
			      C 	; 29/07/2013
			      C 	; 24/07/2013 sstack (= file size + 256)
			      C 	; 26/05/2013 wswap and rswap (are come back!)
			      C 	; 24/05/2013 (u.usp -> sp modification) 
			      C 	; 21/05/2013
			      C 	; 16/05/2013
			      C 	; 19/04/2013 wrswap (instead of wswap and rswap)
			      C 	; 14/04/2013
			      C 	; 'swap' is routine that controls the swapping of processes
			      C 	; in and out of core.
			      C 	;
			      C 	; RETRO UNIX 8086 v1 modification ->
			      C 	;       'swap to disk' is replaced with 'change running segment'
			      C 	;	according to 8086 cpu (x86 real mode) architecture.
			      C 	;	pdp-11 was using 64KB uniform memory while IBM PC
			      C 	;	compatibles was using 1MB segmented memory 
			      C 	;	in 8086/8088 times.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    runq table - contains processes to run.
			      C 	;    p.link - contains next process in line to be run.
			      C 	;    u.uno - process number of process in core	
			      C 	;    s.stack - swap stack used as an internal stack for swapping.	
			      C 	; OUTPUTS ->
			      C 	;    (original unix v1 -> present process to its disk block)
			      C 	;    (original unix v1 -> new process into core -> 
			      C 	;	   Retro Unix 8086 v1 -> segment registers changed 
			      C 	;	   for new process)
			      C 	;    u.quant = 3 (Time quantum for a process)
			      C 	; 	((INT 1Ch count down speed -> 18.2 times per second)	 	
			      C 	;    RETRO UNIX 8086 v1 will use INT 1Ch (18.2 times per second)
			      C 	;	 for now, it will swap the process if there is not
			      C 	;	 a keyboard event (keystroke) (Int 15h, function 4Fh)
			      C 	;	 or will count down from 3 to 0 even if there is a
			      C 	;        keyboard event locking due to repetitive key strokes.
			      C 	;	 u.quant will be reset to 3 for RETRO UNIX 8086 v1.
			      C 	;
			      C 	;    u.pri -points to highest priority run Q.
			      C 	;    r2 - points to the run queue.
			      C 	;    r1 - contains new process number
			      C 	;    r0 - points to place in routine or process that called
			      C 	;	  swap all user parameters
			      C 	;				
			      C 	; ((Modified registers: AX, DX, BX, CX, SI, DI))  	
			      C 	;
 0EF2			      C swap_0:
			      C 		; mov $300,*$ps / processor priority = 6
			      C 	; 14/02/2014
 0EF2  BE 26F2 R	      C 	mov	si, offset runq  ; 23/02/2014 BX -> DI -> SI
			      C 		; mov $runq,r2 / r2 points to runq table
 0EF5			      C swap_1: ; 1: / search runq table for highest priority process
 0EF5  8B 04		      C 	mov	ax, word ptr [SI]
 0EF7  23 C0		      C 	and 	ax, ax
			      C        		; tst (r2)+ / are there any processes to run 
			      C 			  ; / in this Q entry
 0EF9  75 05		      C 	jnz	short swap_2
			      C        		; bne 1f / yes, process 1f
			      C 		; cmp r2,$runq+6 / if zero compare address 
			      C 			       ; / to end of table
			      C 		; bne 1b / if not at end, go back
			      C 
			      C 	;; 25/02/2014
			      C 	;;mov	al, byte ptr [ptty]
			      C 	;;call	wakeup
			      C 	;;or	al, al
			      C 	;;jnz	short swap_1
			      C 	;
			      C 	;;mov	cx, word ptr [s.idlet]+2 ;; 29/07/2013
			      C 	;;; 30/08/2013
			      C 	; 20/09/2013
 0EFB  E8 00AC		      C        	call	idle ; 23/10/2013 (consistency check !)
			      C 		; jsr r0,idle; s.idlet+2 / wait for interrupt; 
			      C 				       ; / all queues are empty
			      C 	; 14/02/2014
 0EFE  EB F5		      C 	jmp	short swap_1
			      C 		; br swap
 0F00			      C swap_2: ; 1:
			      C 		; tst -(r2) / restore pointer to right Q entry
			      C  		; mov r2,u.pri / set present user to this run queue
			      C 	;mov	ax, word ptr [SI]
			      C 	        ; movb (r2)+,r1 / move 1st process in queue to r1
			      C 	;	
 0F00  38 E0		      C 	cmp	al, ah ; 16/05/2013
			      C 		; cmpb r1,(r2)+ / is there only 1 process 
			      C 			      ; / in this Q to be run
 0F02  74 0C		      C 	je	short swap_3
			      C        		; beq 1f / yes
			      C 		; tst -(r2) / no, pt r2 back to this Q entry
			      C 	;
 0F04  8A D8		      C 	mov	bl, al
 0F06  32 FF		      C 	xor	bh, bh
 0F08  8A A7 2689 R	      C 	mov	ah, byte ptr [BX]+p.link-1 
 0F0C  88 24		      C        	mov	byte ptr [SI], ah
			      C 		; movb p.link-1(r1),(r2) / move next process 
			      C 				       ; / in line into run queue
 0F0E  EB 04		      C 	jmp	short swap_4
			      C        		; br 2f
 0F10			      C swap_3: ; 1:
 0F10  33 D2		      C 	xor	dx, dx
			      C 	; 23/02/2014 BX -> SI
 0F12  89 14		      C 	mov	word ptr [SI], dx  ;16/05/2013
			      C 		; clr -(r2) / zero the entry; no processes on the Q
			      C 	;
			      C 	; 26/05/2013 (swap_4 and swap_5)
 0F14			      C swap_4: ; / write out core to appropriate disk area and read 
			      C       ; / in new process if required
			      C        		; clr *$ps / clear processor status
			      C 	; 09/08/2013
 0F14  8A 26 27DF R	      C 	mov 	ah, byte ptr [u.uno]
 0F18  38 C4		      C 	cmp	ah, al
			      C 	;cmp	byte ptr [u.uno], al
			      C        		; cmpb r1,u.uno / is this process the same as 
			      C 			      ; / the process in core?
 0F1A  74 17		      C        	je	short swap_6
			      C        		; beq 2f / yes, don't have to swap
			      C        		; mov r0,-(sp) / no, write out core; save r0 
			      C 			   ; / (address in routine that called swap)
 0F1C  89 26 27A6 R	      C        	mov	word ptr [u.usp], sp 
			      C        		; mov sp,u.usp / save stack pointer
			      C 	; 09/08/2013
			      C 	; 24/07/2013
			      C        	;mov	sp, sstack ; offset sstack
			      C 		; mov $sstack,sp / move swap stack pointer 
			      C 			       ; / to the stack pointer
			      C        	;push	ax	
			      C 		; mov r1,-(sp) / put r1 (new process #) on the stack
			      C 	; 09/08/2013
 0F20  0A E4		      C 	or	ah, ah
			      C 	;cmp 	byte ptr [u.uno], dl ; 0
			      C        		; tstb u.uno / is the process # = 0
 0F22  74 03		      C        	jz	short swap_5
			      C 	;jna	short swap_5
			      C 		; beq  1f / yes, kill process by overwriting
 0F24  E8 0012		      C 	call	wswap
			      C 		;jsr r0,wswap / write out core to disk
 0F27			      C swap_5: ;1: 
			      C 	; pop	ax
			      C        		; mov (sp)+,r1 / restore r1 to new process number
			      C 	; 08/03/2014
			      C 	; (protect 'rswap' return address from stack overwriting)
 0F27  FA		      C 	cli
 0F28  BC 3E50 R	      C        	mov	sp, sstack - 190 ; (SizeOfFile + 2) 
			      C 	;
 0F2B  E8 0032		      C 	call	rswap
			      C 		; jsr r0,rswap / read new process into core
			      C        		; jsr r0,unpack / unpack the users stack from next
			      C 			      ; / to his program to its normal
 0F2E  8B 26 27A6 R	      C 	mov	sp, word ptr [u.usp]
			      C 		; mov u.usp,sp / location; restore stack pointer to
			      C 			     ; / new process stack
			      C 		; mov (sp)+,r0 / put address of where the process 
			      C 			     ; / that just got swapped in, left off.,
			      C 			     ; / i.e., transfer control to new process
 0F32  FB		      C 	sti
 0F33			      C swap_6: ;2:
			      C 	; 14/02/2014 uquant -> u.quant
			      C 	; 30/08/2013
			      C 	; RETRO UNIX 8086 v1 modification !
 0F33  C6 06 27D2 R 04	      C 	mov	byte ptr [u.quant], time_count 
			      C 	;mov	byte ptr [uquant], 3
			      C 		; movb    $30.,uquant / initialize process time quantum
 0F38  C3		      C 	retn
			      C 		; rts r0 / return
			      C 
 0F39			      C wswap:  ; < swap out, swap to disk >
			      C 	; 08/03/2014 major modification
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 08/08/2013
			      C 	; 24/07/2013
			      C 	; 26/05/2013
			      C 	; 'wswap' writes out the process that is in core onto its 
			      C 	; appropriate disk area.
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification ->
			      C 	;       'swap to disk' is replaced with 'change running segment'
			      C 	;	according to 8086 cpu (x86 real mode) architecture.
			      C 	;	pdp-11 was using 64KB uniform memory while IBM PC
			      C 	;	compatibles was using 1MB segmented memory 
			      C 	;	in 8086/8088 times.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.break - points to end of program
			      C 	;    u.usp - stack pointer at the moment of swap
			      C 	;    core - beginning of process program		
			      C 	;    ecore - end of core 	
			      C 	;    user - start of user parameter area		
			      C 	;    u.uno - user process number	
			      C 	;    p.dska - holds block number of process	
			      C 	; OUTPUTS ->
			      C 	;    swp I/O queue
			      C 	;    p.break - negative word count of process 
			      C 	;    r1 - process disk address	
			      C 	;    r2 - negative word count
			      C 	;
			      C 	; RETRO UNIX 8086 v1 input/output:
			      C 	;
			      C 	; INPUTS ->
			      C 	;    u.uno - process number (to be swapped out)
			      C 	; OUTPUTS ->
			      C 	;    none
			      C 	;
			      C 	;   ((Modified registers: CX, SI, DI))  
			      C 
 0F39  BF 06C0		      C 	mov	di, sdsegmnt
 0F3C  8E C7		      C 	mov	es, di
 0F3E  32 C9		      C 	xor 	cl, cl
 0F40  8A 2E 27DF R	      C 	mov	ch, byte ptr [u.uno]
 0F44  FE CD		      C 	dec	ch ; 0 based process number
			      C 	;; 08/03/2014 (swap data space is 256 bytes for every process)
			      C 	;;shr 	cx, 1 ; swap data space is 128 bytes for every process
 0F46  8B F9		      C 	mov 	di, cx
			      C 	; 08/03/2014
 0F48  B9 0020		      C 	mov	cx, 32
 0F4B  BE 27A4 R	      C 	mov	si, offset u ; user structure
 0F4E  F3/ A5		      C 	rep	movsw
			      C 	;
 0F50  8B 36 27A6 R	      C 	mov	si, word ptr [u.usp]  ; sp  (system stack pointer)
 0F54  B9 3F0E R	      C 	mov 	cx, sstack
 0F57  2B CE		      C 	sub	cx, si	; NOTE: system stack size = 256-64 = 192 bytes
 0F59  F3/ A4		      C 	rep	movsb
			      C 	;
 0F5B  8C D9		      C 	mov	cx, ds
 0F5D  8E C1		      C 	mov	es, cx
 0F5F  C3		      C 	retn
			      C 	;
			      C 	; 08/08/2013, 14 -> 16, 7 -> 8
			      C 	;mov	si, sstack - 16 ; 24/07/2013
			      C 			; offset sstack - 16 ;; = word ptr [u.sp_] - 2
			      C 	;mov	cx, 8
			      C 	;rep 	movsw	
			      C 	;mov	cl, 32
			      C 	;mov	si, offset u ; user structure
			      C 	;rep	movsw
			      C 	;mov	cx, ds
			      C 	;mov	es, cx
			      C 	;retn
			      C 
			      C ; Original UNIX v1 'wswap' routine:
			      C 	; wswap:
			      C 		; mov *$30,u.emt / determines handling of emts
			      C         	; mov *$10,u.ilgins / determines handling of 
			      C 				; / illegal instructions
			      C 		; mov u.break,r2 / put process program break address in r2
			      C 		; inc r2 / add 1 to it 
			      C 		; bic $1,r2 / make it even
			      C 		; mov r2,u.break / set break to an even location
			      C 		; mov u.usp,r3 / put users stack pointer 
			      C 			     ; / at moment of swap in r3
			      C 		; cmp r2,$core / is u.break less than $core
			      C 		; blos 2f / yes
			      C 		; cmp r2,r3 / no, is (u.break) greater than stack ptr.
			      C        		; bhis 2f / yes
			      C 	; 1:
			      C        		; mov (r3)+,(r2)+ / no, pack stack next to users program
			      C 		; cmp r3,$ecore / has stack reached end of core
			      C 		; bne 1b / no, keep packing
			      C 	 	; br 1f / yes
			      C 	; 2:
			      C        		; mov $ecore,r2 / put end of core in r2 
			      C 	; 1:
			      C        		; sub  $user,r2 / get number of bytes to write out 
			      C 			   ; / (user up to end of stack gets written out)
			      C 		; neg r2 / make it negative
			      C 		; asr r2 / change bytes to words (divide by 2)
			      C 		; mov r2,swp+4 / word count
			      C 		; movb u.uno,r1 / move user process number to r1
			      C 		; asl r1 / x2 for index
			      C       		; mov r2,p.break-2(r1) / put negative of word count 
			      C 				     ; / into the p.break table
			      C        		; mov p.dska-2(r1),r1 / move disk address of swap area 
			      C 				    ; /	for process to r1
			      C        		; mov r1,swp+2 / put processes dska address in swp+2 
			      C 			     ; / (block number)
			      C 		; bis $1000,swp / set it up to write (set bit 9)
			      C        		; jsr r0,ppoke / write process out on swap area of disk
			      C 	; 1:
			      C        		; tstb swp+1 / is lt done writing?
			      C        		; bne 1b / no, wait
			      C 		; rts r0 / yes, return to swap
			      C 
 0F60			      C rswap:  ; < swap in, swap from disk >
			      C 	; 08/03/2014 major modification
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 08/08/2013
			      C 	; 24/07/2013
			      C 	; 26/05/2013
			      C 	; 'rswap' reads a process whose number is in r1, 
			      C 	; from disk into core.
			      C 	;
			      C 	; RETRO UNIX 8086 v1 modification ->
			      C 	;       'swap to disk' is replaced with 'change running segment'
			      C 	;	according to 8086 cpu (x86 real mode) architecture.
			      C 	;	pdp-11 was using 64KB uniform memory while IBM PC
			      C 	;	compatibles was using 1MB segmented memory 
			      C 	;	in 8086/8088 times.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - process number of process to be read in
			      C 	;    p.break - negative of word count of process 
			      C 	;    p.dska - disk address of the process		
			      C 	;    u.emt - determines handling of emt's 	
			      C 	;    u.ilgins - determines handling of illegal instructions		
			      C 	; OUTPUTS ->
			      C 	;    8 = (u.ilgins)
			      C 	;    24 = (u.emt)
			      C 	;    swp - bit 10 is set to indicate read 
			      C 	;		(bit 15=0 when reading is done)	
			      C 	;    swp+2 - disk block address
			      C 	;    swp+4 - negative word count 	
			      C 	;      ((swp+6 - address of user structure)) 
			      C 	;
			      C 	; RETRO UNIX 8086 v1 input/output:
			      C 	;
			      C 	; INPUTS ->
			      C 	;    AL	- new process number (to be swapped in)	 
			      C 	; OUTPUTS ->
			      C 	;    none
			      C 	;
			      C 	;   ((Modified registers: AX, CX, SI, DI)) 
			      C 
 0F60  8A E0		      C 	mov	ah, al
 0F62  FE CC		      C 	dec	ah
 0F64  32 C0		      C 	xor	al, al 
			      C 	;;shr 	ax, 1 ; 08/03/2014 (256 bytes per process)
 0F66  8B F0		      C 	mov	si, ax ; SI points copy of sstack in sdsegment
			      C 		       ; u.sp_ points sstack-12 (for 6 registers)
 0F68  B8 06C0		      C 	mov	ax, sdsegmnt ; 17/05/2013
 0F6B  8E D8		      C 	mov	ds, ax ; sdsegment
			      C 	; 08/03/2014
 0F6D  BF 27A4 R	      C 	mov	di, offset u
 0F70  B9 0020		      C 	mov	cx, 32
 0F73  F3/ A5		      C 	rep	movsw
 0F75  26: 8B 3E 27A6 R	      C 	mov	di, word ptr ES:[u.usp] ; system stack pointer location
 0F7A  B9 3F0E R	      C 	mov	cx, sstack		
 0F7D  2B CF		      C 	sub	cx, di		; Max. 256-64 bytes stack space
 0F7F  F3/ A4		      C 	rep	movsb
 0F81  8C C8		      C 	mov	ax, cs
 0F83  8E D8		      C 	mov	ds, ax
 0F85  C3		      C 	retn
			      C 	;
			      C 	; 08/08/2013 14 -> 16, 7 ->8
			      C 	; 24/07/2013
			      C 	;mov	di, sstack - 16 ; offset sstack-14
			      C 	;mov	cx, 8
			      C 	;rep 	movsw
			      C 	;mov	di, offset u
			      C 	;mov	cl, 32
			      C 	;rep	movsw
			      C 	;mov	ax, cs
			      C 	;mov	ds, ax
			      C 	;retn
			      C 
			      C ; Original UNIX v1 'rswap'  and 'unpack' routines:
			      C 	;rswap:
			      C        		; asl r1 / process number x2 for index
			      C        		; mov p.break-2(r1), swp+4 / word count
			      C        		; mov p.dska-2(r1),swp+2 / disk address
			      C        		; bis $2000,swp / read
			      C        		; jsr r0,ppoke / read it in 
			      C 	; 1:
			      C        		; tstb swp+1 / done
			      C        		; bne 1b / no, wait for bit 15 to clear (inhibit bit)
			      C        		; mov u.emt,*$30 / yes move these
			      C        		; mov u.ilgins,*$10 / back
			      C        		; rts r0 / return
			      C 
			      C 	;unpack: ; / move stack back to its normal place
			      C 		; mov u.break,r2 / r2 points to end of user program
			      C        		; cmp r2,$core / at beginning of user program yet?
			      C 		; blos 2f / yes, return
			      C 		; cmp r2,u.usp / is break_above the stack pointer 
			      C 			     ; / before swapping
			      C 		; bhis 2f / yes, return
			      C 		; mov $ecore,r3 / r3 points to end of core
			      C 		; add r3,r2
			      C 		; sub u.usp,r2 / end of users stack is in r2
			      C 	; 1:
			      C 		; mov -(r2),-(r3) / move stack back to its normal place
			      C 		; cmp r2,u.break / in core
			      C 		; bne 1b
			      C 	; 2:
			      C        		; rts r0
			      C 
 0F86			      C putlu: 
			      C 	; 23/02/2014
			      C 	; 14/02/2014 single level run queue
			      C 	; 08/08/2013
			      C 	; 26/05/2013 (si -> di)
			      C 	; 15/04/2013
			      C 	;
			      C 	; 'putlu' is called with a process number in r1 and a pointer
			      C 	; to lowest priority Q (runq+4) in r2. A link is created from
			      C 	; the last process on the queue to process in r1 by putting
			      C 	; the process number in r1 into the last process's link.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - user process number
			      C 	;    r2 - points to lowest priority queue 
			      C 	;    p.dska - disk address of the process		
			      C 	;    u.emt - determines handling of emt's 	
			      C 	;    u.ilgins - determines handling of illegal instructions		
			      C 	; OUTPUTS ->
			      C 	;    r3 - process number of last process on the queue upon
			      C 	;	  entering putlu
			      C 	;    p.link-1 + r3 - process number in r1
			      C 	;    r2 - points to lowest priority queue
			      C 	;
			      C 	; ((Modified registers: DX, BX, DI)) 
			      C 	;
			      C 
			      C ; / r1 = user process no.; r2 points to lowest priority queue
			      C 
			      C 	; BX = r2
			      C 	; AX = r1 (AL=r1b)
			      C       
			      C 	; 14/02/2014
 0F86  BB 26F2 R	      C 	mov	bx, offset runq
			      C 	; 23/02/2014
 0F89  8B 17		      C         mov     dx, word ptr [BX]
 0F8B  43		      C 	inc	bx
 0F8C  23 D2		      C 	and	dx, dx
			      C 		; tstb (r2)+ / is queue empty?
 0F8E  74 0C		      C        	jz	short putlu_1
			      C 		; beq 1f / yes, branch
 0F90  8A D6		      C 	mov	dl, dh
 0F92  32 F6		      C 	xor	dh, dh
 0F94  8B FA		      C 	mov	di, dx
			      C        		; movb (r2),r3 / no, save the "last user" process number
			      C 			     ; / in r3
 0F96  88 85 2689 R	      C        	mov	byte ptr [DI]+p.link-1, al
			      C 		; movb r1,p.link-1(r3) / put pointer to user on 
			      C 			     ; / "last users" link
 0F9A  EB 03		      C 	jmp	short putlu_2
			      C 		; br 2f /
 0F9C			      C putlu_1: ; 1:
 0F9C  88 47 FF		      C 	mov	byte ptr [BX]-1, al ; 08/08/2013
			      C        		; movb r1,-1(r2) / user is only user; 
			      C 			    ; / put process no. at beginning and at end
 0F9F			      C putlu_2: ; 2: 
 0F9F  88 07		      C 	mov	byte ptr [BX], al
			      C        		; movb r1,(r2) / user process in r1 is now the last entry
			      C 			     ; / on the queue
			      C 	; 23/02/2014
 0FA1  8A D0		      C 	mov	dl, al
 0FA3  8B FA		      C         mov     di, dx
 0FA5  88 B5 2689 R	      C         mov     byte ptr [DI]+p.link-1, dh ; 0
			      C 	; 
			      C        	;14/02/2014
			      C 	;dec	bx
			      C 		; dec r2 / restore r2
 0FA9  C3		      C         retn
			      C 		; rts r0
			      C 
			      C ;copyz:
			      C ;       mov     r1,-(sp) / put r1 on stack
			      C ;       mov     r2,-(sp) / put r2 on stack
			      C ;       mov     (r0)+,r1
			      C ;       mov     (r0)+,r2
			      C ;1:
			      C ;       clr     (r1)+ / clear all locations between r1 and r2
			      C ;       cmp     r1,r2 
			      C ;       blo     1b
			      C ;       mov     (sp)+,r2 / restore r2
			      C ;       mov     (sp)+,r1 / restore r1
			      C ;       rts     r0 
			      C 
 0FAA			      C idle:
			      C       ; 23/10/2013
			      C       ; 10/10/2013	 
			      C       ; 29/07/2013	
			      C       ; 09/07/2013	
			      C       ; 10/04/2013	
			      C       ; (idle & wait loop)
			      C       ; Retro Unix 8086 v1 modification on original Unixv1 idle procedure!
			      C       ; input -> CX = wait count 
			      C 
			      C       ;sti
			      C       ; 29/07/2013
 0FAA  F4		      C       hlt
 0FAB  90		      C       nop ; 10/10/2013
 0FAC  90		      C       nop
 0FAD  90		      C       nop
			      C       ; 23/10/2013
 0FAE  90		      C       nop
 0FAF  90		      C       nop
 0FB0  90		      C       nop
 0FB1  90		      C       nop
 0FB2  C3		      C       retn      
			      C 
			      C       ;sti
			      C       ;;;push	word ptr [clockp]
			      C       ;or	cx, cx
			      C       ;jnz	short @f
			      C       ;inc	cx	
			      C ;@@:		  		
			      C       ;;;mov word ptr [clockp], cx 				
 0FB3			      C @@:
			      C       ;hlt ; wait for interrupt (timer interrupt or keyboard interrupt etc.)
			      C       ;;;dec	word ptr [clockp]
			      C       ;dec	cx ; 09/07/2013 ;;;
			      C       ;jnz	short @b
			      C       ;;;pop	word ptr [clockp]		   		
			      C       ;retn	
			      C 
			      C        ;mov *$ps,-(sp) / save ps on stack
			      C        ;clr *$ps / clear ps
			      C        ;mov clockp,-(sp) / save clockp on stack
			      C        ;mov (r0)+,clockp / arg to idle in clockp
			      C        ;1 / wait for interrupt
			      C        ;mov (sp)+,clockp / restore clockp, ps
			      C        ;mov (sp)+,*$ps
			      C        ;rts r0
			      C 
 0FB3			      C clear:
			      C 	; 27/01/2022
			      C 	; 03/08/2013
			      C 	; 01/08/2013
			      C 	; 23/07/2013
			      C 	; 09/04/2013
			      C 	;
			      C 	; 'clear' zero's out of a block (whose block number is in r1)
			      C 	; on the current device (cdev)
			      C 	;	
			      C 	; INPUTS ->
			      C 	;    r1 - block number of block to be zeroed
			      C 	;    cdev - current device number 
			      C 	; OUTPUTS ->
			      C 	;    a zeroed I/O buffer onto the current device
			      C 	;    r1 - points to last entry in the I/O buffer
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	;    (Retro UNIX Prototype : 18/11/2012 - 14/11/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, CX, BX, SI, DI, BP))  
			      C 
 0FB3  E8 095E		      C 	call 	wslot
			      C 		; jsr r0,wslot / get an I/O buffer set bits 9 and 15 in first
			      C                    ; / word of I/O queue r5 points to first data word in buffer
 0FB6  8B FB		      C 	mov	di, bx ; r5
 0FB8  8B D0		      C 	mov	dx, ax ; 01/08/2013
 0FBA  B9 0100		      C 	mov	cx, 256
			      C 		; mov $256.,r3
 0FBD  33 C0		      C 	xor	ax, ax
 0FBF  F3/ AB		      C 	rep	stosw ; 03/08/2013
 0FC1  8B C2		      C 	mov	ax, dx ; 01/08/2013
			      C  
			      C ; 1: 
			      C        		; clr (r5)+ / zero data word in buffer
			      C        		; dec r3
			      C        		; bgt 1b / branch until all data words in buffer are zero
			      C 	; 27/01/2022
			      C 	;call	dskwr
			      C 		; jsr r0,dskwr / write zeroed buffer area out onto physical
			      C                              ; / block specified in r1
			      C 	; AX (r1) = block number
			      C 	;retn
			      C 		; rts r0
 0FC3  E9 0959		      C 	jmp	dskwr
			      C 
				include u4.asm ; u4.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U4.ASM (include u4.asm) //// UNIX v1 -> u4.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 30/01/2022 ] !!! completed !!!
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 28/01/2022
			      C ; 27/01/2022 (optimized code)
			      C ; 04/07/2014 (swakeup has been removed)
			      C ; 11/06/2014 swakeup
			      C ; 02/06/2014 swakeup
			      C ; 30/05/2014 isintr
			      C ; 20/03/2014 sleep
			      C ; 18/03/2014 clock
			      C ; 25/02/2014 sleep
			      C ; 23/02/2014 wakeup, sleep
			      C ; 17/02/2014 wakeup
			      C ; 14/02/2014 clock
			      C ; 14/02/2014 sleep, wakeup (sigle level runq) ((to prevent s/w locking))
			      C ; 05/02/2014 sleep, wakeup (SSLEEP/SRUN, p.waitc)
			      C ; 26/01/2014
			      C ; 10/12/2013
			      C ; 07/12/2013 clock
			      C ; 23/10/2013 wakeup, sleep
			      C ; 20/10/2013 isintr, clock, wakeup, sleep 
			      C ; 05/10/2013 clock, wakeup, sleep
			      C ; 24/09/2013 sleep, wakeup (consistency check)
			      C ; 22/09/2013 sleep, wakeup (completed/modified)
			      C ; 20/09/2013 clock, sleep
			      C ;	NOTE: 'sleep' and 'wakeup' need to be modified according to
			      C ;	      original Unix v1 waiting channel feature. 
			      C ;	      Currently 'wakeup' is disabled and 'sleep' is not written 
			      C ;	      properly and clock, sleep, wakeup are not similar 
			      C ;	      to original unix v1 (multi tasking, time sharing feature).
			      C ; 03/09/2013 clock, isintr
			      C ; 30/08/2013 clock
			      C ; 21/08/2013
			      C ; 29/07/2013 sleep
			      C ; 09/07/2013 clock (INT 1Ch handler)
			      C ; 16/05/2013 'isintr' modifications
			      C ; 15/05/2013
			      C ; 09/05/2013
			      C ; 11/03/2013
			      C ;setisp:
			      C        ;mov     r1,-(sp)
			      C        ;mov     r2,-(sp)
			      C        ;mov     r3,-(sp)
			      C        ;mov     clockp,-(sp)
			      C        ;mov     $s.syst+2,clockp
			      C        ;jmp     (r0)
			      C 
 0FC6			      C clock: ; / interrupt from 60 cycle clock
			      C 	; 30/01/2022
			      C 	; 10/04/2014
			      C 	; 18/03/2014
			      C 	; 14/02/2014 uquant --> u.quant
			      C 	; 10/12/2013
			      C 	; 07/12/2013
			      C ;; Retro Unix 8086 v1 Modification: INT 1Ch interrupt handler !
			      C ;; 30/08/2013
			      C ;; 09/07/2013
			      C        ;mov     r0,-(sp) / save r0
			      C        ;tst     *$lks / restart clock?
			      C        ;mov     $s.time+2,r0 / increment the time of day
			      C        ;inc     (r0)
			      C        ;bne     1f
			      C        ;inc     -(r0)
			      C ;1:
			      C        ;mov     clockp,r0 / increment appropriate time category
			      C        ;inc     (r0)
			      C        ;bne     1f
			      C        ;inc     -(r0)
			      C ;1:
			      C ;; 30/08/2013
			      C ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 09/07/2013
			      C 
			      C 	; 20/10/2013
 0FC6  1E		      C 	push 	ds
 0FC7  0E		      C 	push 	cs
 0FC8  1F		      C 	pop 	ds
			      C 	;
			      C 	; 30/01/2022
			      C 	; 10/04/2014
			      C 	;pushf
			      C 	;call	dword ptr [int1Ch]  ; Old INT 1Ch 
			      C 	;			    ; (Turn off floppy motor)
			      C 
 0FC9  80 3E 27D2 R 00	      C 	cmp	byte ptr [u.quant], 0
 0FCE  77 39		      C 	ja	short clk_1
			      C 
			      C 	; 03/09/2013
 0FD0  80 3E 26F7 R FF	      C 	cmp	byte ptr [sysflg], 0FFh ; user or system space ?
 0FD5  75 36		      C 	jne	short clk_2 ; system space (sysflg <> 0FFh)
			      C 	;; 06/12/2013
 0FD7  80 3E 27DF R 01	      C 	cmp	byte ptr [u.uno], 1 ; /etc/init ?
			      C 	; 14/02/2014
 0FDC  76 2B		      C 	jna	short clk_1 ; yes, do not swap out
 0FDE  83 3E 27D4 R 00	      C 	cmp	word ptr [u.intr], 0
			      C 	; 14/02/2014
 0FE3  76 28		      C 	jna	short clk_2
 0FE5			      C clk_0:
			      C 	; 30/08/2013
			      C 	;cli
			      C 	;;push	cs
			      C 	;;pop	ds
			      C 	; 18/03/2014
 0FE5  FE 06 26F7 R	      C 	inc	byte ptr [sysflg] ; Now, we are in system space
			      C 	;
 0FE9  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
			      C 	; 07/12/2013
 0FEC  58		      C 	pop 	ax ; DS (user)
			      C 	;
 0FED  89 26 27A6 R	      C 	mov	word ptr [u.usp], sp
			      C 	;; 07/12/2013
			      C 	;;mov	ax, ss ; mov ax, es
			      C 	;;mov	word ptr [u.segmnt], ax
 0FF1  8C C8		      C 	mov 	ax, cs
			      C 	;mov	es, ax ; 18/03/2014
 0FF3  BC 3F0E R	      C 	mov	sp, sstack
 0FF6  8E D0		      C 	mov	ss, ax
			      C 	;
 0FF8  FF 36 27A6 R	      C 	push 	word ptr [u.usp]
 0FFC  52		      C 	push	dx
 0FFD  51		      C 	push	cx
 0FFE  53		      C 	push	bx
 0FFF  56		      C 	push	si
 1000  57		      C 	push	di
 1001  55		      C 	push	bp
			      C 	;
 1002  89 26 27A4 R	      C 	mov	word ptr [u.sp_], sp
			      C     	;sti
			      C 	; 07/12/2013
 1006  E9 F348		      C         jmp     sysrelease ; 'sys release' by clock/timer
 1009			      C clk_1:
 1009  FE 0E 27D2 R	      C 	dec	byte ptr [u.quant]
 100D			      C clk_2:
			      C 	; 20/10/2013
 100D  1F		      C 	pop 	ds
 100E  CF		      C 	iret
			      C 
			      C ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
			      C 
			      C        ;mov     $uquant,r0 / decrement user time quantum
			      C        ;decb    (r0)
			      C        ;bge     1f / if less than 0
			      C        ;clrb    (r0) / make it 0
			      C ;1: / decrement time out counts return now if priority was not 0
			      C        ;cmp     4(sp),$200 / ps greater than or equal to 200
			      C        ;bge     2f / yes, check time outs
			      C        ;tstb    (r0) / no, user timed out?
			      C        ;bne     1f / no
			      C        ;cmpb    sysflg,$-1 / yes, are we outside the system?
			      C        ;bne     1f / no, 1f
			      C        ;mov     (sp)+,r0 / yes, put users r0 in r0
			      C        ;sys     0 / sysrele
			      C        ;rti
			      C ;2: / priority is high so just decrement time out counts
			      C        ;mov     $toutt,r0 / r0 points to beginning of time out table
			      C ;2:
			      C        ;tstb    (r0) / is the time out?
			      C        ;beq     3f / yes, 3f (get next entry)
			      C        ;decb    (r0) / no, decrement the time
			      C        ;bne     3f / isit zero now?
			      C        ;incb    (r0) / yes, increment the time
			      C ;3:
			      C        ;inc     r0 / next entry
			      C        ;cmp     r0,$touts / end of toutt table?
			      C        ;blo     2b / no, check this entry
			      C        ;mov     (sp)+,r0 / yes, restore r0
			      C        ;rti / return from interrupt
			      C ;1: / decrement time out counts; if 0 call subroutine
			      C        ;mov     (sp)+,r0 / restore r0
			      C        ;mov     $240,*$ps / set processor priority to 5
			      C        ;jsr     r0,setisp / save registers
			      C        ;mov     $touts-toutt-1,r0 / set up r0 as index to decrement thru
			      C                                ;  / the table
			      C ;1:
			      C        ;tstb    toutt(r0) / is the time out for this entry
			      C        ;beq     2f / yes
			      C        ;decb    toutt(r0) / no, decrement the time
			      C        ;bne     2f / is the time 0, now
			      C        ;asl     r0 / yes, 2 x r0 to get word index for tout entry
			      C        ;jsr     r0,*touts(r0) / go to appropriate routine specified in this
			      C        ;asr     r0 / touts entry; set r0 back to toutt index
			      C ;2:
			      C        ;dec     r0 / set up r0 for next entry
			      C        ;bge     1b / finished? , no, go back
			      C        ;br      retisp / yes, restore registers and do a rti
			      C 
			      C ;retisp:
			      C        ;mov     (sp)+,clockp / pop values before interrupt off the stack
			      C        ;mov     (sp)+,r3
			      C        ;mov     (sp)+,r2
			      C        ;mov     (sp)+,r1
			      C        ;mov     (sp)+,r0
			      C        ;rti     / return from interrupt
			      C 
 100F			      C @@:	; 22/09/2013
 100F  C3		      C 	retn
			      C 
 1010			      C wakeup: ; / wakeup processes waiting for an event 
			      C 	; / by linking them to the queue
			      C 	;
			      C 	; 02/06/2014
			      C 	; 23/02/2014
			      C 	; 17/02/2014
			      C 	; 14/02/2014 single level runq (BX input is not needed)
			      C 	; 05/02/2014 SSLEEP/SRUN, p.waitc
			      C 	; 23/10/2013 (consistency check is OK)
			      C 	; 20/10/2013
			      C 	; 10/10/2013
			      C 	; 05/10/2013
			      C 	; 24/09/2013 (consistency check is OK)
			      C 	; 22/09/2013
			      C 	; 18/08/2013 -> tty lock and console tty setting (p.ttyc)
			      C 	; 15/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; (Process/task switching routine by using
			      C 	; Retro UNIX 8086 v1 keyboard interrupt output.))
			      C 	;
			      C 	; In original UNIX v1, 'wakeup' is called to wake the process
			      C 	; sleeping in the specified wait channel by creating a link 
			      C 	; to it from the last user process on the run queue.
			      C 	; If there is no process to wake up, nothing happens.
			      C 	;
			      C 	; In Retro UNIX 8086 v1, Int 09h keyboard interrupt will set
			      C 	; 'switching' status of the current process (owns current tty)
			      C 	; (via alt + function keys) to a process which has highest
			      C 	; priority (on run queue) on the requested tty (0 to 7, except
			      C 	; 8 and 9 which are tty identifiers of COM1, COM2 serial ports)
			      C 	; as it's console tty. (NOTE: 'p.ttyc' is used to set console
			      C 	; tty for tty switching by keyboard.)	 
			      C 	; 
			      C 	; INPUT -> 
			      C 	;	   AL = wait channel (r3) ('tty number' for now)
			      C 	;	   ;;BX = Run queue (r2) offset
			      C 	;
			      C 	; ((modified registers: AX, BX))
			      C 	;
			      C 	; 20/10/2013
			      C 	; 10/10/2013
			      C 	;;cmp 	byte ptr [u.uno], 2
			      C 	;;jb	short wakeup_4
			      C 	; 14/02/2014
 1010  32 FF		      C 	xor	bh, bh
 1012  8A D8		      C 	mov	bl, al
 1014  81 C3 278E R	      C 	add	bx, offset wlist
			      C 	; 23/02/2014
 1018  8A 07		      C 	mov	al, byte ptr [BX] ; waiting list (waiting process number)
			      C 
 101A  22 C0		      C 	and	al, al
 101C  74 0F		      C 	jz	short @f ; nothing to wakeup
			      C 	;cmp	al, 1
			      C 	;jb	short @f ; nothing to wakeup
			      C 
			      C 	; 23/02/2014
			      C 	;
 101E  32 E4		      C 	xor	ah, ah
 1020  88 26 27D2 R	      C 	mov 	byte ptr [u.quant], ah ; 0 ; time quantum = 0	
 1024  88 27		      C 	mov	byte ptr [BX], ah ; 0 ; zero wait channel entry
 1026  57		      C 	push	di
 1027  52		      C 	push	dx
 1028  E8 FF5B		      C 	call	putlu
 102B  5A		      C 	pop	dx
 102C  5F		      C 	pop	di
 102D			      C @@:
 102D  C3		      C 	retn
			      C 
			      C        		;mov     r1,-(sp) / put char on stack
			      C        		;mov     (r0)+,r2 / r2 points to a queue
			      C        		;mov     (r0)+,r3 / r3 = wait channel number
			      C        		;movb    wlist(r3),r1 / r1 contains process number 
			      C 		;	  / in that wait channel that was sleeping
			      C        		;beq     2f / if 0 return, nothing to wakeup
			      C        		;cmp     r2,u.pri / is runq greater than or equal 
			      C 		; 		/ to users process priority
			      C        		;bhis    1f / yes, don't set time quantum to zero
			      C        		;clrb    uquant / time quantum = 0
			      C 	;1:
			      C        		;clrb    wlist(r3) / zero wait channel entry
			      C        		;jsr     r0,putlu / create a link from the last user
			      C 		;  / on the Q to this process number that got woken
			      C 	;2:
			      C        		;mov     (sp)+,r1 / restore r1
			      C        		;rts     r0
			      C 
 102E			      C sleep: 
			      C 	; 27/01/2022
			      C 	; 20/03/2014
			      C 	; 25/02/2014
			      C 	; 23/02/2014
			      C 	; 14/02/2014 single level runq
			      C 	; 05/02/2014 SSLEEP/SRUN, p.waitc
			      C 	; 26/01/2014
			      C 	; 10/12/2013
			      C 	; 23/10/2013 (consistency check is OK)
			      C 	; 20/10/2013
			      C 	; 05/10/2013 (u.uno = 1 --> /etc/init ?) (r1 = ah)
			      C 	; 24/09/2013 consistency check -> OK
			      C 	; 22/09/2013
			      C 	; 20/09/2013
			      C 	; 29/07/2013 ;;;
			      C 	; 09/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; (Process/task switching and quit routine by using
			      C 	; Retro UNIX 8086 v1 keyboard interrupt output.))
			      C 	;
			      C 	; In original UNIX v1, 'sleep' is called to wait for
			      C 	; tty and tape output or input becomes available
			      C 	; and process is put on waiting channel and swapped out,
			      C 	; then -when the tty or tape is ready to write or read-
			      C 	; 'wakeup' gets process back to active swapped-in status.)
			      C 	;
			      C 	; In Retro UNIX 8086 v1, Int 1Bh ctrl+brk interrupt and
			      C 	; Int 09h keyboard interrupt will set 'quit' or 'switching'		
			      C 	; status of the current process also INT 1Ch will count down
			      C 	; 'uquant' value and INT 09h will redirect scancode of keystroke
			      C 	; to tty buffer of the current process and kernel will get
			      C 	; user input by using tty buffer of the current process
			      C 	; (instead of standard INT 16h interrupt).
			      C 	; TTY output will be redirected to related video page of text mode
			      C 	; (INT 10h will be called with different video page depending
			      C 	; on tty assignment of the active process: 0 to 7 for
			      C 	; pseudo screens.)
			      C 	;
			      C 	; In Retro UNIX 8086 v1, 'sleep' will be called to wait for
			      C 	; a keystroke from keyboard or wait for reading or writing
			      C 	; characters/data on serial port(s).
			      C 	;
			      C 	; Character/Terminal input/output through COM1 and COM2 will be
			      C 	; performed by related routines in addition to pseudo TTY routines.
			      C 	; 
			      C 	; R1 = AH = wait channel (0-9 for TTYs) ; 05/10/2013 (22/09/2013)
			      C 	;
			      C 	;; 05/10/2013
			      C         ;10/12/2013
			      C 	;cmp	byte ptr [u.uno], 1
			      C         ;ja	short @f
			      C 	;retn
			      C 
			      C 	; 20/03/2014
			      C 	;mov	bx, word ptr [runq]
			      C 	;cmp	bl, bh
			      C 	;jne	short @f	
			      C 	; 25/02/2014
			      C 	;cmp	word ptr [runq], 0
			      C 	;ja	short @f	
			      C 	;retn
 102E			      C @@:
 102E  E8 0030		      C 	call	isintr
			      C 	;jnz	sysret
			      C 		; / wait for event
			      C        		; jsr r0,isintr / check to see if interrupt 
			      C 		;               / or quit from user
			      C                	; br 2f	        / something happened
			      C 		;               / yes, his interrupt so return
			      C                 ;       	/ to user
			      C 	; 27/01/2022
 1031  74 03		      C 	jz	short @f
 1033  E9 F2DA		      C 	jmp	sysret
 1036			      C @@:
			      C     	; 20/10/2013
 1036  32 FF		      C         xor     bh, bh
 1038  8A DC		      C         mov     bl, ah
			      C         ; 22/09/2013
 103A  81 C3 278E R	      C 	add	bx, offset wlist
			      C 	; 23/02/2014
 103E  8A 07		      C 	mov	al, byte ptr [BX]
 1040  22 C0		      C 	and	al, al
 1042  74 05		      C 	jz	short @f
 1044  53		      C 	push	bx
 1045  E8 FF3E		      C 	call	putlu
 1048  5B		      C 	pop	bx
 1049			      C @@:
 1049  A0 27DF R	      C 	mov	al, byte ptr [u.uno]    
 104C  88 07		      C   	mov	byte ptr [BX], al ; put the process number
			      C 				  ; in the wait channel
			      C 		; mov (r0)+,r1 / put number of wait channel in r1
			      C 		; movb wlist(r1),-(sp) / put old process number in there,
			      C 				     ; / on the stack
			      C        		; movb u.uno,wlist(r1) / put process number of process
			      C 				     ; / to put to sleep in there
 104E  FF 36 26C2 R	      C         push    word ptr [cdev]
			      C 		; mov cdev,-(sp) / nothing happened in isintr so
 1052  E8 FE9D		      C 	call	swap
			      C        		; jsr r0,swap / swap out process that needs to sleep
 1055  8F 06 26C2 R	      C         pop     word ptr [cdev]
			      C 		; mov (sp)+,cdev / restore device
 1059  E8 0005		      C 	call	isintr
			      C 	; 27/01/2022
 105C  74 16		      C 	jz	short @f
			      C 	; 22/09/2013
			      C 	;jnz	sysret         
			      C 		; jsr r0,isintr / check for interrupt of new process
			      C                	; br 2f 	/ yes, return to new user
			      C 		; movb (sp)+,r1 / no, r1 = old process number that was 
			      C 		; 		/ originally on the wait channel
			      C        		; beq 1f        / if 0 branch
			      C   		; mov $runq+4,r2 / r2 points to lowest priority queue
			      C        		; mov $300,*$ps / processor priority = 6
			      C 		; jsr r0,putlu / create link to old process number
			      C        		; clr *$ps   / clear the status; process priority = 0
			      C      ;1:
			      C 	;retn
			      C 		; rts r0 / return
			      C      ;2:
 105E  E9 F2AF		      C         jmp	sysret
			      C 		; jmp sysret / return to user
			      C 
 1061			      C isintr:
			      C 	; 28/01/2022
			      C 	; 27/01/2022
			      C 	; 30/05/2014
			      C 	; 20/10/2013
			      C 	; 22/09/2013
			      C 	; 03/09/2013
			      C 	; 16/05/2013 tty/video_page switching
			      C 	; 09/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; (Process/task switching and quit routine by using
			      C 	; Retro UNIX 8086 v1 keyboard interrupt output.))
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	; 'isintr' checks if user interrupt request is enabled
			      C 	;  and there is a 'quit' request by user;
			      C 	;  otherwise, 'isintr' will return with zf=1 that means
			      C 	;  "nothing to do". (20/10/2013)
			      C 	;
			      C 
			      C 	; 28/01/2022
			      C 	; (retro unix 8086 v1 isintr procedure checks ctrl+brk
			      C 	;  key status; if it is set, [u.ttyp] check is not needed)
			      C 	; (([u.ttyp] is last read tty number, [u.ttyp+1] is
			      C 	;	last written tty number for process [u.uno]))
			      C 	; ((if [u.uno] is not reading from or wtiting to
			      C 	;	current tty [ptty], ctrlbrk interrupt handler
			      C 	;	will not set [u.quit] to 0FFFFh))
			      C 	; 20/10/2013
			      C 	;cmp 	word ptr [u.ttyp], 0 ; has process got a tty ?
			      C 	;jna	short isintr2 ; retn
			      C 	; 03/09/2013
			      C 	; (nothing to do)
			      C 	;retn
			      C 
			      C 	; 22/09/2013
 1061  83 3E 27D4 R 00	      C 	cmp	word ptr [u.intr], 0
 1066  76 0C		      C 	jna	short isintr2 ; retn
			      C 	; 30/05/2014
 1068  50		      C 	push	ax 
 1069  A1 27D6 R	      C 	mov	ax, word ptr [u.quit]
			      C 	; 28/01/2022
			      C 	;or	ax, ax ; 0 ?
			      C 	;jz	short isintr1 ; zf = 1
 106C  83 F8 FE		      C 	cmp	ax, 0FFFEh    ; 'ctrl + brk' check
 106F  77 02		      C 	ja	short isintr1 ; 0FFFFh, zf = 0
 1071  33 C0		      C 	xor	ax, ax ; zf = 1
 1073			      C isintr1:
 1073  58		      C 	pop	ax
 1074			      C isintr2: ; 22/09/2013
			      C 	; zf=1 -> nothing to do
 1074			      C @@:	; 27/01/2022 (sleep return)
 1074  C3		      C 	retn
			      C 
			      C 	; UNIX v1 original 'isintr' routine... 
			      C        	;mov     r1,-(sp)  / put number of wait channel on the stack
			      C        	;mov     r2,-(sp)  / save r2
			      C        	;mov     u.ttyp,r1 / r1 = pointer to buffer of process control
			      C         ;                  / typewriter
			      C        	;beq     1f / if 0, do nothing except skip return
			      C        	;movb    6(r1),r1 / put interrupt char in the tty buffer in r1
			      C        	;beq     1f       / if its 0 do nothing except skip return
			      C        	;cmp     r1,$177  / is interrupt char = delete?
			      C        	;bne     3f       / no, so it must be a quit (fs)
			      C        	;tst     u.intr   / yes, value of u.intr determines handling
			      C         ;                 / of interrupts
			      C        	;bne     2f       / if not 0, 2f. If zero do nothing.
			      C      ;1:
			      C        	;tst     (r0)+    / bump r0 past system return (skip)
			      C      ;4:
			      C        	;mov     (sp)+,r2 / restore r1 and r2
			      C        	;mov     (sp)+,r1
			      C        	;rts     r0
			      C      ;3: / interrupt char = quit (fs)
			      C        	;tst     u.quit / value of u.quit determines handling of quits
			      C        	;beq     1b / u.quit = 0 means do nothing
			      C      ;2: / get here because either u.intr <> 0 or u.qult <> O
			      C        	;mov     $tty+6,r1 / move pointer to tty block into r1
			      C      ;1: / find process control tty entry in tty block
			      C        	;cmp     (r1),u.ttyp / is this the process control tty buffer?
			      C        	;beq     1f    / block found go to 1f
			      C        	;add     $8,r1 / look at next tty block
			      C        	;cmp     r1,$tty+[ntty*8]+6 / are we at end of tty blocks
			      C        	;blo     1b    / no
			      C        	;br      4b    / no process control tty found so go to 4b
			      C      ;1:
			      C        	;mov     $240,*$ps / set processor priority to 5
			      C        	;movb    -3(r1),0f / load getc call argument; character llst
			      C         ;                  / identifier
			      C        	;inc     0f / increment
			      C      ;1:
			      C        	;jsr     r0,getc; 0:.. / erase output char list for control
			      C         ;        br 4b / process tty. This prevents a line of stuff
			      C         ;              / being typed out after you hit the interrupt
			      C         ;              / key
			      C        	;br      1b
			      C 
				include u5.asm ; u5.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U5.ASM (include u5.asm) //// UNIX v1 -> u5.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 22/04/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 04/04/2022
			      C ; 26/02/2022
			      C ; 03/02/2022
			      C ; 30/01/2022 compact kernel (moving buffers to bss section)
			      C ; 27/01/2022
			      C ; 07/08/2013 iget
			      C ; 01/08/2013 alloc, (free3, free), itrunc
			      C ; 31/07/2013 u.rw -> rw, setimod, mget
			      C ; 28/07/2013 iget, icalc (u.rw)
			      C ; 21/07/2013 alloc, free, imap
			      C ; 18/07/2013 iget
			      C ; 17/07/2013 icalc (inode->i), iget
			      C ; 09/07/2013 iget (cdev=1)
			      C ; 29/04/2013 access modification
			      C ; 26/04/2013 imap, iget (mntd->mdev)
			      C ; 24/04/2013 access
			      C ; 23/04/2013 itrunc
			      C ; 07/04/2013 alloc, free, iget, icalc
			      C ; 02/04/2013 alloc
			      C ; 01/04/2013 alloc
			      C ; 24/03/2013 mget
			      C ; 22/03/2013 mget
			      C ; 11/03/2013
			      C 
 1075			      C mget:
			      C 	; 22/04/2022
			      C 	; 27/01/2022
			      C 	; 31/07/2013
			      C 	; 24/03/2013
			      C         ; 22/03/2013
			      C 	; Get existing or (allocate) a new disk block for file
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    u.fofp (file offset pointer)
			      C 	;    inode 
			      C 	;    u.off (file offset)
			      C 	; OUTPUTS ->
			      C 	;    r1 (physical block number)
			      C 	;    r2, r3, r5 (internal)
			      C 	;
			      C 	; ((AX = R1)) output
			      C 	;    (Retro UNIX Prototype : 05/03/2013 - 14/11/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, BX, CX, SI, DI, BP))  
			      C 
			      C 		; mov *u.fofp,mq / file offset in mq
			      C 		; clr ac / later to be high sig
			      C 		; mov $-8,lsh   / divide ac/mq by 256.
			      C 		; mov mq,r2
			      C 		; bit $10000,i.flgs / lg/sm is this a large or small file
			      C 		; bne 4f / branch for large file
 1075			      C mget_0:	
 1075  8B 36 27B6 R	      C         mov     si, word ptr [u.fofp] ; 24/03/2013
 1079  8A 5C 01		      C         mov     bl, byte ptr [SI]+1
 107C  32 FF		      C         xor     bh, bh
			      C         ; BX = r2
 107E  F7 06 25EA R 1000      C         test 	word ptr [i.flgs], 4096 ; 1000h
			      C 			  	     ; is this a large or small file
 1084  75 4A		      C 	jnz 	short mget_5 ; 4f ; large file
			      C 
 1086  F6 C3 F0		      C         test    bl, 0F0h ; !0Fh                    
			      C 		; bit $!17,r2
 1089  75 19		      C 	jnz 	short mget_2
			      C 		; bne 3f / branch if r2 greater than or equal to 16
 108B  80 E3 0E		      C         and     bl, 0Eh  
			      C 		; bic $!16,r2 / clear all bits but bits 1,2,3
 108E  8B 87 25F0 R	      C 	mov 	ax, word ptr i.dskp[BX] ; AX = R1, physical block number
			      C 		; mov i.dskp(r2),r1 / r1 has physical block number
 1092  0B C0		      C 	or 	ax, ax
 1094  75 0D		      C 	jnz 	short mget_1 ; if physical block number is zero
			      C 		; bne 2f / if physical block num is zero then need a new block
			      C 		       ; / for file
 1096  E8 0071		      C 	call 	alloc
			      C 		; jsr r0,alloc / allocate a new block
			      C          ; AX (r1) = Physical block number
 1099  89 87 25F0 R	      C 	mov 	word ptr i.dskp[BX], ax
			      C 		; mov r1,i.dskp(r2) / physical block number stored in i-node
 109D  E8 01AB		      C 	call 	setimod	
			      C 		; jsr r0,setimod / set inode modified byte (imod)
 10A0  E8 FF10		      C 	call	clear
			      C 		; jsr r0,clear / zero out disk/drum block just allocated
 10A3			      C mget_1: ; 2:
			      C         ; AX (r1) = Physical block number
 10A3  C3		      C 	retn 
			      C 		; rts r0
 10A4			      C mget_2: ; 3: / adding on block which changes small file to a large file
 10A4  E8 0063		      C 	call 	alloc
			      C 		; jsr r0,alloc / allocate a new block for this file;
			      C 	                     ; / block number in r1
			      C         ; AX (r1) = Physical block number
 10A7  E8 086A		      C 	call 	wslot
			      C 		; jsr r0,wslot / set up I/O buffer for write, r5 points to 
			      C 			     ; / first data word in buffer
			      C         ; AX (r1) = Physical block number
 10AA  B9 0008		      C 	mov 	cx, 8  ; R3, transfer old physical block pointers
			      C 		   ; into new indirect block area for the new
			      C 		   ; large file		
 10AD  8B FB		      C 	mov 	di, bx ; r5
 10AF  BE 25F0 R	      C 	mov 	si, offset i.dskp 
			      C 		; mov $8.,r3 / next 6 instructions transfer old physical 
			      C 			   ; / block pointers
			      C 		; mov $i.dskp,r2 / into new indirect block for the new 
			      C 			  ; / large file
			      C 	; 22/04/2022
 10B2  50		      C 	push	ax ; * ; bugfix
			      C 	;	
 10B3  33 C0		      C 	xor 	ax, ax ; mov ax, 0
 10B5			      C mget_3: ;1:
 10B5  A5		      C 	movsw
			      C 		; mov (r2),(r5)+
 10B6  89 44 FE		      C 	mov 	word ptr [SI]-2, ax
			      C 		; clr (r2)+
 10B9  E2 FA		      C 	loop	mget_3 ; 1b
			      C 		; dec r3
			      C 		; bgt 1b
			      C 
 10BB  B1 F8		      C 	mov 	cl, 256-8
			      C 		; mov $256.-8.,r3 / clear rest of data buffer
 10BD			      C mget_4:	; 1
 10BD  F3/ AB		      C 	rep 	stosw
			      C 		; clr (r5)+
			      C 		; dec r3
			      C 		; bgt 1b
			      C 	; 22/04/2022
			      C 	;pop	ax ; * ; bugfix
			      C 	; 24/03/2013
			      C         ; AX (r1) = Physical block number
 10BF  E8 085D		      C 	call	dskwr
			      C 		; jsr r0,dskwr / write new indirect block on disk
			      C 	; AX (r1) = Physical block number
			      C 	;mov 	word ptr [i.dskp], ax
			      C 		; mov r1,i.dskp / put pointer to indirect block in i-node
			      C 	; 22/04/2022
 10C2  8F 06 25F0 R	      C 	pop	word ptr [i.dskp] ; * ; bugfix
			      C 	; 27/01/2022
 10C6  80 0E 25EB R 10	      C 	or	byte ptr [i.flgs+1], 10h
			      C 	;or 	word ptr [i.flgs], 4096 ; 1000h
			      C 		; bis $10000,i.flgs / set large file bit 
			      C 				  ; / in i.flgs word of i-node
 10CB  E8 017D		      C 	call	setimod
			      C 		; jsr r0,setimod / set i-node modified flag
 10CE  EB A5		      C 	jmp 	short mget_0	
			      C 		; br mget
			      C 
 10D0			      C mget_5:  ; 4 ; large file
			      C 	; 05/03/2013 (UNIXCOPY.ASM)
			      C         ;mov    ax, bx  ; ax <= 255 for this file (UNIX v1, RUFS) system
			      C         ;mov    cx, 256 ; 01/03/2013 no need a division here
			      C 	;xor 	dx, dx  ; 01/03/2013 no need a division here
			      C 	;div 	cx	; 01/03/2013 no need a division here
			      C 	;and 	bx, 1FEh ; zero all bit but 1,2,3,4,5,6,7,8
			      C 		         ; gives offset in indirect block
			      C 	;push 	bx	; R2	
			      C 	;mov 	bx, ax  ; calculate offset in i-node for pointer
			      C 		        ; to proper indirect block
			      C 	;and 	bx, 0Eh
			      C 	;mov 	ax, word ptr i.dskp[BX] ; R1
			      C 		; mov $-8,lsh / divide byte number by 256.
			      C 		; bic $!776,r2 / zero all bits but 1,2,3,4,5,6,7,8; gives offset
			      C 		;              / in indirect block
			      C 		; mov r2,-(sp) / save on stack (*)
			      C 		; mov mq,r2 / calculate offset in i-node for pointer to proper
			      C        		;           / indirect block
			      C 		; bic $!16,r2
 10D0  80 E3 FE		      C         and     bl, 0FEh ; bh = 0
 10D3  53		      C         push    bx  ; i-node pointer offset in indirect block  (*) 
			      C         ; 01/03/2013 Max. possible BX (offset) value is 127 (65535/512)
			      C 	; 	     for this file system (offset 128 to 255 not in use)
			      C 	; There is always 1 indirect block for this file system
 10D4  A1 25F0 R	      C 	mov 	ax, word ptr [i.dskp] ; i.dskp[0]
			      C 		; mov i.dskp(r2),r1
 10D7  0B C0		      C 	or 	ax, ax ; R1
 10D9  75 0C		      C 	jnz 	short mget_6 ; 2f
			      C 		; bne 2f / if no indirect block exists
 10DB  E8 002C		      C 	call 	alloc
			      C 		; jsr r0,alloc / allocate a new block
			      C 	; mov 	 word ptr i.dskp[BX], ax  ; R1, block number
 10DE  A3 25F0 R	      C 	mov 	word ptr [i.dskp], ax  ; 03/03/2013
			      C 		; mov r1,i.dskp(r2) / put block number of new block in i-node
 10E1  E8 0167		      C 	call 	setimod
			      C 		; jsr r0,setimod / set i-node modified byte
			      C 	; AX = new block number
 10E4  E8 FECC		      C 	call 	clear
			      C 		; jsr r0,clear / clear new block
 10E7			      C mget_6: ;2
			      C 	; 05/03/2013
			      C 	; AX = r1, physical block number (of indirect block)
 10E7  E8 07FF		      C 	call 	dskrd ; read indirect block
			      C 		; jsr r0,dskrd / read in indirect block
 10EA  5A		      C 	pop 	dx  ; R2, get offset (*)
			      C 		; mov (sp)+,r2 / get offset
			      C 	; AX = r1, physical block number (of indirect block)
 10EB  50		      C 	push 	ax ; ** ; 24/03/2013
			      C 		; mov r1,-(sp) / save block number of indirect block on stack
			      C 	; BX (r5) = pointer to buffer (indirect block)
 10EC  03 DA		      C 	add 	bx, dx ; / r5 points to first word in indirect block, r2
			      C 		; add r5,r2 / r5 points to first word in indirect block, r2
			      C 	                  ; / points to location of inter
 10EE  8B 07		      C 	mov 	ax, word ptr [BX] ; put physical block no of block
			      C 			      ; in file sought in R1 (AX)
			      C 		; mov (r2),r1 / put physical block no of block in file
			      C 	               	    ; / sought in r1
 10F0  0B C0		      C 	or 	ax, ax
 10F2  75 14		      C         jnz 	short mget_7 ; 2f
			      C 		; bne 2f / if no block exists 
 10F4  E8 0013		      C 	call 	alloc
			      C 		; jsr r0,alloc / allocate a new block
 10F7  89 07		      C 	mov 	word ptr [BX], ax ; R1
			      C 		; mov r1,(r2) / put new block number into proper location in
			      C 	                    ; / indirect block
 10F9  5A		      C 	pop	dx ; ** ; 24/03/2013
			      C 		; mov (sp)+,r1 / get block number of indirect block
 10FA  52		      C 	push 	dx ; ** ; 31/07/2013
 10FB  50		      C 	push	ax ; * ; 24/03/2013, 31/07/2013 (new block number)
 10FC  8B C2		      C 	mov	ax, dx ; 24/03/2013
			      C 		; mov (r2),-(sp) / save block number of new block
			      C 	; AX (r1) = physical block number (of indirect block)
 10FE  E8 0813		      C 	call 	wslot
			      C 		; jsr r0,wslot
			      C         ; AX (r1) = physical block number
			      C 	; BX (r5) = pointer to buffer (indirect block)
 1101  E8 081B		      C 	call 	dskwr
			      C 	; AX = r1 = physical block number (of indirect block)
			      C 		; jsr r0,dskwr / write newly modified indirect block 
			      C 			     ; / back out on disk
 1104  58		      C 	pop	ax ; *  ; 31/07/2013
			      C 		; mov (sp),r1 / restore block number of new block	
			      C 	; AX (r1) = physical block number of new block
 1105  E8 FEAB		      C 	call 	clear
			      C 		; jsr r0,clear / clear new block	
 1108			      C mget_7: ; 2
 1108  5A		      C 	pop 	dx ; **
			      C 		; tst (sp)+ / bump stack pointer
			      C 	; AX (r1) = Block number of new block
 1109  C3		      C 	retn
			      C 		; rts r0
			      C 
 110A			      C alloc:
			      C 	; 30/01/2022
			      C 	; 01/08/2013
			      C 	; 21/07/2013
			      C 	; 02/04/2013
			      C 	; 01/04/2013
			      C 	;
			      C 	; get a free block and 
			      C 	; set the corresponding bit in the free storage map
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    cdev (current device)
			      C 	;    r2 
			      C 	;    r3
			      C 	; OUTPUTS ->
			      C 	;    r1 (physical block number of block assigned)
			      C 	;    smod, mmod, systm (super block), mount (mountable super block)	
			      C 	;
			      C 	; ((AX = R1)) output
			      C 	;    (Retro UNIX Prototype : 14/11/2012 - 21/07/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, CX))  
			      C 
			      C 		;mov r2,-(sp) / save r2, r3 on stack
			      C 		;mov r3,-(sp)
			      C 	;push 	cx
 110A  53		      C 	push 	bx ; R2
			      C 	;push 	dx ; R3
			      C 	;mov 	bx, offset systm ; SuperBlock
			      C 	; 30/01/2022 
 110B  BB 2A2A R	      C 	mov	bx, systm ; mov bx, offset s ; 21/07/2013
			      C 		; mov $systm,r2 / start of inode and free storage map for drum
 110E  80 3E 26C2 R 00	      C 	cmp 	byte ptr [cdev], 0
			      C 		; tst cdev
 1113  76 03		      C 	jna	short alloc_1
			      C 		; beq 1f / drum is device
			      C 	; 30/01/2022
 1115  BB 2C2E R	      C 	mov	bx, mount ; ;mov bx, offset mount
			      C 		; mov $mount,r2 / disk or tape is device, start of inode and
			      C 			      ; / free storage map
 1118			      C alloc_1: ; 1
 1118  8B 07		      C         mov     ax, word ptr [BX]
			      C 		; mov (r2)+,r1 / first word contains number of bytes in free
			      C 			     ; / storage map
 111A  D1 E0		      C 	shl	ax, 1
			      C 		; asl r1 / multiply r1 by eight gives 
			      C 		; number of blocks in device
 111C  D1 E0		      C 	shl	ax, 1
			      C 		; asl r1
 111E  D1 E0		      C 	shl 	ax, 1
			      C 		; asl r1
 1120  8B C8		      C 	mov	cx, ax 
			      C 	;; push cx ;; 01/08/2013
			      C 		; mov r1,-(sp) / save # of blocks in device on stack
 1122  33 C0		      C 	xor 	ax, ax ; 0
			      C 		; clr r1 / r1 contains bit count of free storage map
 1124			      C alloc_2: ; 1
 1124  43		      C 	inc 	bx ; 18/8/2012
 1125  43		      C 	inc 	bx ; 
 1126  8B 17		      C 	mov 	dx, word ptr [BX]
			      C 		; mov (r2)+,r3 / word of free storage map in r3 
 1128  0B D2		      C 	or 	dx, dx
 112A  75 0A		      C 	jnz 	short alloc_3 ; 1f
			      C 		; bne 1f / branch if any free blocks in this word	
 112C  83 C0 10		      C 	add 	ax, 16
			      C 		; add $16.,r1
 112F  3B C1		      C 	cmp 	ax, cx    
			      C 		; cmp r1 ,(sp) / have we examined all free storage bytes
 1131  72 F1		      C 	jb 	short alloc_2
			      C 		; blo 1b
 1133  E9 EF8A		      C         jmp     panic 
			      C 		; jmp panic / found no free storage
 1136			      C alloc_3: ; 1
 1136  D1 EA		      C 	shr	dx, 1
			      C 		; asr r3 / find a free block
 1138  72 03		      C 	jc	short alloc_4 ; 1f
			      C 		; bcs 1f / branch when free block found; bit for block k
			      C 		       ; / is in byte k/8 / in bit k (mod 8)
 113A  40		      C 	inc	ax
			      C 		; inc r1 / increment bit count in bit k (mod8)
 113B  EB F9		      C 	jmp 	short alloc_3
			      C 		; br 1b
 113D			      C alloc_4: ; 1:
			      C 	;; pop cx ;; 01/08/2013
			      C 		; tst (sp)+ / bump sp
			      C 	; 02/04/2013 
 113D  E8 001E		      C 	call	free3
			      C 		; jsr r0,3f / have found a free block
			      C 	; 21/8/2012
 1140  F7 D2		      C 	not 	dx ; masking bit is '0' and others are '1'
 1142  21 17		      C 	and	word ptr [BX], dx   ;; 0 -> allocated 
			      C 		; bic r3,(r2) / set bit for this block 
			      C 		            ; / i.e. assign block
			      C 		; br 2f
 1144  EB 06		      C 	jmp 	short alloc_5
			      C 
 1146			      C free:
			      C 	; 30/01/2022
			      C 	; 01/08/2013
			      C 	; 21/07/2013
			      C 	; 07/04/2013
			      C       	; 
			      C 	; calculates byte address and bit position for given block number
			      C 	; then sets the corresponding bit in the free storage map
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - block number for a block structured device
			      C 	;    cdev - current device 
			      C 	; OUTPUTS ->
			      C 	;    free storage map is updated
			      C 	;    smod is incremented if cdev is root device (fixed disk)
			      C 	;    mmod is incremented if cdev is a removable disk 	
			      C 	;
			      C 	;  (Retro UNIX Prototype : 01/12/2012, UNIXCOPY.ASM)
			      C         ;  ((Modified registers: DX, CX))  
			      C 
			      C 		;mov r2,-(sp) / save r2, r3
			      C 		;mov r3,-(sp)
			      C 	;push 	cx
 1146  53		      C 	push 	bx ; R2
			      C 	;push 	dx ; R3 
			      C 
 1147  E8 0014		      C         call    free3
			      C 	     	; jsr r0,3f  / set up bit mask and word no. 
			      C 				 ; / in free storage map for block
 114A  09 17		      C 	or 	word ptr [BX], dx  
			      C 	  	; bis r3, (r2) / set free storage block bit;
			      C 			    ;  / indicates free block	
			      C 	; 0 -> allocated, 1 -> free
			      C 
 114C			      C alloc_5:
			      C 	; 07/04/2013
 114C			      C free_1: ; 2:
			      C 	;pop 	dx
			      C 		; mov (sp)+,r3 / restore r2, r3
 114C  5B		      C 	pop	bx
			      C 		; mov (sp)+,r2
			      C 	; pop	cx
 114D  80 3E 26C2 R 00	      C 	cmp 	byte ptr [cdev], 0
			      C 		; tst cdev / cdev = 0, block structured, drum; 
			      C 			 ; / cdev = 1, mountable device
 1152  77 05		      C 	ja	short alloc_6 ; 1f
			      C 		; bne 1f
			      C 	;mov	byte ptr [smod], 1
 1154  FE 06 26F5 R	      C 	inc 	byte ptr [smod]
			      C 		; incb smod / set super block modified for drum
			      C 	; AX (r1) = block number
 1158  C3		      C 	retn
			      C 		; rts r0
 1159			      C free_2:
 1159			      C alloc_6: ; 1:
			      C 	;mov	byte ptr [mmod], 1
 1159  FE 06 26F6 R	      C 	inc 	byte ptr [mmod]
			      C 		; incb	mmod 
			      C 		  ; / set super block modified for mountable device
			      C 	; AX (r1) = block number
 115D  C3		      C 	retn	
			      C 		; rts r0
 115E			      C free3:
			      C 	; 30/01/2022
			      C 	; 01/08/2013
			      C 	; 02/04/2013
			      C 	;
			      C 	; free3 is called from 'alloc' and 'free' procedures
			      C 	; 
 115E			      C alloc_free_3: ; 3
 115E  BA 0001		      C 	mov 	dx, 1
 1161  8B C8		      C 	mov 	cx, ax
			      C 		; mov r1,r2 / block number, k, = 1		
 1163  83 E1 0F		      C 	and 	cx, 0Fh  ; 0Fh <-- (k) mod 16
			      C 		; bic $!7,r2 / clear all bits but 0,1,2; r2 = (k) mod (8)
 1166  74 02		      C 	jz 	short @f
			      C 		; bisb 2f(r2),r3 / use mask to set bit in r3 corresponding to
			      C 			       ; / (k) mod 8
 1168  D3 E2		      C 	shl 	dx, cl
 116A			      C @@:
 116A  8B D8		      C 	mov 	bx, ax
			      C 		; mov r1,r2 / divide block number by 16
 116C  D1 EB		      C 	shr 	bx, 1
			      C 		; asr r2
 116E  D1 EB		      C 	shr 	bx, 1
			      C 		; asr r2
 1170  D1 EB		      C 	shr 	bx, 1
			      C 		; asr r2
 1172  D1 EB		      C 	shr 	bx, 1
			      C 		; asr r2
			      C 		; bcc 1f / branch if bit 3 in r1 was 0 i.e., 
			      C 		       ; / bit for block is in lower half of word
			      C 		; swab r3 / swap bytes in r3; bit in upper half of word in free
			      C 		        ; / storage map
 1174			      C alloc_free_4: ; 1
 1174  D1 E3		      C 	shl 	bx, 1 ; 21/8/2012
			      C 		; asl r2 / multiply block number by 2; r2 = k/8
			      C 	;add 	bx, offset systm+2 ; SuperBlock+2
			      C 	; 30/01/2022
 1176  81 C3 2A2C R	      C 	add	bx, systm+2 ; add bx, offset s + 2 ; 21/07/2013
			      C 		; add $systm+2,r2 / address of word of free storage map for drum
			      C 	    		        ; / with block bit in it 	
 117A  80 3E 26C2 R 00	      C 	cmp	byte ptr [cdev], 0
			      C 		; tst cdev
 117F  76 04		      C 	jna	short alloc_free_5
			      C 		; beq 1f / cdev = 0 indicates device is drum
			      C 	;add	bx, offset mount - offset systm
			      C 	; 30/01/2022
 1181  81 C3 052C	      C 	add	bx, sb1 - sb0 ; add bx, offset sb1 - offset sb0 ; 21/07/2013
			      C 		; add $mount-systm,r2 / address of word of free storage map for
			      C 				    ; / mountable device with bit of block to be
			      C 				    ; / freed
 1185			      C alloc_free_5: ; 1 
 1185  C3		      C 	retn
			      C 		; rts r0 / return to 'free'
			      C 	      ; 2
			      C 	        ; .byte	1,2,4,10,20,40,100,200 / masks for bits 0,...,7
			      C 	
 1186			      C iget:
			      C 	; 07/08/2013
			      C 	; 31/07/2013
			      C         ; 28/07/2013
			      C 	; 18/07/2013
			      C 	; 17/07/2013
			      C 	; 09/07/2013 (cdev,mdev)
			      C         ; 26/04/2013 (mdev)
			      C         ; 07/04/2013
			      C 	; 
			      C 	; get a new i-node whose i-number in r1 and whose device is in cdev
			      C 	;
			      C 	; ('iget' returns current i-number in r1, if input value of r1 is 0)
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    ii - current i-number, rootdir
			      C 	;    cdev - new i-node device
			      C 	;    idev - current i-node device
			      C 	;    imod - current i-node modified flag
			      C 	;    mnti - cross device file i-number
			      C 	;    r1 - i-numbe rof new i-node
			      C 	;    mntd - mountable device number		
			      C 	; 	 
			      C 	; OUTPUTS ->
			      C 	;    cdev, idev, imod, ii, r1
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	;
			      C 	;  (Retro UNIX Prototype : 14/07/2012 - 18/11/2012, UNIXCOPY.ASM)
			      C         ;  ((Modified registers: DX, CX, BX, SI, DI, BP))  
			      C 
 1186  8A 16 26C2 R	      C 	mov	dl, byte ptr [cdev] ; 18/07/2013
 118A  8A 36 26C0 R	      C 	mov	dh, byte ptr [idev] ; 07/08/2013
			      C 	;
 118E  3B 06 26BE R	      C 	cmp 	ax, word ptr [ii]
			      C 		; cmp r1,ii / r1 = i-number of current file
 1192  75 04		      C 	jne 	short iget_1
			      C 		; bne 1f
 1194  38 F2		      C 	cmp	dl, dh
			      C 		; cmp idev,cdev
			      C 			  ; / is device number of i-node = current device
 1196  74 4E		      C         je      short @f
			      C 		; beq 2f
 1198			      C iget_1: ; 1:
 1198  32 DB		      C 	xor	bl, bl
 119A  38 1E 26F4 R	      C 	cmp	byte ptr [imod], bl ; 0	
			      C 		; tstb imod / has i-node of current file
			      C 			  ; / been modified i.e., imod set
 119E  76 1C		      C 	jna	short iget_2
			      C 		; beq 1f
 11A0  88 1E 26F4 R	      C 	mov	byte ptr [imod], bl ; 0
			      C 		;  clrb	imod / if it has, 
			      C 			   ; / we must write the new i-node out on disk
 11A4  50		      C 	push	ax
			      C 		; mov r1,-(sp)
			      C 	;mov	dl, byte ptr [cdev]
 11A5  52		      C 	push	dx
			      C 		; mov cdev,-(sp)
 11A6  A1 26BE R	      C 	mov	ax, word ptr [ii]
			      C 		; mov ii,r1
			      C 	;mov	dh, byte ptr [idev]
 11A9  88 36 26C2 R	      C 	mov	byte ptr [cdev], dh
			      C 		; mov idev,cdev
 11AD  FE C3		      C 	inc	bl ; 1
			      C 	; 31/07/2013
 11AF  88 1E 26F8 R	      C 	mov     byte ptr [rw], bl ; 1 == write 
			      C 	;;28/07/2013 rw -> u.rw
			      C         ;;mov     byte ptr [u.rw], bl ; 1 == write
 11B3  E8 0031		      C 	call	icalc
			      C 		; jsr r0,icalc; 1
 11B6  5A		      C 	pop	dx
 11B7  88 16 26C2 R	      C 	mov	byte ptr [cdev], dl
			      C 		; mov (sp)+,cdev
 11BB  58		      C 	pop	ax
			      C 		; mov (sp)+,r1
 11BC			      C iget_2: ; 1:
 11BC  23 C0		      C 	and	ax, ax
			      C 		; tst r1 / is new i-number non zero
 11BE  74 23		      C 	jz	short iget_4 ; 2f
			      C 		; beq 2f / branch if r1=0
			      C 
			      C 	; mov 	dl, byte ptr [cdev]
 11C0  0A D2		      C 	or	dl, dl
			      C 		; tst cdev / is the current device number non zero
			      C 			 ; / (i.e., device =/ drum)
 11C2  75 0F		      C 	jnz	short iget_3 ;  1f
			      C 		; bne 1f / branch 1f cdev =/ 0  ;; (cdev != 0)
 11C4  3B 06 26EC R	      C 	cmp	ax, word ptr [mnti]			
			      C 		; cmp r1,mnti / mnti is the i-number of the cross device
			      C 			    ; / file (root directory of mounted device)
 11C8  75 09		      C 	jne	short iget_3 ; 1f
			      C 		; bne 1f
			      C         ;mov    bl, byte ptr [mntd]
 11CA  FE C2		      C 	inc	dl ; move dl, 1 ; 17/07/2013
 11CC  88 16 26C2 R	      C         mov	byte ptr [cdev], dl ; 17/07/2013 - 09/07/2013
			      C 		; mov mntd,cdev / make mounted device the current device
 11D0  A1 26F0 R	      C 	mov	ax, word ptr [rootdir]
			      C 		; mov rootdir,r1
 11D3			      C iget_3: ; 1:
 11D3  A3 26BE R	      C 	mov	word ptr [ii], ax
			      C 		; mov r1,ii
 11D6  88 16 26C0 R	      C 	mov	byte ptr [idev], dl ; cdev
			      C 		; mov cdev,idev
 11DA  32 DB		      C 	xor	bl, bl
			      C         ; 31/07/2013
 11DC  88 1E 26F8 R	      C 	mov     byte ptr [rw], bl ; 0 == read 
			      C 	;;28/07/2013 rw -> u.rw       
			      C         ;;mov     byte ptr [u.rw], bl ; 0 = read
 11E0  E8 0004		      C 	call	icalc
			      C 		; jsr r0,icalc; 0 / read in i-node ii
 11E3			      C iget_4: ; 2:
 11E3  A1 26BE R	      C 	mov	ax, word ptr [ii]
			      C 		; mov ii,r1
 11E6			      C @@:
 11E6  C3		      C 	retn
			      C 		; rts r0
			      C 
 11E7			      C icalc:
			      C 	; 04/04/2022 (47->31)
			      C 	;	(Inode Table/List Address modification)
			      C 	; 27/01/2022
			      C 	; 31/07/2013
			      C         ; 28/07/2013
			      C 	; 17/07/2013
			      C 	; 07/04/2013
			      C 	;
			      C 	; calculate physical block number from i-number then
			      C 	; read or write that block
			      C 	;
			      C 	; 'icalc' is called from 'iget'
			      C 	;
			      C 	; for original unix v1:
			      C 	; / i-node i is located in block (i+31.)/16. and begins 32.*
			      C        	; / (i+31)mod16 bytes from its start
			      C 	;
			      C 	; for retro unix 8086 v1:
			      C 	;  i-node is located in block (i+47)/16 and
			      C 	;  begins 32*(i+47) mod 16 bytes from its start
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - i-number of i-node
			      C 	; 	 
			      C 	; OUTPUTS ->
			      C 	;    inode r/w
			      C 	;
			      C 	; ((AX = R1)) input
			      C 	;
			      C 	;  (Retro UNIX Prototype : 14/07/2012 - 18/11/2012, UNIXCOPY.ASM)
			      C         ;  ((Modified registers: AX, DX, CX, BX, SI, DI, BP))  
			      C 	;
			      C 
			      C 	;add	ax, 47	; add 47 to inode number
			      C 	; 04/04/2022
 11E7  83 C0 1F		      C 	add	ax, 31
			      C 		; add $31.,r1 / add 31. to i-number
 11EA  50		      C 	push	ax
			      C 		; mov r1,-(sp) / save i+31. on stack
 11EB  D1 E8		      C 	shr 	ax, 1
			      C 		; asr r1 / divide by 16.
 11ED  D1 E8		      C 	shr 	ax, 1
			      C 		; asr r1
 11EF  D1 E8		      C 	shr 	ax, 1
			      C 		; asr r1
 11F1  D1 E8		      C 	shr	ax, 1
			      C 		; asr r1 / r1 contains block number of block
			      C 		       ; / in which i-node exists
 11F3  E8 06F3		      C 	call	dskrd
			      C 		; jsr r0,dskrd / read in block containing i-node i.
			      C 	; 31/07/2013
 11F6  80 3E 26F8 R 00	      C         cmp     byte ptr [rw], 0 ; Retro Unix 8086 v1 feature !
			      C 	;; 28/07/2013 rw -> u.rw
			      C         ;;cmp	byte ptr [u.rw], 0 ; Retro Unix 8086 v1 feature !
			      C 		; tst (r0)
 11FB  76 03		      C 	jna	short icalc_1
			      C 		; beq 1f / branch to wslot when argument
			      C 		       ; / in icalc call = 1
			      C 	; AX = r1  = block number
 11FD  E8 0714		      C 	call	wslot
			      C 		; jsr r0,wslot / set up data buffer for write
			      C 			     ; / (will be same buffer as dskrd got)
			      C 	; BX = r5 points to first word in data area for this block
 1200			      C icalc_1: ; 1:
 1200  5A		      C 	pop	dx 
 1201  83 E2 0F		      C 	and 	dx, 0Fh ; (i+31) mod 16 (2022) ; (i+47) mod 16
			      C 		; bic $!17,(sp) / zero all but last 4 bits; 
			      C 			      ; / gives (i+31.) mod 16
 1204  D1 E2		      C 	shl 	dx, 1
 1206  D1 E2		      C 	shl 	dx, 1
 1208  D1 E2		      C 	shl 	dx, 1
 120A  D1 E2		      C 	shl 	dx, 1
 120C  D1 E2		      C 	shl 	dx, 1 
			      C 	; DX = 32 * ((i+31) mod 16) ; 32 * ((i+47) mod 16)
 120E  8B F3		      C 	mov	si, bx  ; bx points 1st word of the buffer
 1210  03 F2		      C 	add	si, dx  ; dx is inode offset in the buffer
			      C           	; SI (r5) points to first word in i-node i.	
			      C 		; mov (sp)+,mq / calculate offset in data buffer; 
			      C 			     ; / 32.*(i+31.)mod16
			      C 		; mov $5,lsh / for i-node i.
			      C 		; add mq,r5 / r5 points to first word in i-node i.
			      C 	;mov	di, offset inode
 1212  BF 25EA R	      C 	mov 	di, offset i ; 17/07/2013
			      C 		; mov $inode,r1 / inode is address of first word 
			      C 			      ; / of current i-node
 1215  B9 0010		      C 	mov 	cx, 16 ; CX = r3
			      C 		; mov $16.,r3
			      C        ; 31/07/2013
 1218  38 2E 26F8 R	      C   	cmp     byte ptr [rw], ch ; 0  ;; Retro Unix 8086 v1 feature !
			      C        ;;28/07/2013 rw -> u.rw                 
			      C        ;;cmp	byte ptr [u.rw], ch ; 0  ;; Retro Unix 8086 v1 feature !
			      C 		; tst (r0)+ / branch to 2f when argument in icalc call = 0
 121C  76 07		      C 	jna	short icalc_3
			      C 		; beq 2f / r0 now contains proper return address 
			      C 		       ; / for rts r0
 121E			      C icalc_2: ; 1:
 121E  87 F7		      C 	xchg 	si, di
			      C 	; over write old i-node (in buffer to be written)
 1220  F3/ A5		      C 	rep 	movsw
			      C 		; mov (r1)+,(r5)+ / over write old i-node
			      C 		; dec r3
			      C 		; bgt 1b
			      C 	;call	dskwr
			      C 	;	; jsr r0,dskwr / write inode out on device
			      C 	;retn
			      C 	;	; rts r0
			      C 	; 27/01/2022
 1222  E9 06FA		      C 	jmp	dskwr
			      C 
 1225			      C icalc_3: ; 2:
			      C 	; copy new i-node into inode area of (core) memory
 1225  F3/ A5		      C 	rep 	movsw
			      C 		; mov (r5)+,(r1)+ / read new i-node into 
			      C 		                ; / "inode" area of core
			      C 		; dec r3
			      C 		; bgt 2b
 1227  C3		      C 	retn
			      C 		; rts r0
			      C 
 1228			      C access:
			      C 	; 27/01/2022
			      C 	; 29/04/2013 (AX register preserved)
			      C 	; 24/04/2013
			      C 	; check whether user is owner of file or user has read or write
			      C 	; permission (based on i.flgs).
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - i-number of file
			      C 	;    u.uid
			      C 	; arg0 -> (owner flag mask)	 		
			      C 	;     Retro UNIX 8086 v1 feature -> owner flag mask in DL (DX) 	 
			      C 	; OUTPUTS ->
			      C 	;    inode (or jump to error)
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	;
			      C         ;  ((Modified registers: CX, BX, SI, DI, BP))  
			      C 	;
 1228  52		      C 	push	dx  ; flags
 1229  E8 FF5A		      C 	call	iget
			      C 		; jsr r0,iget / read in i-node for current directory
			      C 			    ; / (i-number passed in r1)
 122C  8B 0E 25EA R	      C 	mov	cx, word ptr [i.flgs]
			      C 		; mov i.flgs,r2
 1230  5A		      C 	pop	dx
 1231  8A 36 27DC R	      C 	mov	dh, byte ptr [u.uid_] ; 29/04/2013 al -> dh
 1235  3A 36 25ED R	      C 	cmp	dh, byte ptr [i.uid] ; 29/04/2013
			      C 		; cmpb i.uid,u.uid / is user same as owner of file
 1239  75 04		      C 	jne	short access_1
			      C 		; bne 1f / no, then branch
 123B  D0 E9		      C 	shr	cl, 1
			      C 		; asrb r2 / shift owner read write bits into non owner
			      C 		        ; / read/write bits
 123D  D0 E9		      C 	shr	cl, 1
			      C 		; asrb r2
 123F			      C access_1: ; 1:
 123F  22 CA		      C 	and	cl, dl
			      C 		; bit r2,(r0)+ / test read-write flags against argument
			      C 			     ; / in access call
 1241  75 07		      C 	jnz	short access_2
			      C 		; bne 1f
 1243  0A F6		      C 	or	dh, dh ; 29/04/2013 al -> dh
			      C 		; tstb u.uid
			      C 	;jnz	error
			      C 		; beq 1f
			      C 		; jmp error
			      C 	; 27/01/2022
 1245  74 03		      C 	jz	short access_2
 1247  E9 F0A9		      C 	jmp	error
 124A			      C access_2: ; 1:
 124A  C3		      C 	retn
			      C 		; rts r0
			      C 
 124B			      C setimod:
			      C 	; 31/07/2013
			      C 	; 09/04/2013
			      C 	;
			      C 	; 'setimod' sets byte at location 'imod' to 1; thus indicating that 
			      C 	; the inode has been modified. Also puts the time of modification
			      C 	; into the inode.
			      C 	;
			      C 	;  (Retro UNIX Prototype : 14/07/2012 - 23/02/2013, UNIXCOPY.ASM)
			      C         ;  ((Modified registers: DX, CX, BX)) 
			      C 	;
			      C 	
			      C 	; push 	dx
 124B  50		      C 	push	ax
			      C 
 124C  C6 06 26F4 R 01	      C 	mov 	byte ptr [imod], 1
			      C 		; movb $1,imod / set current i-node modified bytes
			      C 	; Erdogan Tan 14-7-2012
 1251  E8 11BA		      C 	call 	epoch
			      C 		 ; mov s.time,i.mtim 
			      C 			    ; / put present time into file modified time
			      C 		 ; mov s.time+2,i.mtim+2
			      C 
 1254  A3 2604 R	      C 	mov 	word ptr [i.mtim], ax
 1257  89 16 2606 R	      C 	mov 	word ptr [i.mtim]+2, dx
			      C 	
			      C 	; Retro UNIX 8086 v1 modification !
 125B  8B 0E 2600 R	      C 	mov	cx, word ptr [i.ctim]
 125F  8B 1E 2602 R	      C 	mov	bx, word ptr [i.ctim]+2
			      C 
 1263  85 CB		      C 	test	cx, bx
 1265  75 07		      C 	jnz	short @f
			      C 
 1267  A3 2600 R	      C 	mov 	word ptr [i.ctim], ax
 126A  89 16 2602 R	      C 	mov 	word ptr [i.ctim]+2, dx 
 126E			      C @@: ; 31/07/2013
 126E  58		      C 	pop	ax
			      C 	;pop	dx
			      C 	
 126F  C3		      C 	retn
			      C 		; rts r0
			      C 
 1270			      C itrunc:
			      C 	; 03/02/2022
			      C 	; 27/01/2022
			      C 	; 01/08/2013
			      C 	; 23/04/2013
			      C 	;
			      C 	; 'itrunc' truncates a file whose i-number is given in r1
			      C 	;  to zero length.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - i-number of i-node
			      C 	;    i.dskp - pointer to contents or indirect block in an i-node
			      C 	;    i.flgs - large file flag		
			      C 	;    i.size - size of file	
			      C 	; 	 
			      C 	; OUTPUTS ->
			      C 	;    i.flgs - large file flag is cleared
			      C 	;    i.size - set to 0	
			      C 	;    i.dskp .. i.dskp+16 - entire list is cleared
			      C 	;    setimod - set to indicate i-node has been modified
			      C 	;    r1 - i-number of i-node  					
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	;
			      C 	;  (Retro UNIX Prototype : 01/12/2012 - 10/03/2013, UNIXCOPY.ASM)
			      C         ;  ((Modified registers: DX, CX, BX, SI, DI, BP))  
			      C 
 1270  E8 FF13		      C 	call	iget
			      C 		; jsr r0,iget
 1273  BE 25F0 R	      C 	mov	si, offset i.dskp
			      C 		; mov $i.dskp,r2 / address of block pointers in r2
 1276			      C itrunc_1: ; 1:
 1276  AD		      C 	lodsw
			      C 		; mov (r2)+,r1 / move physical block number into r1
 1277  0B C0		      C 	or 	ax, ax
 1279  74 27		      C 	jz	short itrunc_5
			      C 		; beq 5f
 127B  56		      C 	push	si
			      C 		; mov r2,-(sp)
			      C 	; 03/02/2022
 127C  F6 06 25EB R 10	      C 	test	byte ptr [i.flgs+1], 10h
			      C 	;test	word ptr [i.flgs], 1000h
			      C 		; bit $10000,i.flgs / test large file bit?
 1281  74 1B		      C 	jz	short itrunc_4
			      C 		; beq 4f / if clear, branch
 1283  50		      C 	push	ax
			      C 		; mov r1,-(sp) / save block number of indirect block
 1284  E8 0662		      C 	call	dskrd
			      C 		; jsr r0,dskrd / read in block, 1st data word 
			      C 			     ; / pointed to by r5
			      C 	; BX = r5 = Buffer data address (the 1st word)
 1287  B9 0100		      C 	mov	cx, 256
			      C 		; mov $256.,r3 / move word count into r3
 128A  8B F3		      C 	mov	si, bx
 128C			      C itrunc_2: ; 2:
 128C  AD		      C 	lodsw
			      C 		; mov (r5)+,r1 / put 1st data word in r1; 
			      C 			     ; / physical block number
 128D  23 C0		      C 	and	ax, ax
 128F  74 05		      C 	jz	short itrunc_3
			      C 		; beq 3f / branch if zero
 1291  51		      C 	push	cx
			      C 		; mov r3,-(sp) / save r3, r5 on stack
			      C 	;push	si
			      C 		; mov r5,-(sp)
 1292  E8 FEB1		      C 	call	free
			      C 		; jsr r0,free / free block in free storage map
			      C 	;pop	si
			      C 		; mov(sp)+,r5
 1295  59		      C 	pop	cx
			      C 		; mov (sp)+,r3
 1296			      C itrunc_3: ; 3:
 1296  E2 F4		      C 	loop	itrunc_2
			      C 		; dec r3 / decrement word count
			      C 		; bgt 2b / branch if positive
 1298  58		      C 	pop	ax
			      C 		; mov (sp)+,r1 / put physical block number of 
			      C 			     ; / indirect block
			      C 	; 01/08/2013
			      C 	;and	word ptr [i.flgs], 0EFFFh ; 1110111111111111b
			      C 	; 27/01/2022
 1299  80 26 25EB R EF	      C 	and	byte ptr [i.flgs+1], 0EFh
 129E			      C itrunc_4: ; 4:
 129E  E8 FEA5		      C 	call	free
			      C 		; jsr r0,free / free indirect block
 12A1  5E		      C 	pop	si
			      C 		; mov (sp)+,r2
 12A2			      C itrunc_5: ; 5:
 12A2  81 FE 2600 R	      C 	cmp	si, offset i.dskp+16
			      C 		; cmp r2,$i.dskp+16.
 12A6  72 CE		      C 	jb	short itrunc_1	
			      C 		; bne 1b / branch until all i.dskp entries check
			      C 	; 27/01/2022
			      C 	;and	byte ptr [i.flgs+1], 0EFh
			      C 	; 01/08/2013
			      C 	;and	word ptr [i.flgs], 0EFFFh ; 1110111111111111b
			      C 		; bic $10000,i.flgs / clear large file bit
 12A8  BF 25F0 R	      C 	mov	di, offset i.dskp
 12AB  B9 0008		      C 	mov	cx, 8
 12AE  33 C0		      C 	xor 	ax, ax
 12B0  A3 25EE R	      C 	mov	word ptr [i.size_], ax ; 0
			      C 		; clr i.size / zero file size
 12B3  F3/ AB		      C 	rep	stosw
			      C 		; jsr r0,copyz; i.dskp; i.dskp+16. 
			      C 			   ; / zero block pointers
 12B5  E8 FF93		      C 	call	setimod
			      C 		; jsr r0,setimod / set i-node modified flag
 12B8  A1 26BE R	      C 	mov	ax, word ptr [ii]
			      C 		; mov ii,r1
 12BB  C3		      C 	retn
			      C 		; rts r0
			      C 
 12BC			      C imap:
			      C 	; 26/02/2022
			      C 	; 30/01/2022
			      C 	; 26/04/2013
			      C 	; 'imap' finds the byte in core (superblock) containing
			      C 	; allocation bit for an i-node whose number in r1.
			      C 	;
			      C 	; INPUTS ->
			      C 	;    r1 - contains an i-number
			      C 	;    fsp - start of table containing open files
			      C 	;
			      C 	; OUTPUTS ->
			      C 	;    r2 - byte address of byte with the allocation bit
			      C 	;    mq - a mask to locate the bit position.	
			      C 	;	  (a 1 is in calculated bit posisiton)
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	; ((DL/DX = MQ)) output
			      C 	; ((BX = R2)) output
			      C 	;
			      C 	;    (Retro UNIX Prototype : 02/12/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, CX, BX, SI))  
			      C 	;
			      C 		; / get the byte that has the allocation bit for 
			      C 		; / the i-number contained in r1
			      C 	;mov	dx, 1
 12BC  B2 01		      C 	mov	dl, 1
			      C 		; mov $1,mq / put 1 in the mq
 12BE  8B D8		      C 	mov	bx, ax
			      C 		; mov r1,r2 / r2 now has i-number whose byte
			      C  		          ; / in the map we must find
 12C0  83 EB 29		      C 	sub	bx, 41
			      C 		; sub $41.,r2 / r2 has i-41
 12C3  8A CB		      C 	mov	cl, bl
			      C 		; mov r2,r3 / r3 has i-41
 12C5  80 E1 07		      C 	and	cl, 7
			      C 		; bic $!7,r3 / r3 has (i-41) mod 8 to get 
			      C 			   ; / the bit position
 12C8  74 02		      C 	jz	short @f
			      C 	;shl	dx, cl
 12CA  D2 E2		      C 	shl	dl, cl
			      C 		; mov r3,lsh / move the 1 over (i-41) mod 8 positions
 12CC			      C @@:			   ; / to the left to mask the correct bit
 12CC  D1 EB		      C 	shr	bx, 1
			      C 		; asr r2
 12CE  D1 EB		      C 	shr	bx, 1
			      C 		; asr r2
 12D0  D1 EB		      C 	shr	bx, 1		
			      C 		; asr r2 / r2 has (i-41) base 8 of the byte number
			      C 		       ; / from the start of the map
			      C 		; mov r2,-(sp) / put (i-41) base 8 on the stack
			      C 	;mov	si, offset systm
			      C 	; 30/01/2022
 12D2  BE 2A2A R	      C 	mov	si, systm ; mov	si, offset s ; 21/07/2013	
			      C 		; mov $systm,r2 / r2 points to the in-core image of
			      C 				; / the super block for drum
			      C 	;cmp	word ptr [cdev], 0
 12D5  80 3E 26C2 R 00	      C 	cmp	byte ptr [cdev], 0
			      C 		; tst cdev / is the device the disk
 12DA  76 04		      C 	jna	short @f
			      C 		; beq 1f / yes
			      C 	;add	si, offset mount - offset systm
			      C 	; 30/01/2022
 12DC  81 C6 0534	      C 	add	si, mount-systm 
			      C 	;add	si, offset mount - offset s ; 21/07/2013
			      C 		; add $mount-systm,r2 / for mounted device,
			      C 			; / r2 points to 1st word of its super block
 12E0			      C @@: ; 1:
 12E0  03 1C		      C 	add	bx, word ptr [SI] ;; add free map size to si
			      C 		; add (r2)+,(sp) / get byte address of allocation bit
 12E2  03 DE		      C 	add	bx, si
			      C         	; add (sp)+,r2 / ?
 12E4  83 C3 04		      C 	add	bx, 4 ;; inode map offset in superblock
			      C 		      ;; (2 + free map size + 2)
			      C 		; add $2,r2 / ?
			      C 
			      C 	; 26/02/2022 (Retro UNIX 8086 v1, 2022 modification)
 12E7  81 C6 2BB5 R	      C 	add	si, systm.time-1 ; last byte of the inode table in sb
 12EB  3B F3		      C 	cmp	si, bx	; cf will be 1
			      C 			; if inode number overs inode count
 12ED  73 03		      C 	jnb	short @f
 12EF  E9 F001		      C 	jmp	error
 12F2			      C @@:
			      C  	; DL/DX (MQ) has a 1 in the calculated bit position
			      C         ; BX (R2) has byte address of the byte with allocation bit
 12F2  C3		      C 	retn
			      C 		; rts r0
			      C 
				include u6.asm ; u6.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U6.ASM (include u6.asm) //// UNIX v1 -> u6.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 19/07/2022 ]  ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 19/07/2022
			      C ; ('dskw' file offset bugfix. File offset will not be increased
			      C ;	  when disk block/sector write operation fails.)	
			      C ; 13/06/2022
			      C ; 03/02/2022
			      C ; 27/01/2022
			      C ; 16/07/2015
			      C ; 23/07/2014 rtty
			      C ; 07/07/2014 wtty
			      C ; 27/06/2014 wtty (putc)
			      C ; 19/06/2014 rtty, wtty
			      C ; 03/06/2014 (rtty/wtty check is ok)
			      C ; 02/06/2014 wtty
			      C ; 26/05/2014 wtty
			      C ; 15/04/2014 rtty, wtty ('getc' and 'putc' error return modifications)
			      C ; 14/04/2014 wtty
			      C ; 23/02/2014 rtty
			      C ; 01/02/2014 rtty
			      C ; 13/01/2014 rtty, wtty
			      C ; 06/12/2013 rtty, wtty (major modification: p.ttyc, u.ttyp)
			      C ; 10/10/2013 rtty, wtty (tty read lock & tty write lock are removed)
			      C ; 05/10/2013 rtty, wtty
			      C ; 29/09/2013 rtty
			      C ; 20/09/2013 rtty & passc (tty read lock)
			      C ;	     wtty & cpass (tty write lock), dskw, rmem, wmem
			      C ; 13/09/2013 rtty
			      C ; 26/08/2013 wtty
			      C ; 14/08/2013 rtty, rcvt, wtty, xmtt, cpass
			      C ; 03/08/2013 dskr (namei_r), dskw (mkdir_w)
			      C ; 01/08/2013 dskw (mkdir_w)
			      C ; 31/07/2013 dskr (namei_r), writei
			      C ; 29/07/2013 rtty, idle
			      C ; 28/07/2013 rtty, rcvt, wtty, u.namei_r
			      C ; 26/07/2013 readi
			      C ; 16/07/2013 rtty, rcvt, chk_ttyp, rmem, wmem modifications
			      C ; 27/05/2013 chk_ttyp
			      C ; 21/05/2013 chk_ttyp, chk_com_o
			      C ; 20/05/2013 chk_ttyp
			      C ; 15/05/2013 rcvt, xmtt, COM1, COM2
			      C ; 26/04/2013 readi, writei modifications
			      C ; 14/03/2013 -> writei
			      C ; 12/03/2013 -> writei, u.segment
			      C 
			      C ; 11/03/2013
			      C 
 12F3			      C readi:
			      C 	; 27/01/2022
			      C 	; 31/07/2013
			      C 	; 26/07/2013 (namei_r check in 'dskr')
			      C 	; 15/05/2013 COM1, COM2 (serial ports) modification
			      C 	; 26/04/2013 (modification depending on 'dsrkd' modification)
			      C 	; 12/03/2013 -> u.segment
			      C 	; 11/03/2013
			      C 	; Reads from an inode whose number in R1
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - inode number
			      C 	;    u.count - byte count user desires
			      C 	;    u.base - points to user buffer
			      C 	;    u.fofp - points to word with current file offset
			      C 	; OUTPUTS ->
			      C 	;    u.count - cleared
			      C 	;    u.nread - accumulates total bytes passed back
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	;    (Retro UNIX Prototype : 01/03/2013 - 14/12/2012, UNIXCOPY.ASM)
			      C         ;    ((Modified registers: DX, BX, CX, SI, DI, BP))  
			      C 
 12F3  33 D2		      C 	xor	dx, dx ; 0
 12F5  89 16 27C2 R	      C 	mov 	word ptr [u.nread], dx ; 0
			      C 		 ; clr u.nread / accumulates number of bytes transmitted
 12F9  39 16 27C0 R	      C 	cmp 	word ptr [u.count], dx ; 0
			      C 	         ; tst u.count / is number of bytes to be read greater than 0
 12FD  77 01		      C 	ja 	short @f ; 1f
			      C 		 ; bgt 1f / yes, branch
 12FF  C3		      C 	retn
			      C 		 ; rts r0 / no, nothing to read; return to caller
 1300			      C @@: ; 1:
			      C 	         ; mov r1,-(sp) / save i-number on stack
 1300  83 F8 28		      C 	cmp	ax, 40
			      C 		 ; cmp r1,$40. / want to read a special file 
			      C 		 ;             / (i-nodes 1,...,40 are for special files)
			      C         ;ja	dskr 
			      C 		 ; ble 1f / yes, branch
			      C 		 ; jmp dskr / no, jmp to dskr; 
			      C 		 ;         / read file with i-node number (r1)
			      C 		 ;    / starting at byte ((u.fofp)), read in u.count bytes
			      C 	; 27/01/2022
 1303  76 03		      C 	jna	short @f
 1305  E9 0081		      C 	jmp	dskr
 1308			      C @@:
 1308  50		      C 	push	ax ; because subroutines will jump to 'ret_'
 1309			      C @@: ; 1:
 1309  8B D8		      C 	mov	bx, ax
 130B  D1 E3		      C 	shl	bx, 1
			      C 		 ; asl r1 / multiply inode number by 2
 130D  81 C3 1311 R	      C 	add	bx, offset @f - 2
 1311  FF 27		      C 	jmp	word ptr [BX]	
			      C 		 ; jmp *1f-2(r1)
 1313			      C @@: ; 1:
 1313  1339 R		      C 	dw 	offset rtty ; tty, AX = 1 (runix)
			      C 		 ;rtty / tty; r1=2
			      C 		 ;rppt / ppt; r1=4
 1315  1375 R		      C 	dw	offset rmem ; mem, AX = 2 (runix)
			      C 		 ;rmem / mem; r1=6
			      C 		 ;rrf0 / rf0
			      C 		 ;rrk0 / rk0
			      C 		 ;rtap / tap0
			      C 		 ;rtap / tap1
			      C 		 ;rtap / tap2
			      C 		 ;rtap / tap3
			      C 		 ;rtap / tap4
			      C 		 ;rtap / tap5
			      C 		 ;rtap / tap6
			      C 		 ;rtap / tap7
 1317  182A R		      C 	dw 	offset rfd ; fd0, AX = 3 (runix only)
 1319  182A R		      C 	dw 	offset rfd ; fd1, AX = 4 (runix only)
 131B  1836 R		      C 	dw 	offset rhd ; hd0, AX = 5 (runix only)
 131D  1836 R		      C 	dw 	offset rhd ; hd1, AX = 6 (runix only)	
 131F  1836 R		      C 	dw 	offset rhd ; hd2, AX = 7 (runix only)
 1321  1836 R		      C 	dw 	offset rhd ; hd3, AX = 8 (runix only)	
 1323  1386 R		      C 	dw	offset rlpr ; lpr, AX = 9 (invalid, write only device !?)
 1325  1371 R		      C 	dw	offset rcvt ; tty0, AX = 10 (runix)	  
			      C 		 ;rcvt / tty0
 1327  1371 R		      C 	dw	offset rcvt ; tty1, AX = 11 (runix)	  
			      C 		 ;rcvt / tty1
 1329  1371 R		      C 	dw	offset rcvt ; tty2, AX = 12 (runix)	  
			      C 		 ;rcvt / tty2
 132B  1371 R		      C 	dw	offset rcvt ; tty3, AX = 13 (runix)	  
			      C 		 ;rcvt / tty3
 132D  1371 R		      C 	dw	offset rcvt ; tty4, AX = 14 (runix)	  
			      C 		 ;rcvt / tty4
 132F  1371 R		      C 	dw	offset rcvt ; tty5, AX = 15 (runix)	  
			      C 		 ;rcvt / tty5
 1331  1371 R		      C 	dw	offset rcvt ; tty6, AX = 16 (runix)	  
			      C 		 ;rcvt / tty6
 1333  1371 R		      C 	dw	offset rcvt ; tty7, AX = 17 (runix)	  
			      C 		 ;rcvt / tty7
 1335  1371 R		      C 	dw	offset rcvt ; COM1, AX = 18 (runix only)	  
			      C 		 ;rcrd / crd
 1337  1371 R		      C 	dw	offset rcvt ; COM2, AX = 19 (runix only)
			      C 
 1339			      C rtty: ; / read from console tty
			      C 	; 16/07/2015 (Only 1 byte is read, by ignoring byte count!)
			      C 	;  	     WHAT FOR: Every character from Keyboard input 
			      C 	;	     must be written immediate on video page (screen)
			      C 	;	     when it is required.	
			      C 	; 19/06/2014
			      C 	; 15/04/2014 ('getc' error return modifications)
			      C 	; 23/02/2014
			      C 	; 01/02/2014
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 10/10/2013
			      C 	; 05/10/2013
			      C 	; 29/09/2013
			      C 	; 20/09/2013 (tty read lock)
			      C 	; 13/09/2013
			      C 	; 14/08/2013
			      C 	; 28/07/2013 u.ttyn
			      C 	; 16/07/2013
			      C 	; 16/07/2013 'getc' modifications
			      C 	; 20/05/2013
			      C 	; 15/05/2013 'getc' error return for serial ports
			      C 	; 14/05/2013 'getc' modifications instead of INT 16h
			      C 	; 11/03/2013
			      C 	; Console tty buffer is PC keyboard buffer
			      C 	; and keyboard-keystroke handling is different than original
			      C 	; unix (PDP-11) here. TTY/Keyboard procedures here are changed
			      C 	; according to IBM PC compatible ROM BIOS keyboard functions. 
			      C 	;
			      C 	; 06/12/2013
 1339  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 133D  32 FF		      C 	xor	bh, bh
 133F  8A 87 2669 R	      C 	mov	al, byte ptr [BX]+p.ttyc-1 ; current/console tty
 1343			      C rttys:
			      C 		; mov tty+[8*ntty]-8+6,r5 / r5 is the address of the 4th word of
			      C 	               ; / of the control and status block
			      C 		; tst 2(r5) / for the console tty; this word points to the console
			      C 		       ; / tty buffer
			      C 	; 28/07/2013
 1343  A2 27E2 R	      C 	mov 	byte ptr [u.ttyn], al
			      C 	; 06/12/2013
			      C 	;; 13/01/2014
			      C 	;;cmp	al, 7
			      C 	;;ja	short rtty_nc
 1346  FE C0		      C 	inc	al
 1348  A2 27C6 R	      C 	mov	byte ptr [u.ttyp], al ; tty number + 1
 134B			      C rtty_nc: ; 01/02/2014
			      C 	; 29/09/2013
 134B  B9 000A		      C 	mov	cx, 10
 134E			      C @@: 	; 01/02/2014
 134E  51		      C 	push 	cx ; 29/09/2013
			      C 	; byte ptr [u.ttyn] = tty number (0 to 9) 
 134F  B0 01		      C 	mov 	al, 1
 1351  E8 0770		      C 	call 	getc
 1354  59		      C 	pop 	cx ; 29/09/2013	
			      C 	; 28/07/2013
			      C 	; byte ptr [u.ttyn] = tty number
			      C 	;; 15/04/2014
			      C 	;;jc	error  ; 15/05/2013 (COM1 or COM2 serial port error)
			      C 	 ;mov 	ah, 01h  ; Test for available key, ZF=1 if none, ZF=0 and
			      C 	 ;int 	16h 	 ; AX contains next key code if key available.
 1355  75 10		      C 	jnz	short @f
			      C 		; bne 1f / 2nd word of console tty buffer contains number
			      C 	               ; / of chars. Is this number non-zero?
			      C 	;dec	cx
			      C 	;jnz	short rtty_idle
 1357  E2 09		      C 	loop	rtty_idle ; 01/02/2014
			      C 	; 05/10/2013
 1359  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn]
			      C 	; 29/09/2013
 135D  E8 FCCE		      C 	call	sleep
			      C 		; jsr r0,canon; ttych / if 0, call 'canon' to get a line
			      C                 ;           / (120 chars.)
			      C 	;byte ptr [u.ttyn] = tty number (0 to 9) 
 1360  EB E9		      C 	jmp	short rtty_nc ; 01/02/2014
			      C 
 1362			      C rtty_idle:
			      C 	; 16/07/2013
			      C 	;; mov	cx, word ptr [s.idlet]+2 ;; 29/07/2013
 1362  E8 FC45		      C 	call 	idle
			      C 	; 29/09/2013
 1365  EB E7		      C 	jmp	short @b ; 01/02/2014
			      C ;1:
			      C ;rtty_nc:
			      C 	;mov	al, 1
			      C 	;call	getc
			      C 	 ;mov 	ah, 01h  ; Test for available key, ZF=1 if none, ZF=0 and
			      C 	 ;int 	16h 	 ; AX contains next key code if key available.
			      C         ;jz   	short ret_
			      C 		; tst 2(r5) / is the number of characters zero
			      C 		; beq ret1 / yes, return to caller via 'ret1'
			      C 		; movb *4(r5),r1 / no, put character in r1
			      C 		; inc 4(r5) / 3rd word of console tty buffer points to byte which
			      C 		          ; / contains the next char.
			      C 		; dec 2(r5) / decrement the character count
 1367			      C @@:
 1367  32 C0		      C 	xor 	al, al
 1369  E8 0758		      C 	call 	getc
			      C 	;; 23/07/0014
			      C 	;;jc	error ; 15/05/2013 (COM1 or COM2 serial port error)
			      C 	; AL = ascii code of the character
			      C 	  ;xor 	ah, ah
			      C 	  ;int	16h
			      C 	;
 136C  E8 0065		      C 	call	passc
			      C 		; jsr r0,passc / move the character to core (user)
			      C 	;; 16/07/2015
			      C 	; 19/06/2014
			      C 	;;jnz	short rtty_nc
			      C 	; 23/07/2014
			      C 	;jmp	short ret_
 136F  58		      C 	pop	ax
 1370  C3		      C 	retn 
			      C 
			      C ;ret1:
			      C 		; jmp ret / return to caller via 'ret'
			      C 
 1371			      C rcvt:   ; < receive/read character from tty >
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 28/07/2013 al = tty number (ah -> al)
			      C 	; 16/07/2013 rttys
			      C 	; 21/05/2013 owner checking for COM/serial ports
			      C 	; 15/05/2013
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; In original UNIX v1, 'rcvt' routine 
			      C 	;		(exactly different than this one)
			      C 	;	was in 'u9.s' file.
			      C 	;
 1371  2C 0A		      C 	sub 	al, 10
			      C 	; AL = tty number (0 to 9), (COM1=8, COM2=9)
			      C 	; 16/07/2013
			      C 	; 21/05/2013
 1373  EB CE		      C         jmp     short rttys
			      C       
			      C ;rppt: / read paper tape
			      C ;	jsr	r0,pptic / gets next character in clist for ppt input and
			      C ;			 / places
			      C ;		br ret / it in r1; if there 1s no problem with reader, it
			      C ;		       / also enables read bit in prs
			      C ;	jsr	r0,passc / place character in users buffer area
			      C ;	br	rppt
			      C 
 1375			      C rmem: ; / transfer characters from memory to a user area of core
			      C 	; 16/07/2015
 1375  8B 36 27B6 R	      C         mov     si, word ptr [u.fofp]
 1379			      C @@:
 1379  8B 1C		      C         mov     bx, word ptr [SI]        
			      C 	        ; mov *u.fofp,r1 / save file offset which points to the char
			      C 		               ; / to be transferred to user
 137B  FF 04		      C         inc     word ptr [SI] ; 16/07/2013
			      C 		; inc *u.fofp / increment file offset to point to 'next' 
			      C 			    ; / char in memory file
 137D  8A 07		      C 	mov	al, byte ptr [BX]
			      C 		; movb (r1),r1 / get character from memory file, 
			      C 		             ; / put it in r1
 137F  E8 0052		      C 	call	passc        ; jsr r0,passc / move this character to 
			      C 			     ;  / the next byte of the users core area
			      C 	; 20/09/2013
			      C 	;jmp	short @b	
			      C 		; br rmem / continue
 1382  75 F5		      C 	jnz	short @b
			      C 	;
 1384			      C ret_:
 1384  58		      C 	pop	ax
 1385  C3		      C 	retn
			      C 
 1386			      C rlpr:
			      C ;1:
			      C ;rcrd:
 1386  E9 EF6A		      C 	jmp	error
			      C 		;jmp	error / see 'error' routine
			      C 
 1389			      C dskr:
			      C 	; 19/07/2022
			      C 	; 03/08/2013
			      C 	; 31/07/2013
			      C 	; 26/07/2013 (namei_r check)
 1389  50		      C 	push	ax ; 26/04/2013
			      C 		; mov (sp),r1 / i-number in r1
			      C 	; AX = i-number
 138A  E8 FDF9		      C 	call	iget
			      C 		; jsr r0,iget / get i-node (r1) into i-node section of core
 138D  8B 16 25EE R	      C         mov     dx, word ptr [i.size_]
			      C 		; mov i.size,r2 / file size in bytes in r2
 1391  8B 1E 27B6 R	      C 	mov	bx, word ptr [u.fofp]
 1395  2B 17		      C 	sub	dx, word ptr [BX]
			      C 		; sub *u.fofp,r2 / subtract file offset
 1397  76 EB		      C         jna     short ret_ 
			      C 		; blos ret
 1399  3B 16 27C0 R	      C         cmp     dx, word ptr [u.count] 
			      C 		; cmp r2,u.count / are enough bytes left in file 
			      C 			       ; / to carry out read
 139D  73 04		      C 	jnb	short dskr_1
			      C 		; bhis 1f
 139F  89 16 27C0 R	      C 	mov	word ptr [u.count], dx
			      C 		; mov r2,u.count / no, just read to end of file
 13A3			      C dskr_1: ; 1:
			      C 	; AX = i-number
 13A3  E8 FCCF		      C 	call	mget
			      C 		; jsr r0,mget / returns physical block number of block 
			      C 			    ; / in file where offset points
			      C 	; AX = physical block number
 13A6  E8 0540		      C 	call	dskrd
			      C 		; jsr r0,dskrd / read in block, r5 points to 
			      C 			     ; / 1st word of data in buffer
			      C 	; BX (r5) = system (I/O) buffer address
 13A9  E8 01AF		      C 	call	sioreg	; 19/07/2022
			      C 		; jsr r0,sioreg
			      C 	
			      C 	; 19/07/2022
			      C 	;xchg	si, di
			      C 
			      C 	; 19/07/2022
			      C 	; SI = file offset pointer
			      C 	; AX = file (user data) offset
 13AC  01 0C		      C 	add	word ptr [SI], cx 
			      C 			; new file offset (old offset + byte count)
			      C 	;
 13AE  8B F7		      C 	mov	si, di	; sector (I/O) buffer offset
 13B0  8B F8		      C 	mov	di, ax
			      C 		
			      C 	; DI = file (user data) offset
			      C 	; SI = sector (I/O) buffer offset
			      C 	; CX = byte count
			      C 	; 03/08/2013
 13B2  80 3E 26F9 R 00	      C 	cmp	byte ptr [namei_r], 0
			      C 	;;28/07/2013 namei_r -> u.namei_r
			      C 	; 26/07/2013
			      C 	;;dec	byte ptr [u.namei_r] ; the caller is 'namei' sign (=1)
 13B7  76 04		      C 	jna	short dskr_2 	   ; zf=0 -> the caller is 'namei'
 13B9  F3/ A4		      C 	rep	movsb
 13BB  EB 0B		      C 	jmp	short dskr_3
 13BD			      C dskr_2:
			      C 	;;28/07/2013
			      C 	; 26/07/2013	
			      C 	;;inc	byte ptr [u.namei_r] ; (=0)
 13BD  A1 27E0 R	      C         mov     ax, word ptr [u.segmnt] ; Retro Unix 8086 v1 feature only !
 13C0  8E C0		      C 	mov	es, ax ; Retro Unix 8086 v1 feature: ES = user segment !
			      C ; 2:
 13C2  F3/ A4		      C 	rep	movsb
			      C 		; movb (r2)+,(r1)+ / move data from buffer into working core
			      C 		                 ; / starting at u.base
			      C 		; dec r3
			      C 		; bne 2b / branch until proper number of bytes are transferred
 13C4  8C D8		      C 	mov	ax, ds
 13C6  8E C0		      C 	mov	es, ax
 13C8			      C dskr_3:
			      C 	; 03/08/2013
 13C8  58		      C 	pop	ax
 13C9  39 0E 27C0 R	      C 	cmp	word ptr [u.count], cx ; 0
			      C 		; tst u.count / all bytes read off disk
			      C 		; bne dskr
 13CD  77 BA		      C 	ja	short dskr
 13CF  88 0E 26F9 R	      C 	mov	byte ptr [namei_r], cl ; 0
 13D3  C3		      C 	retn
			      C 	;jna	short ret_
			      C 		; br ret
			      C         ;pop	ax ; 26/04/2013 (i-node number)
			      C 	;jmp 	short dskr
			      C 
 13D4			      C passc:
 13D4  8B 1E 27E0 R	      C         mov     bx, word ptr [u.segmnt] ; Retro Unix 8086 v1 feature only !
 13D8  8E C3		      C 	mov	es, bx  ; Retro Unix 8086 v1 feature: ES = user segment !
			      C 
 13DA  8B 1E 27BE R	      C 	mov	bx, word ptr [u.base]
 13DE  26: 88 07	      C 	mov	byte ptr ES:[BX], al 
			      C 		; movb r1,*u.base / move a character to the next byte of the
			      C 		               ; / users buffer
			      C 
 13E1  8C DB		      C 	mov	bx, ds ; Retro Unix 8086 v1 feature: DS = system segment !
 13E3  8E C3		      C 	mov	es, bx ; Retro Unix 8086 v1 feature: ES = system segment !
			      C 
 13E5  FF 06 27BE R	      C 	inc	word ptr [u.base]
			      C 		; inc u.base / increment the pointer to point to 
			      C 			  ; / the next byte in users buffer
 13E9  FF 06 27C2 R	      C 	inc	word ptr [u.nread]
			      C 		; inc u.nread / increment the number of bytes read
 13ED  FF 0E 27C0 R	      C 	dec	word ptr [u.count]
			      C 		; dec u.count / decrement the number of bytes to be read
 13F1			      C @@:
			      C 	; 20/09/2013 (;;)
 13F1  C3		      C 	retn
			      C 	;;jnz	short @f
			      C 		; bne 1f / any more bytes to read?; yes, branch
			      C 	;;pop	ax
			      C 	;;	; mov (sp)+,r0 / no, do a non-local return to the caller of
			      C 		             ; / 'readi' by:
			      C ;;ret_: ;/ (1) pop the return address off the stack into r0
			      C ;;	pop	ax
			      C 		; mov (sp)+,r1 / (2) pop the i-number off the stack into r1
			      C ;;@@: ;1:
			      C 		; clr	*$ps / clear processor status
			      C ;;	retn
			      C 		; rts r0 / return to address currently on top of stack
			      C 
 13F2			      C writei:
			      C 	; 13/06/2022 LPT (/dev/lpr) printing modification
			      C 	; 27/01/2022
			      C 	; 31/07/2013
			      C 	; 15/05/2013 COM1, COM2 (serial ports) modification
			      C 	; 26/04/2013
			      C 	; 14/03/2013 wslot, sioreg
			      C 	; 12/03/2013
			      C 	; Write data to file with inode number in R1
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - inode number
			      C 	;    u.count - byte count to be written
			      C 	;    u.base - points to user buffer
			      C 	;    u.fofp - points to word with current file offset
			      C 	; OUTPUTS ->
			      C 	;    u.count - cleared
			      C 	;    u.nread - accumulates total bytes passed back	
			      C 	; ((AX = R1))
			      C 	;    (Retro UNIX Prototype : 18/11/2012 - 11/11/2012, UNIXCOPY.ASM)
			      C 	;    ((Modified registers: DX, BX, CX, SI, DI, BP)) 	
			      C 
 13F2  33 C9		      C 	xor	cx, cx
 13F4  89 0E 27C2 R	      C 	mov 	word ptr [u.nread], cx  ; 0
			      C 		; clr u.nread / clear the number of bytes transmitted during
			      C 		            ; / read or write calls
 13F8  39 0E 27C0 R	      C 	cmp 	word ptr [u.count], cx
			      C 	;	; tst u.count / test the byte count specified by the user
 13FC  77 08		      C 	ja 	short @f ; 1f
			      C 		; bgt 1f / any bytes to output; yes, branch
			      C 	;retn
			      C 	;	; rts r0 / no, return - no writing to do
			      C 	
			      C 	; 13/06/2022 - 'Get LPT Status' function
 13FE  83 F8 09		      C 	cmp	ax, 9  ; LPR_INODE ; lpt (parallel port printer) ?
 1401  75 EE		      C 	jne	short @b ; retn
 1403  E9 00A9		      C 	jmp	lpr_stat   ; get/read line status
			      C 
 1406			      C @@: ;1:
			      C 		; mov r1 ,-(sp) / save the i-node number on the stack
 1406  83 F8 28		      C 	cmp 	ax, 40
			      C 		; cmp r1,$40.
			      C 		; / does the i-node number indicate a special file?
			      C 	;ja	dskw 
			      C 		; bgt dskw / no, branch to standard file output
			      C 	; 27/01/2022
 1409  76 03		      C 	jna	short @f
 140B  E9 00BE		      C 	jmp	dskw
 140E			      C @@:
 140E  50		      C 	push	ax ; because subroutines will jump to 'ret_'
 140F  8B D8		      C 	mov	bx, ax
 1411  D1 E3		      C 	shl	bx, 1
			      C 		; asl r1 / yes, calculate the index into the special file
 1413  81 C3 1417 R	      C 	add	bx, offset @f - 2
 1417  FF 27		      C 	jmp	word ptr [BX]	
			      C 		; jmp *1f-2(r1)
			      C 		; / jump table and jump to the appropriate routine
 1419			      C @@: ;1:
 1419  143F R		      C 	dw 	offset wtty ; tty, AX = 1 (runix)
			      C 		 ;wtty / tty; r1=2
			      C 		 ;wppt / ppt; r1=4
 141B  1474 R		      C 	dw	offset wmem ; mem, AX = 2 (runix)
			      C 		 ;wmem / mem; r1=6
			      C 		 ;wrf0 / rf0
			      C 		 ;wrk0 / rk0
			      C 		 ;wtap / tap0
			      C 		 ;wtap / tap1
			      C 		 ;wtap / tap2
			      C 		 ;wtap / tap3
			      C 		 ;wtap / tap4
			      C 		 ;wtap / tap5
			      C 		 ;wtap / tap6
			      C 		 ;wtap / tap7
 141D  1830 R		      C 	dw 	offset wfd ; fd0, AX = 3 (runix only)
 141F  1830 R		      C 	dw 	offset wfd ; fd1, AX = 4 (runix only)
 1421  183C R		      C 	dw 	offset whd ; hd0, AX = 5 (runix only)
 1423  183C R		      C 	dw 	offset whd ; hd1, AX = 6 (runix only)	
 1425  183C R		      C 	dw 	offset whd ; hd2, AX = 7 (runix only)
 1427  183C R		      C 	dw 	offset whd ; hd3, AX = 8 (runix only)	
 1429  1485 R		      C 	dw	offset wlpr ; lpr, AX = 9   (runix)
 142B  146E R		      C 	dw	offset xmtt ; tty0, AX = 10 (runix)	  
			      C 		 ;xmtt / tty0
 142D  146E R		      C 	dw	offset xmtt ; tty1, AX = 11 (runix)	  
			      C 		 ;xmtt / tty1
 142F  146E R		      C 	dw	offset xmtt ; tty2, AX = 12 (runix)	  
			      C 		 ;xmtt / tty2
 1431  146E R		      C 	dw	offset xmtt ; tty3, AX = 13 (runix)	  
			      C 		 ;xmtt / tty3
 1433  146E R		      C 	dw	offset xmtt ; tty4, AX = 14 (runix)	  
			      C 		 ;xmtt / tty4
 1435  146E R		      C 	dw	offset xmtt ; tty5, AX = 15 (runix)	  
			      C 		 ;xmtt / tty5
 1437  146E R		      C 	dw	offset xmtt ; tty6, AX = 16 (runix)	  
			      C 		 ;xmtt / tty6
 1439  146E R		      C 	dw	offset xmtt ; tty7, AX = 17 (runix)	  
			      C 		 ;xmtt / tty7
 143B  146E R		      C 	dw	offset xmtt ; COM1, AX = 18 (runix only)	  
			      C 		; / wlpr / lpr
 143D  146E R		      C 	dw	offset xmtt ; COM2, AX = 19 (runix only)	
			      C 
 143F			      C wtty: ; write to console tty (write to screen)
			      C 	; 07/07/2014
			      C 	; 27/06/2014
			      C 	; 19/06/2014
			      C 	; 02/06/2014
			      C 	; 26/05/2014 (putc_eot, putc_n, sleep bugfix)
			      C 	; 15/04/2014 ('putc' error return modification)
			      C 	; 14/04/2014 (serial port modification)
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 10/10/2013
			      C 	; 05/10/2013
			      C 	; 20/09/2013 (tty write lock)
			      C 	; 13/09/2013
			      C 	; 26/08/2013
			      C 	; 14/08/2013
			      C 	; 28/07/2013 u.ttyn
			      C 	; 21/05/2013 owner checking
			      C 	; 15/05/2013 'mov ah, byte ptr [ptty]', wtty_nc
			      C 	; 14/05/2013 'putc' modifications instead of INT 10h
			      C 	; 12/03/2013
			      C 	; Console tty output is on on current video page
			      C 	; Console tty character output procedure is changed here
			      C 	; acconding to IBM PC compatible ROM BIOS video (text mode) functions.
			      C 	;
			      C 	; 06/12/2013
 143F  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 1443  32 FF		      C 	xor	bh, bh
 1445  8A A7 2669 R	      C 	mov	ah, byte ptr [BX]+p.ttyc-1 ; current/console tty
 1449  8A C4		      C 	mov	al, ah ; 07/07/2014
 144B			      C wttys:	;
			      C 	; 10/10/2013
 144B  88 26 27E2 R	      C 	mov 	byte ptr [u.ttyn], ah
			      C 	; 06/12/2013
			      C 	;; 13/01/2014
			      C 	;;cmp	ah, 7
			      C 	;;ja	short @f
			      C 	;mov	al, ah
 144F  FE C0		      C 	inc	al
 1451  A2 27C7 R	      C 	mov	byte ptr [u.ttyp]+1, al ; tty number + 1
			      C ;;@@:	; 26/08/2013
 1454			      C wtty_nc: ; 15/05/2013
			      C 	; AH = [u.ttyn] = tty number ; 28/07/2013
 1454  E8 00DF		      C 	call	cpass
			      C 		; jsr r0,cpass / get next character from user buffer area; if
			      C 		             ; / none go to return address in syswrite
			      C 		; tst r1 / is character = null
			      C 		; beq wtty / yes, get next character
			      C 	; 10/10/2013
 1457  74 13		      C 	jz	short wret
			      C ;1 :
			      C 		;mov 	$240,*$ps / no, set processor priority to five
			      C 		;cmpb	cc+1,$20. / is character count for console tty greater
			      C 		;	          / than 20
			      C 		;bhis	2f / yes; branch to put process to sleep
			      C 	; 27/06/2014
 1459			      C @@:
			      C 	; AH = tty number
			      C 	; AL = ASCII code of the character
			      C 	; 15/04/2014
 1459  50		      C 	push	ax
 145A  E8 0702		      C 	call	putc ; 14/05/2013
 145D  73 0A		      C 	jnc	short @f
			      C 	; 02/06/2014
 145F  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn]
 1463  E8 FBC8		      C 	call	sleep
 1466  58		      C 	pop	ax
 1467  EB F0		      C 	jmp 	short @b
			      C 		; jc 	error ; 15/05/2013 (COM1 or COM2 serial port error)
			      C 		; jsr 	r0,putc; 1 / find place in freelist to assign to 
			      C 			      ; / console tty and
			      C 		; br 	2f / place character in list; if none available
			      C 		   	  ; / branch to put process to sleep
			      C 		; jsr	r0,startty / attempt to output character on tty
 1469			      C @@:
			      C 	; 15/04/2014
 1469  58		      C 	pop	ax
 146A  EB E8		      C 	jmp	short wtty_nc
			      C 		; br wtty
 146C			      C wret:	; 10/10/2013
 146C  58		      C 	pop	ax
 146D  C3		      C 	retn
			      C ;2:
			      C 	;mov	r1,-(sp) / place character on stack
			      C 	;jsr	r0,sleep; 1 / put process to sleep
			      C 	;mov	(sp)+,r1 / remove character from stack
			      C 	;br	1b / try again to place character in clist and output
			      C 
 146E			      C xmtt:   ; < send/write character to tty >
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 10/10/2013
			      C 	; 14/08/2013
			      C 	; 28/07/2013
			      C 	; 21/05/2013 owner checking for COM/serial ports
			      C 	; 15/05/2013
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; In original UNIX v1, 'xmtt' routine 
			      C 	;		(exactly different than this one)
			      C 	;	was in 'u9.s' file.
			      C 	;
 146E  2C 0A		      C 	sub 	al, 10
			      C 	; AL = tty number (0 to 9), (COM1=8, COM2=9)
			      C 	 ; 10/10/2013
 1470  8A E0		      C 	mov	ah, al
			      C 	; 28/07/2013
 1472  EB D7		      C 	jmp	short wttys
			      C 
			      C ;wppt:
			      C ;	jsr	r0,cpass / get next character from user buffer area,
			      C ;		         / if none return to writei's calling routine
			      C ;	jsr	r0,pptoc / output character on ppt
			      C ;	br	wppt
			      C 
 1474			      C wmem: ; / transfer characters from a user area of core to memory file
 1474  8B 36 27B6 R	      C         mov     si, word ptr [u.fofp] 
 1478			      C @@:
 1478  E8 00BB		      C 	call	cpass
			      C 		; jsr r0,cpass / get next character from users area of
			      C 			     ; / core and put it in r1
			      C         	; mov r1,-(sp) / put character on the stack
			      C 	; 20/09/2013
 147B  74 EF		      C 	jz	short wret ; @f     
 147D  8B 1C		      C         mov     bx, word ptr [SI]
			      C 		; mov *u.fofp,r1 / save file offset in r1
 147F  FF 04		      C         inc     word ptr [SI] ; 16/07/2015
			      C 		; inc *u.fofp / increment file offset to point to next
			      C 			    ; / available location in file
 1481  88 07		      C 	mov	byte ptr [BX], al	
			      C 		; movb (sp)+,(r1) / pop char off stack, put in memory loc 
			      C 			        ; / assigned to it
 1483  EB F3		      C 	jmp	short @b
			      C 		; br wmem / continue
			      C ;1:
			      C 	;jmp	error / ?
			      C ;@@:	
			      C ;	; 20/09/2013
			      C ;	pop	ax
			      C ;	retn
			      C 
			      C ;wlpr:
			      C 	; 13/06/2022
			      C 	;jmp 	error   ; ... Printing procedure will be located here ...
			      C 		;/	jsr	r0,cpass
			      C 		;/	cmp	r0,$'a
			      C 		;/	blo	1f
			      C 		;/	cmp	r1,$'z
			      C 		;/	bhi	1f
			      C 		;/	sub	$40,r1
			      C 		;/1:
			      C 		;/	jsr	r0,lptoc
			      C 		;/	br	wlpr
			      C 		; br rmem / continue
			      C 
			      C ; 13/06/2022 - Retro UNIX 8086 Kernel v0.1.0.3 - PRINTER BIOS (Functions)
			      C 
			      C ;; Ref: MSDOS 3.3 (Retro DOS 3.2) Printer driver code (MSLPT.ASM)
			      C ;; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
			      C ;; 23/03/2018 - Retro DOS v2.0
			      C ;; RETRODOS32.ASM - 03/08/2019 (Retro DOS v3.2)
			      C 
			      C ; IBM ROMBIOS (INT 17h) STATUS BITS
			      C 
 = 0080			      C NOTBUSYSTATUS	equ 10000000b	; NOT BUSY
 = 0040			      C ACKSTATUS	equ 01000000b	; ACKNOWLEDGE (FOR WHAT?)
 = 0020			      C NOPAPERSTATUS	equ 00100000b	; NO MORE PAPER
 = 0010			      C SELECTEDSTATUS	equ 00010000b	; THE PRINTER SAID IT WAS SELECTED
 = 0008			      C IOERRSTATUS	equ 00001000b	; SOME KIND ERROR
 = 0006			      C RESERVED	equ 00000110b	; NOPS
 = 0001			      C TIMEOUTSTATUS	equ 00000001b	; TIME OUT.
			      C 
			      C ;----------------------------------------------------------------
			      C ;								:
			      C ;		WRITE TO PRINTER DEVICE 			:
			      C ;								:
			      C ;   CX has count of bytes to be printed 			:
			      C ;   ES:DI point to source buffer contains characters		:
			      C ;   AuxNum (in msbio.asm) has printer number			:
			      C ;								:
			      C ;----------------------------------------------------------------
			      C 
 1485			      C wlpr:
			      C 	; 13/06/2022 - Retro UNIX 8086 v1 
			      C 	;	      (Retro UNIX Kernel v0.1.0.3)
 1485			      C PRN$WRIT:
			      C 	; INPUT:
			      C 	;	[u.count] = count of characters to be printed
			      C 	;	[u.base] = buffer address in user's memory space
			      C 	;
			      C 	;	(if CX = 0, printer status will be returned)
			      C 	
			      C 	;xor	cx, cx
 1485			      C PRN$LOOP:
 1485  E8 00AE		      C 	call	cpass		; Get a character into AL
 1488  74 23		      C 	jz	short pr_exit
			      C 	;
 148A  B1 02		      C 	mov	cl, 2  ; retry count
 148C			      C PRN$OUT:
			      C 	; al = character which will be printed
 148C  32 E4		      C 	xor	ah, ah ; 0	; PRINT THE CHARACTER IN (AL)
 148E  E8 002E		      C 	call	PRNOP
 1491  74 F2		      C 	jz	short PRN$LOOP	; if error, try to print again
 1493			      C PrRetry:
			      C 	; al = character
 1493  FE C9		      C 	dec	cl
 1495  75 F5		      C 	jnz	short PRN$OUT
 1497			      C pr_err_exit:
 1497  8A C4		      C 	mov	al, ah ; printer port status flags
 1499  32 E4		      C 	xor	ah, ah ; 0
 149B  A3 27A8 R	      C 	mov	word ptr [u.r0], ax ; status flags in AL
 149E  8B 2E 27A4 R	      C 	mov 	bp, word ptr [u.sp_]
			      C 			; Kernel stack at the beginning of sys call
 14A2  8B 16 27C2 R	      C 	mov	dx, word ptr [u.nread]
 14A6  4A		      C 	dec	dx ; last char failed
 14A7  89 56 0A		      C 	mov	word ptr [bp]+10, dx 
			      C 			; count of printed chacters in dx
 14AA  E9 EE46		      C 	jmp	error
 14AD			      C pr_exit:
 14AD  58		      C 	pop	ax ; inode number
			      C 
			      C 	;mov	ax, word ptr [u.nread]
			      C 	;mov	word ptr [u.r0], ax ; count of printed chacters
			      C 	;jmp	sysret
 14AE  C3		      C 	retn	; return from writei to syswrite (rw0)
			      C 
			      C ; 13/06/2022
			      C 
			      C ;----------------------------------------------------------------
			      C ;								:
			      C ;		PRINTER STATUS ROUTINE				:
			      C ;								:
			      C ;----------------------------------------------------------------
			      C ;
			      C 	
 14AF			      C lpr_stat:
			      C 	; 13/06/2022 - Retro UNIX 8086 v1 (Kernel v0.1.0.3)
 14AF			      C PRN$STAT:
 14AF  E8 000B		      C 	call	PRNSTAT		; get the status
			      C 	
 14B2  8A C4		      C 	mov	al, ah ; printer port status flags (bits)
 14B4  32 E4		      C 	xor	ah, ah ; 0
 14B6  A3 27A8 R	      C 	mov	word ptr [u.r0], ax ; status flags in AL
			      C 
 14B9  58		      C 	pop	ax ; discard return address to syswrite
 14BA  E9 EE53		      C 	jmp	sysret
			      C 
			      C ;
			      C ;   PRNSTAT	get printer status
			      C ;   PRNOP	print a character
			      C ;
			      C ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
			      C ; printer routines.  The routines share code which calls on the bios and
			      C ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
			      C ; only by the value put into AH before the ROM-BIOS call.
			      C ;
			      C ;   INPUT	if PRNOP then character in AL
			      C ;
			      C ;   OUTPUT	- AL holds error code
			      C ;		- AH status byte from printer
			      C ;		- flag NZ if error
			      C 
 14BD			      C PRNSTAT:						   
 14BD  B4 02		      C 	mov	ah, 2		; set command for get status 
 14BF			      C PRNOP:
			      C 	; 13/06/2022 - Retro UNIX 8086 v1 (Kernel v0.1.0.3)
			      C 	;
			      C 	; Print character (on paper)
			      C 
			      C 	; INPUT:
			      C 	;	al = character to be printed
			      C 	; OUTPUT:
			      C 	;	zf = 1 -> ok
			      C 	;	zf = 0 -> error code in AL
			      C 
 14BF  33 D2		      C 	xor	dx, dx	; 0 = LPT1 (default for Retro UNIX)
 14C1  CD 17		      C 	int	17h	; lpt bios
			      C 	
 14C3  F6 C4 08		      C 	test	ah, IOERRSTATUS	  ; I/O ERROR?
			      C 	;jz	short short prnop_chk_nrdy ; NO, TRY NOT READY
 14C6  75 03		      C 	jnz	short PRNOP2
			      C 
			      C 	; AT THIS POINT, WE KNOW WE HAVE AN ERROR.
			      C 	; THE CONVERSE IS NOT TRUE.
			      C 
			      C 	;retn	 ; zf = 0	; RETURN WITH ERROR
			      C 
			      C ; THE BITS SAID NO ERROR.
			      C ; UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WORK HERE.
			      C 
 14C8			      C prnop_chk_nrdy:
 14C8  F6 C4 01		      C 	test	ah, TIMEOUTSTATUS ; IS TIME-OUT SET?
			      C 				; IF NZ THEN ERROR, ELSE OK???
 14CB			      C PRNOP2:
 14CB  C3		      C 	retn
			      C 
 14CC			      C dskw: ; / write routine for non-special files
			      C 	; 19/07/2022
			      C 	;	(file offset bugfix for 'dskwr' error return situation)	
			      C 	; 20/09/2013
			      C 	; 03/08/2013
			      C 	; 01/08/2013 (mkdir_w check)
 14CC  50		      C 	push	ax ; 26/04/2013
			      C 		; mov (sp),r1 / get an i-node number from the stack into r1
			      C 	; AX = inode number
 14CD  E8 FCB6		      C 	call	iget
			      C 		; jsr r0,iget / write i-node out (if modified), 
			      C 		            ; / read i-node 'r1' into i-node area of core
 14D0  8B 1E 27B6 R	      C         mov     bx, word ptr [u.fofp] 
 14D4  8B 17		      C 	mov 	dx, word ptr [BX]
			      C 		; mov *u.fofp,r2 / put the file offset [(u.off) or the offset
			      C 			       ; / in the fsp entry for this file] in r2
 14D6  03 16 27C0 R	      C 	add 	dx, word ptr [u.count]	
			      C 		; add u.count,r2 / no. of bytes to be written
			      C 			       ; / + file offset is put in r2
 14DA  3B 16 25EE R	      C         cmp     dx, word ptr [i.size_]
			      C 		; cmp r2,i.size / is this greater than the present size of
			      C 		              ; / the file?
 14DE  76 07		      C 	jna	short dskw_1
			      C 		; blos 1f / no, branch
 14E0  89 16 25EE R	      C         mov     word ptr [i.size_], dx
			      C 	 	; mov r2,i.size / yes, increase the f11e size to 
			      C 			      ; / file offset + no. of data bytes
 14E4  E8 FD64		      C 	call	setimod
			      C 	 	; jsr r0,setimod / set imod=1 (i.e., core inode has been
			      C 		          ; / modified), stuff time of modification into
			      C 	          	  ; / core image of i-node
 14E7			      C dskw_1: ; 1:	
 14E7  E8 FB8B		      C 	call	mget
			      C 	; AX = Block number
			      C 		; jsr r0,mget / get the block no. in which to write 
			      C 			    ; /	the next data byte
 14EA  8B 1E 27B6 R	      C 	mov     bx, word ptr [u.fofp]
 14EE  8B 17		      C 	mov	dx, word ptr [BX]
 14F0  81 E2 01FF	      C 	and	dx, 1FFh  
			      C 		; bit *u.fofp,$777 / test the lower 9 bits of the file offset
 14F4  75 08		      C 	jnz	short dskw_2
			      C 		; bne 2f / if its non-zero, branch; if zero, file offset = 0,
			      C 		       ; / 512, 1024,...(i.e., start of new block)
 14F6  81 3E 27C0 R 0200      C 	cmp	word ptr [u.count], 512
			      C 		; cmp u.count,$512. / if zero, is there enough data to fill
			      C 				  ; / an entire block? (i.e., no. of
 14FC  73 03		      C 	jnb	short dskw_3
			      C 		; bhis 3f / bytes to be written greater than 512.? 
			      C 			; / Yes, branch. Don't have to read block
			      C 
 14FE			      C dskw_2: ; 2: / in as no past info. is to be saved (the entire block will be
			      C    		; / overwritten).
 14FE  E8 03E8		      C 	call	dskrd
			      C 		; jsr r0,dskrd / no, must retain old info.. 
			      C 			     ; / Hence, read block 'r1' into an I/O buffer
 1501			      C dskw_3: ; 3:
			      C 	; AX (r1) = block/sector number
 1501  E8 0410		      C 	call	wslot
			      C 		; jsr r0,wslot / set write and inhibit bits in I/O queue, 
			      C 			   ; / proc. status=0, r5 points to 1st word of data
			      C 	; BX (r5) = system (I/O) buffer address
 1504  E8 0054		      C 	call	sioreg	; 19/07/2022
			      C 		; jsr r0,sioreg / r3 = no. of bytes of data, 
			      C 			     ; / r1 = address of data, r2 points to location
			      C 			     ; / in buffer in which to start writing data
			      C 	; 19/07/2022
			      C 	; SI = file offset pointer
			      C 	; AX = file (user data) offset (previous value of [u.base)
			      C 
			      C 	; 19/07/2022 - Erdogan Tan
			      C 	; BugFix (Also original unix v1 kernel code has this bug!)
			      C 	; ((Against a possible disk write failure/error, 
			      C 	;   file offset must not be updated/increased before 'dskwr'
			      C 	;   but it was updated in 'sioreg'. I have modified 'sioreg'
			      C 	;   and 'dskw' procedures for that.))
			      C 
			      C 	; 19/07/2022
 1507  56		      C 	push	si ; *	; save file offset (pointer)
 1508  51		      C 	push	cx ; **	; save byte count
 1509  8B F0		      C 	mov	si, ax
			      C 	
			      C 	; SI = file (user data) offset
			      C 	; DI = sector (I/O) buffer offset
			      C 	; CX = byte count
			      C 	
			      C         ; 03/08/2013
			      C 	; 01/08/2013
 150B  80 3E 26FA R 00	      C 	cmp	byte ptr [mkdir_w], 0
 1510  76 04		      C 	jna	short dskw_4	   ; zf=0 -> the caller is 'mkdir'
 1512  F3/ A4		      C 	rep	movsb
 1514  EB 0B		      C 	jmp	short dskw_5
 1516			      C dskw_4:
 1516  A1 27E0 R	      C 	mov     ax, word ptr [u.segmnt] ; Retro Unix 8086 v1 feature only !
 1519  8E D8		      C 	mov	ds, ax ; Retro Unix 8086 v1 feature: ES = user segment !
			      C ; 2:
 151B  F3/ A4		      C 	rep	movsb
			      C 		; movb (r1 )+,(r2)+ 
			      C 		         ; / transfer a byte of data to the I/O buffer
			      C 		; dec r3 / decrement no. of bytes to be written
			      C 		; bne 2b / have all bytes been transferred? No, branch
			      C 
 151D  8C C8		      C 	mov	ax, cs ; Retro Unix 8086 v1 feature: CS = system segment !
 151F  8E D8		      C 	mov	ds, ax ; Retro Unix 8086 v1 feature: DS = system segment !
 1521			      C dskw_5:
 1521  E8 03FB		      C 	call	dskwr
			      C 		; jsr r0,dskwr / yes, write the block and the i-node
			      C 
			      C 	; 19/07/2022
			      C 	; (there is not a disk write error, we can increase file offset)
 1524  58		      C 	pop	ax ; ** ; byte count
 1525  5F		      C 	pop	di ; *  ; file offset (pointer)
			      C 	;
 1526  01 05		      C 	add	word ptr [DI], ax
			      C 			; new file offset (old offset + byte count)
			      C 
 1528  83 3E 27C0 R 00	      C         cmp     word ptr [u.count], 0
			      C 		; tst u.count / any more data to write?
 152D  77 B8		      C 	ja	short dskw_1
			      C 		; bne 1b / yes, branch
			      C 	; 03/08/2013
 152F  C6 06 26FA R 00	      C 	mov	byte ptr [mkdir_w], 0
			      C 	; 20/09/2013 (;;)
 1534  58		      C 	pop	ax
 1535  C3		      C 	retn
			      C 	;;jmp 	short dskw_ret 
			      C 	        ; jmp ret / no, return to the caller via 'ret'
			      C 
 1536			      C cpass: ; / get next character from user area of core and put it in r1
 1536  83 3E 27C0 R 00	      C 	cmp 	word ptr [u.count], 0  ; 14/08/2013
			      C 		; tst u.count / have all the characters been transferred
			      C 			    ; / (i.e., u.count, # of chars. left
 153B  76 1D		      C 	jna	short @f
			      C 		; beq 1f / to be transferred = 0?) yes, branch
 153D  FF 0E 27C0 R	      C 	dec	word ptr [u.count]
			      C 		; dec u.count / no, decrement u.count
			      C         ;
 1541  8B 1E 27E0 R	      C 	mov     bx, word ptr [u.segmnt] ; Retro Unix 8086 v1 feature only !
 1545  8E C3		      C 	mov	es, bx  ; Retro Unix 8086 v1 feature: ES = user segment !
			      C 	;
 1547  8B 1E 27BE R	      C 	mov	bx, word ptr [u.base]
 154B  26: 8A 07	      C 	mov	al, byte ptr ES:[BX] ; Runix v1: get data from user segment!
			      C 		; movb *u.base,r1 / take the character pointed to 
			      C 				; / by u.base and put it in r1
 154E  8C DB		      C 	mov	bx, ds ; Retro Unix 8086 v1 feature: DS = system segment !
 1550  8E C3		      C 	mov	es, bx ; Retro Unix 8086 v1 feature: ES = system segment !
			      C 	;	
 1552  FF 06 27C2 R	      C 	inc	word ptr [u.nread]
			      C 		; inc u.nread / increment no. of bytes transferred
 1556  FF 06 27BE R	      C 	inc	word ptr [u.base]
			      C 		; inc u.base / increment the buffer address to point to the
 155A			      C @@:	; 20/09/2013 (;;)
 155A  C3		      C 	retn
			      C 		; rts	r0 / next byte
			      C ;;@@: ; 1: 
			      C ;;	pop	ax
			      C 		; mov (sp)+,r0 
			      C 		         ; / put return address of calling routine into r0
			      C ;;dskw_ret:
			      C ;;	pop	ax
			      C 		; mov (sp)+,r1 / i-number in r1
			      C ;;	retn
			      C 		; rts r0 / non-local return
			      C 
 155B			      C sioreg: 
			      C 	; 19/07/2022
			      C 	;	(file offset bugfix for 'dskwr' error return situation)
			      C 	; 03/02/2022
			      C 	; 22/07/2013
			      C 	; 14/03/2013 bx -> si, ax input -> bx input
			      C 	; 12/03/2013
			      C 	; INPUTS -> 
			      C 	;     BX = system buffer (data) address (r5)
			      C 	; OUTPUTS -> 
			      C 	;     SI = user data offset (r1)
			      C 	;     DI = system (I/O) buffer offset (r2)
			      C 	;     CX = byte count (r3)
			      C         ; ((Modified registers: AX)) ; 22/07/2013
			      C 
			      C 	; 19/07/2022
			      C 	; OUTPUTS -> 
			      C 	;	AX = user data offset (previous value of [u.base])
			      C 	;	SI = pointer to file offset 
			      C 	; 	DI = system (I/O) buffer offset
			      C 	;	CX = byte count
			      C 	;	BX = system buffer (data) address	
			      C 
 155B  8B 36 27B6 R	      C         mov     si, word ptr [u.fofp]
 155F  8B 3C		      C         mov     di, word ptr [SI]
			      C 		; mov *u.fofp,r2 / file offset (in bytes) is moved to r2
 1561  8B CF		      C 	mov	cx, di
			      C 		; mov r2,r3 / and also to r3
			      C 	; 03/02/2022
 1563  80 CD FE		      C 	or	ch, 0FEh
			      C 	;or	cx, 0FE00h
			      C 		; bis $177000,r3 / set bits 9,...,15 of file offset in r3
 1566  81 E7 01FF	      C 	and	di, 1FFh
			      C 		; bic $!777,r2 / calculate file offset mod 512.
 156A  03 FB		      C 	add	di, bx ; BX = system buffer (data) address
			      C 		; add r5,r2 / r2 now points to 1st byte in system buffer
			      C 			  ; / where data is to be placed
 156C  A1 27BE R	      C 	mov	ax, word ptr [u.base] ; 22/07/2013
			      C                 ; mov u.base,r1 / address of data is in r1
 156F  F7 D9		      C 	neg	cx
			      C 		; neg r3 / 512 - file offset (mod512.) in r3 
			      C 		       ; / (i.e., the no. of free bytes in the file block)
 1571  3B 0E 27C0 R	      C 	cmp	cx, word ptr [u.count]
			      C 		; cmp r3,u.count / compare this with the no. of data bytes
			      C 			       ; / to be written to the file
 1575  76 04		      C 	jna	short @f
			      C 		; blos	2f / if less than branch. Use the no. of free bytes
			      C 			 ; / in the file block as the number to be written
 1577  8B 0E 27C0 R	      C 	mov	cx, word ptr [u.count]
			      C 		; mov u.count,r3 / if greater than, use the no. of data 
			      C 			       ; / bytes as the number to be written
 157B			      C @@: ; 2:
 157B  01 0E 27C2 R	      C 	add 	word ptr [u.nread], cx
			      C 		; add r3,u.nread / r3 + number of bytes xmitted 
			      C 			       ; / during write is put into u.nread
 157F  29 0E 27C0 R	      C 	sub 	word ptr [u.count], cx
			      C 		; sub r3,u.count / u.count = no. of bytes that still 
			      C 			       ; / must be written or read
 1583  01 0E 27BE R	      C 	add 	word ptr [u.base], cx
			      C 		; add r3,u.base / u.base points to the 1st of the remaining
			      C 			      ; / data bytes
			      C 	; 19/07/2022
			      C 	;	AX = user data offset
			      C 	;	SI = pointer to file offset 
			      C 
			      C         ;add 	word ptr [SI], cx 
			      C 	;	; add r3,*u.fofp / new file offset = number of bytes done
			      C 	;		       ; / + old file offset
			      C 	;mov 	si, ax ; 22/07/2013
			      C         
 1587  C3		      C 	retn
			      C 		; rts r0
			      C 
				include u7.asm ; u7.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U7.ASM (include u7.asm) //// UNIX v1 -> u7.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 13/06/2022 ]  ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 15/05/2022
			      C ; 11/05/2022
			      C ; 09/05/2022
			      C ; 03/03/2022
			      C ; 04/02/2022
			      C ; 27/01/2022
			      C ; 13/07/2014 ottyp
			      C ; 12/07/2014 ottyp
			      C ; 15/04/2014 ottyp 
			      C ; 26/01/2014 otty, ottyp, ctty, cttyp
			      C ; 17/01/0214 otty, ottyp, ottys, ctty, cttyp
			      C ; 13/01/2014 otty, ocvt, ottys, ctty, ccvt, ottyp, cttyp
			      C ; 12/01/2014 iclose
			      C ; 06/12/2013 otty, ocvt, ctty, ccvt (major modification: p.ttyc, u.ttyp)
			      C ; 04/12/2013 (getc, putc procedures have been moved to U9.ASM)
			      C ; 03/12/2013 putc (write_tty, beep, waitf)
			      C ; 30/11/2013 putc
			      C ; 04/11/2013 putc, symount, sysumount
			      C ; 30/10/2013 putc
			      C ; 20/10/2013 getc
			      C ; 10/10/2013 getc
			      C ; 05/10/2013 getc
			      C ; 24/09/2013 getc, otty, ocvt, ctty, ccvt, putc (consistency check)
			      C ; 20/09/2013 putc, getc
			      C ; 17/09/2013 otty (ottys), ctty, ccvt
			      C ; 16/09/2013 ocvt, ctty
			      C ; 13/09/2013 otty
			      C ; 03/09/2013 otty, ocvt, ctty, ccvt
			      C ; 27/08/2013 iopen, iclose, ocvt, ccvt
			      C ; 26/08/2013 putc
			      C ; 16/08/2013 iopen, iclose, otty, ctty
			      C ; 13/08/2013 ctty (cttys)
			      C ; 05/08/2013 ctty
			      C ; 30/07/2013 iclose, ctty, ccvt
			      C ; 29/07/2013
			      C ; 28/07/2013
			      C ; 16/07/2013 iopen, otty, ocvt, ctty, ccvt, getc, iclose modifications
			      C ; 15/07/2013
			      C ; 09/07/2013 - sysmount, sysumount
			      C 
 1588			      C sysmount: ; / mount file system; args special; name
			      C 	; 11/05/2022
			      C 	; 27/01/2022
			      C 	; 04/11/2013
			      C 	; 09/07/2013
			      C 	; 'sysmount' anounces to the system that a removable 
			      C 	; file system has been mounted on a special file.
			      C 	; The device number of the special file is obtained via
			      C 	; a call to 'getspl'. It is put in the I/O queue entry for
			      C 	; dismountable file system (sb1) and the I/O queue entry is
			      C 	; set up to read (bit 10 is set). 'ppoke' is then called to
			      C 	; to read file system into core, i.e. the first block on the
			      C 	; mountable f'le system is read in. This block is super block
			      C 	; for the file system. This call is super user restricted.	
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysmount; special; name
			      C 	; Arguments:
			      C 	;	special - pointer to name of special file (device)
			      C 	;	name -  pointer to name of the root directory of the
			      C 	;		newly mounted file system. 'name' should 
			      C 	;		always be a directory.
			      C 	; Inputs: - 
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysmount' system call has two arguments; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 2 is used
			      C 	;	to get sysmount system call arguments from the user;
			      C 	;	* 1st argument, special is pointed to by BX register
			      C 	;	* 2nd argument, name is in CX register
			      C 	;
			      C 	;	NOTE1: Retro UNIX 8086 v1 'arg2' routine gets these
			      C 	;	       arguments which were in these registers;
			      C 	;	       but, it returns by putting the 1st argument
			      C 	;	       in 'u.namep' and the 2nd argument
			      C 	;	       on top of stack. (1st argument is offset of the
			      C 	;	       file/path name in the user's program segment.		 	
			      C 	;	NOTE2: Device numbers, names and related procedures are 
			      C 	;	       already modified for IBM PC compatibility and 
			      C 	;	       Retro UNIX 8086 v1 device configuration.	
			      C 	
			      C 	;call	arg2
			      C 		; jsr r0,arg2 / get arguments special and name
 1588  89 1E 27BA R	      C 	mov	word ptr [u.namep], bx
 158C  51		      C 	push	cx
 158D  83 3E 26EC R 00	      C 	cmp	word ptr [mnti], 0
			      C 		; tst mnti / is the i-number of the cross device file
			      C 			 ; / zero?
			      C 	;ja	error
			      C         	; bne errora / no, error
			      C 	; 27/01/2022
 1592  77 54		      C 	ja	short sysmount_err
 1594  E8 00C0		      C 	call	getspl
			      C 		; jsr r0,getspl / get special files device number in r1
			      C 	; 04/11/2013
			      C 	;pop	cx ; file name pointer
 1597  8B D8		      C 	mov	bx, ax ; ; Retro UNIX 8086 v1 device number (0 to 5)
 1599  80 BF 26C6 R 00	      C 	cmp	byte ptr [BX]+drv.err, 0
 159E  76 03 E9 ED50	      C 	ja	error
			      C 	;mov	word ptr [u.namep], cx
 15A3  8F 06 27BA R	      C 	pop	word ptr [u.namep]
			      C         	; mov (sp)+,u.namep / put the name of file to be placed
			      C 				  ; / on the device
 15A7  50		      C 	push	ax ; push bx
			      C 		; mov r1,-(sp) / save the device number
			      C         ;
 15A8  E8 F682		      C 	call	namei
			      C 	;;or	ax, ax ; Retro UNIX 8086 v1 modification !
			      C 		       ; ax = 0 -> file not found 	
			      C 	;;jz	error
			      C 	;jc	error
			      C 		; jsr r0,namei / get the i-number of the file
			      C                	; br errora
			      C 	; 27/01/2022
 15AB  72 3B		      C 	jc	short sysmount_err
 15AD  A3 26EC R	      C 	mov	word ptr [mnti], ax
			      C         	; mov r1,mnti / put it in mnti
			      C 
			      C 	; 11/05/2022
			      C 	; -Retro UNIX 8086/386 v1 feaure only-
 15B0  A1 26BE R	      C 	mov	ax, word ptr [ii]
 15B3  A3 288E R	      C 	mov	word ptr [mntp], ax ; parent dir inumber of [mnti]
			      C 
			      C 	; 04/11/2013
 15B6  BB 2C2A R	      C 	mov	bx, offset sb1 ; super block buffer (of mounted disk)
 15B9			      C @@: ;1:
 15B9  80 7F 01 00	      C         cmp	byte ptr [BX]+1, 0
			      C 		; tstb sb1+1 / is 15th bit of I/O queue entry for
			      C 			   ; / dismountable device set?
 15BD  76 05		      C         jna	short @f		
			      C 		; bne 1b / (inhibit bit) yes, skip writing
 15BF  E8 F9E8		      C 	call	idle ; 04/11/2013 (wait for hardware interrupt)
 15C2  EB F5		      C 	jmp	short @b
 15C4			      C @@:   
 15C4  58		      C 	pop	ax ; Retro UNIX 8086 v1 device number/ID (0 to 5)     
 15C5  A2 26C5 R	      C 	mov	byte ptr [mdev], al
			      C 		; mov  (sp),mntd / no, put the device number in mntd
			      C 	; 04/11/2013
 15C8  88 07		      C 	mov	byte ptr [BX], al
			      C         	; movb (sp),sb1 / put the device number in the lower byte
			      C 			      ; / of the I/O queue entry
			      C 	;mov	byte ptr [cdev], 1 ; mounted device/drive
			      C         	; mov (sp)+,cdev / put device number in cdev
 15CA  81 0F 0400	      C         or	word ptr [BX], 400h ; Bit 10, 'read' flag/bit
			      C 		; bis $2000,sb1 / set the read bit
 15CE  C6 47 02 01	      C 	mov	byte ptr [BX]+2, 1 ; physical block number = 1
 15D2  E8 03D9		      C 	call 	diskio
			      C 	;jnc	short @f
			      C 	; 15/05/2022
 15D5  72 07		      C 	jc	short sysmount_sbrd_err
			      C 
			      C ;sysmount_sbrd_err: ; 15/05/2022
			      C ;	xor 	ax, ax
			      C ;	mov	word ptr [mnti], ax ; 0
			      C ;	mov	byte ptr [mdev], al ; 0
			      C ;	;mov	byte ptr [cdev], al ; 0
			      C ;	mov	word ptr [BX], ax ; 0
			      C ;sysmount_err:
			      C ;sysumount_err:
			      C ;getspl_err:	; 04/02/2022
			      C ;	jmp	error
			      C 
 15D7			      C @@:
 15D7  C6 47 01 00	      C 	mov	byte ptr [BX]+1, 0 ; 18/07/2013
			      C 	;;call	ppoke
			      C         	; jsr r0,ppoke / read in entire file system
			      C ;@@: ;1:
			      C   	;;cmp	byte ptr [sb1]+1, 0
			      C 		; tstb sb1+1 / done reading?
			      C    	;;jna	sysret
			      C 	;,call	idle ; 04/11/2013 (wait for hardware interrupt)
			      C 	;;jmp	short @b
			      C 		;bne 1b / no, wait
			      C         	;br sysreta / yes
 15DB  E9 ED32		      C 	jmp	sysret
			      C 
 15DE			      C sysmount_sbrd_err: ; 15/05/2022
 15DE  33 C0		      C 	xor 	ax, ax
 15E0  A3 26EC R	      C 	mov	word ptr [mnti], ax ; 0
 15E3  A2 26C5 R	      C 	mov	byte ptr [mdev], al ; 0
			      C 	;mov	byte ptr [cdev], al ; 0
 15E6  89 07		      C 	mov	word ptr [BX], ax ; 0
 15E8			      C sysmount_err:
 15E8			      C sysumount_err:
 15E8			      C getspl_err:	; 04/02/2022
 15E8  E9 ED08		      C 	jmp	error
			      C 
 15EB			      C sysumount: ; / special dismount file system
			      C 	; 15/05/2022
			      C 	; 09/05/2022
			      C 	; 27/01/2022
			      C 	; 04/11/2013
			      C 	; 09/07/2013
			      C 	; 'sysmount' anounces to the system that the special file, 
			      C 	; indicated as an argument is no longer contain a removable
			      C 	; file system. 'getspl' gets the device number of the special
			      C 	; file. If no file system was mounted on that device an error
			      C 	; occurs. 'mntd' and 'mnti' are cleared and control is passed
			      C 	; to 'sysret'.
			      C 	;
			      C 	; Calling sequence:
			      C 	;	sysmount; special
			      C 	; Arguments:
			      C 	;	special - special file to dismount (device)
			      C 	;
			      C 	; Inputs: - 
			      C 	; Outputs: -
			      C 	; ...............................................................
			      C 	;				
			      C 	; Retro UNIX 8086 v1 modification: 
			      C 	;       'sysumount' system call has one argument; so,
			      C 	;	Retro UNIX 8086 v1 argument transfer method 1 is used
			      C 	;	to get sysmount system call argument from the user;
			      C 	;	* Single argument, special is pointed to by BX register
			      C 	;
			      C 	
			      C 	;mov 	ax, 1 ; one/single argument, put argument in BX	
			      C 	;call	arg
			      C 		; jsr r0,arg; u.namep / point u.namep to special
 15EB  89 1E 27BA R	      C         mov	word ptr [u.namep], bx
 15EF  E8 0065		      C 	call	getspl
			      C 		; jsr r0,getspl / get the device number in r1
			      C 	;;;
			      C 	; 09/05/2022 - Erdogan Tan
			      C 	; (I have added [mnti] check because
			      C 	;  retro unix device number of /dev/fd0 is 0
			      C 	;  .. so, 'cmp al, byte ptr [mdev]' is not enough
			      C 	;  for dismounting /dev/fd0. sysumount system call would give
			      C 	;  wrong cf=0 result while /dev/fd0 is not mounted.)
 15F2  83 3E 26EC R 00	      C 	cmp	word ptr [mnti], 0
 15F7  76 EF		      C 	jna	short sysumount_err ; there is not a mounted device !
			      C 	;;;
			      C 
 15F9  3A 06 26C5 R	      C 	cmp	al, byte ptr [mdev]
			      C 		; cmp r1,mntd / is it equal to the last device mounted?
			      C 	;jne	error
			      C         	; bne errora / no error
			      C 	; 27/01/2022
 15FD  75 E9		      C 	jne	short sysumount_err
 15FF  32 C0		      C 	xor	al, al ; ah = 0
 1601			      C @@: ;1:
 1601  38 06 2C2B R	      C      	cmp 	byte ptr [sb1]+1, al ; 0
			      C 		; tstb sb1+1 / yes, is the device still doing I/O 
			      C 			   ; / (inhibit bit set)?
 1605  76 05		      C 	jna	short @f		
			      C 		; bne 1b / yes, wait
 1607  E8 F9A0		      C 	call	idle ; 04/11/2013 (wait for hardware interrupt)
 160A  EB F5		      C 	jmp	short @b
			      C 
 160C			      C @@:
			      C 	; 15/05/2022
			      C 	; (Retro UNIX 8086/386 v1 feature only !)
			      C 	; change user's current directory to mounting directory
			      C 	; if it is on the mounted device (chdir back to root fs)
 160C  38 06 27DA R	      C 	cmp	byte ptr [u.cdrv], al ; 0
 1610  76 3C		      C 	jna	short @f
			      C 
			      C 	;;;
			      C 	; 15/05/2022
			      C 	; It is needed to change the parent process's current
			      C 	; directory because shell runs (/etc/umount) 
			      C 	; as child process.
			      C 	
 1612  32 FF		      C 	xor	bh, bh
 1614  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno]
 1618  D0 E3		      C 	shl	bl, 1 ; >= 2 .. <= 32
 161A  81 C3 2628 R	      C 	add	bx, offset p.ppid-2
 161E  8B 17		      C 	mov	dx, word ptr [bx]
			      C 			; process id of the parent [p.ppid]
 1620  BE 260A R	      C 	mov	si, offset p.pid
 1623  B9 0010		      C 	mov	cx, nproc ; 16  
 1626			      C sysumnt_2:	
 1626  AD		      C 	lodsw
 1627  3B C2		      C 	cmp	ax, dx
 1629  74 02		      C 	je	short sysumnt_3
 162B  E2 F9		      C 	loop	sysumnt_2
 162D			      C sysumnt_3:
 162D  33 C0		      C 	xor	ax, ax
 162F  81 EE 260A R	      C 	sub	si, offset p.pid
 1633  D1 EE		      C 	shr	si, 1
			      C 	; si = process number
 1635  06		      C 	push	es
 1636  BB 06C0		      C 	mov	bx, sdsegmnt
 1639  8E C3		      C 	mov	es, bx
 163B  8B DE		      C 	mov	bx, si
 163D  86 FB		      C 	xchg	bh, bl ; bl = 0
 163F  FE CF		      C 	dec	bh ; 0 based process number
			      C 	; bx = user structure offset in sdsegment
 1641  8B 16 26EC R	      C 	mov	dx, word ptr [mnti]
 1645  26: 89 57 06	      C 	mov	word ptr es:[bx+user.cdir], dx
 1649  26: 88 47 36	      C 	mov	byte ptr es:[bx+user.cdrv], al ; 0
 164D  07		      C 	pop	es
			      C 	;;;
 164E			      C @@:        
 164E  A2 26C5 R	      C 	mov	byte ptr [mdev], al
			      C 	     	; clr mntd / no, clear these
 1651  A3 26EC R	      C    	mov	word ptr [mnti], ax
			      C         	; clr mnti
 1654  E9 ECB9		      C         jmp	sysret
			      C 		; br sysreta / return
			      C 
 1657			      C getspl: ; / get device number from a special file name
			      C         ; 04/02/2022
			      C 	; 09/07/2013
 1657  E8 F5D3		      C 	call	namei
			      C 	;or	ax, ax ; Retro UNIX 8086 v1 modification !
			      C 		       ; ax = 0 -> file not found
			      C 	;;jz	error
			      C 	;jc	error
			      C 		; jsr r0,namei / get the i-number of the special file
			      C                 ; br errora / no such file
			      C 	; 04/02/2022
 165A  72 8C		      C         jc	short getspl_err
			      C 
 165C  83 E8 03		      C 	sub	ax, 3 ; Retro UNIX 8086 v1 modification !
			      C 		      ;	i-number-3, 0 = fd0, 5 = hd3 
			      C 		; sub $4,r1 / i-number-4 rk=1,tap=2+n
			      C         ;jc	error
			      C 		; ble errora / less than 0?  yes, error
			      C         ; 04/02/2022
 165F  72 87		      C         jc	short getspl_err
			      C 	
 1661  83 F8 05		      C 	cmp	ax, 5 ;
			      C 		; cmp  r1,$9. / greater than 9  tap 7
			      C 	;ja	error
			      C         	; bgt errora / yes, error
			      C 	; 04/02/2022
 1664  77 82		      C 	ja	short getspl_err
			      C 
			      C 	; AX = Retro UNIX 8086 v1 Device Number (0 to 5)
 1666			      C @@:
 1666  C3		      C 	retn
			      C 		; rts    r0 / return with device number in r1
			      C 
 1667			      C iopen:
			      C 	; 13/06/2022 - Retro UNIX 8086 v1 (Kernel v0.1.0.3) 
			      C 	;	(Printer initialization)
			      C 	; 04/02/2022
			      C 	; 27/08/2013
			      C 	; 16/08/2013
			      C 	; 16/07/2013 
			      C 	; 21/05/2013
			      C 	;
			      C 	; open file whose i-number is in r1
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - inode number
			      C 	; OUTPUTS ->
			      C 	;    file's inode in core	
			      C 	;    r1 - inode number (positive)
			      C 	;
			      C 	; ((AX = R1))
			      C         ;    ((Modified registers: DX, BX, CX, SI, DI, BP)) 
			      C 	;        
			      C ; / open file whose i-number is in r1
 1667  F6 C4 80		      C 	test	ah, 80h ; Bit 15 of AX
			      C 		; tst r1 / write or read access?
 166A  75 3B		      C         jnz	short iopen_2
			      C 		; blt 2f / write, go to 2f
 166C  B2 02		      C 	mov	dl, 2 ; read access
 166E  E8 FBB7		      C 	call	access
			      C         	; jsr r0,access; 2 
			      C 			; / get inode into core with read access
			      C 	; DL=2
 1671			      C iopen_0: 
 1671  83 F8 28		      C         cmp	ax, 40
			      C 		; cmp r1,$40. / is it a special file
			      C         ;ja	short @f
			      C 		; bgt 3f / no. 3f
 1674  77 F0		      C 	ja	short @b ; 16/08/2013
 1676  50		      C 	push	ax
			      C 		; mov r1,-(sp) / yes, figure out
 1677  8B D8		      C 	mov	bx, ax
			      C 	; 04/02/2022
 1679  D0 E3		      C 	shl	bl, 1
			      C 	;shl	bx, 1
			      C 		; asl r1
 167B  81 C3 167F R	      C         add     bx, offset iopen_1 - 2
 167F  FF 27		      C 	jmp	word ptr [BX]
			      C         	; jmp *1f-2(r1) / which one and transfer to it
 1681			      C iopen_1: ; 1:
 1681  16B8 R		      C 	dw 	offset otty ; tty, AX = 1 (runix)
			      C  		 ;otty / tty ; r1=2
			      C         	 ;oppt / ppt ; r1=4
 1683  178F R		      C 	dw	offset sret ; mem, AX = 2 (runix)
			      C 		 ;sret / mem ; r1=6
			      C 		 ;sret / rf0
			      C         	 ;sret / rk0
			      C         	 ;sret / tap0
			      C         	 ;sret / tap1
			      C         	 ;sret / tap2
			      C         	 ;sret / tap3
			      C         	 ;sret / tap4
			      C         	 ;sret / tap5
			      C         	 ;sret / tap6
			      C         	 ;sret / tap7
 1685  178F R		      C         dw      offset sret ; fd0, AX = 3 (runix only)
 1687  178F R		      C         dw      offset sret ; fd1, AX = 4 (runix only)
 1689  178F R		      C         dw      offset sret ; hd0, AX = 5 (runix only)
 168B  178F R		      C         dw      offset sret ; hd1, AX = 6 (runix only) 
 168D  178F R		      C         dw      offset sret ; hd2, AX = 7 (runix only)
 168F  178F R		      C         dw      offset sret ; hd3, AX = 8 (runix only) 
			      C 	;;dw	offset error ; lpr, AX = 9 (error !)
			      C         ;dw	offset sret ; lpr, AX = 9 (runix)
			      C         ; 13/06/2022 (lpt_init)
 1691  1817 R		      C 	dw	offset ejec ; lpr, AX = 9 (runix)
 1693  16C4 R		      C 	dw	offset ocvt ; tty0, AX = 10 (runix)	  
			      C 		 ;ocvt / tty0
 1695  16C4 R		      C 	dw	offset ocvt ; tty1, AX = 11 (runix)	  
			      C 		 ;ocvt / tty1
 1697  16C4 R		      C 	dw	offset ocvt ; tty2, AX = 12 (runix)	  
			      C 		 ;ocvt / tty2
 1699  16C4 R		      C 	dw	offset ocvt ; tty3, AX = 13 (runix)	  
			      C 		 ;ocvt / tty3
 169B  16C4 R		      C 	dw	offset ocvt ; tty4, AX = 14 (runix)	  
			      C 		 ;ocvt / tty4
 169D  16C4 R		      C 	dw	offset ocvt ; tty5, AX = 15 (runix)	  
			      C 		 ;ocvt / tty5
 169F  16C4 R		      C 	dw	offset ocvt ; tty6, AX = 16 (runix)	  
			      C 		 ;ocvt / tty6
 16A1  16C4 R		      C 	dw	offset ocvt ; tty7, AX = 17 (runix)	  
			      C 		 ;ocvt / tty7
 16A3  16C4 R		      C 	dw	offset ocvt ; COM1, AX = 18 (runix only)	  
			      C 		 ;error / crd
 16A5  16C4 R		      C 	dw	offset ocvt ; COM2, AX = 19 (runix only)
			      C ;@@:
			      C 	;retn
			      C 
 16A7			      C iopen_2: ; 2: / check open write access
 16A7  F7 D8		      C 	neg	ax
			      C 		; neg r1 / make inode number positive
 16A9  B2 01		      C 	mov	dl, 1 ; write access
 16AB  E8 FB7A		      C 	call	access
			      C 		; jsr r0,access; 1 / get inode in core
			      C 	; DL=1
			      C 	; 04/02/2022
 16AE  F6 06 25EB R 40	      C 	test	byte ptr [i.flgs+1], 40h
			      C 	;test	word ptr [i.flgs], 4000h ; Bit 14 : Directory flag
			      C  		; bit $40000,i.flgs / is it a directory?
			      C 	;jnz	error		
			      C        	;	; bne 2f / yes, transfer (error)
			      C         ;jmp	short iopen_0
			      C 	; 04/02/2022
 16B3  74 BC		      C 	jz	short iopen_0
 16B5  E9 EC3B		      C 	jmp	error
			      C 
			      C 	;cmp	ax, 40
			      C 		; cmp r1,$40. / no, is it a special file?
			      C         ;ja	short @b
			      C 		; bgt 3f / no, return
			      C 	;push	ax
			      C 		; mov r1,-(sp) / yes
			      C 	;mov	bx, ax
			      C 	;shl	bx, 1
			      C 		; asl r1
			      C 	;add	bx, offset ipen_3 - 2
			      C 	;jmp	word ptr [BX]
			      C 		; jmp *1f-2(r1) / figure out 
			      C 			; / which special file it is and transfer
			      C ;iopen_3: ; 1:
			      C ;	dw 	offset otty ; tty, AX = 1 (runix)
			      C  		 ;otty / tty ; r1=2
			      C         	 ;leadr / ppt ; r1=4
			      C ;	dw	offset sret ; mem, AX = 2 (runix)
			      C 		 ;sret / mem ; r1=6
			      C 		 ;sret / rf0
			      C         	 ;sret / rk0
			      C         	 ;sret / tap0
			      C         	 ;sret / tap1
			      C         	 ;sret / tap2
			      C         	 ;sret / tap3
			      C         	 ;sret / tap4
			      C         	 ;sret / tap5
			      C         	 ;sret / tap6
			      C         	 ;sret / tap7
			      C ;	dw 	offset sret ; fd0, AX = 3 (runix only)
			      C ;	dw 	offset sret ; fd1, AX = 4 (runix only)
			      C ;	dw 	offset sret ; hd0, AX = 5 (runix only)
			      C ;	dw 	offset sret ; hd1, AX = 6 (runix only)	
			      C ;	dw 	offset sret ; hd2, AX = 7 (runix only)
			      C ;	dw 	offset sret ; hd3, AX = 8 (runix only)	
			      C ;	dw	offset sret ; lpr, AX = 9  (runix)
			      C 	;dw	offset ejec ; lpr, AX = 9  (runix)
			      C ;	dw	offset sret ; tty0, AX = 10 (runix)	  
			      C 		 ;ocvt / tty0
			      C ;	dw	offset sret ; tty1, AX = 11 (runix)	  
			      C 		 ;ocvt / tty1
			      C ;	dw	offset sret ; tty2, AX = 12 (runix)	  
			      C 		 ;ocvt / tty2
			      C ;	dw	offset sret ; tty3, AX = 13 (runix)	  
			      C 		 ;ocvt / tty3
			      C ;	dw	offset sret ; tty4, AX = 14 (runix)	  
			      C 		 ;ocvt / tty4
			      C ;	dw	offset sret ; tty5, AX = 15 (runix)	  
			      C 		 ;ocvt / tty5
			      C ;	dw	offset sret ; tty6, AX = 16 (runix)	  
			      C 		 ;ocvt / tty6
			      C ;	dw	offset sret ; tty7, AX = 17 (runix)	  
			      C 		 ;ocvt / tty7
			      C ;	dw	offset ocvt ; COM1, AX = 18 (runix only)	  
			      C 		 ;/ ejec / lpr
			      C ;	dw	offset ocvt ; COM2, AX = 19 (runix only)
			      C 
 16B8			      C otty: ;/ open console tty for reading or writing
			      C 	; 03/03/2022
			      C 	; 27/01/2022
			      C 	; 13/07/2014
			      C 	; 12/07/2014
			      C 	; 15/04/2014 (modification for serial ports)
			      C 	; 26/01/2014
			      C 	; 17/01/2014
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 17/09/2013
			      C 	; 16/09/2013
			      C 	; 13/09/2013
			      C 	; 03/09/2013
			      C 	; 16/08/2013
			      C 	; 16/07/2013
			      C 	; 15/07/2013
			      C 	; 27/05/2013
			      C        	; 21/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	;
			      C 	; 16/07/2013
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;  If a tty is open for read or write by
			      C 	;     a process (u.uno), only same process can open
			      C 	;     same tty to write or read (R->R&W or W->W&R).	
			      C 	;
			      C 	; (INPUT: DL=2 for Read, DL=1 for Write, DL=0 for sysstty)
			      C 	; ah = 0
			      C 	; 06/12/2013
 16B8  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 16BC  32 FF		      C 	xor	bh, bh
 16BE  8A 87 2669 R	      C 	mov	al, byte ptr [BX]+p.ttyc-1 ; current/console tty
			      C 	; 13/01/2014
 16C2  EB 02		      C 	jmp	short ottyp
 16C4			      C ocvt:
 16C4  2C 0A		      C 	sub	al, 10
 16C6			      C ottyp:
			      C 	; 03/03/2022
			      C 	; 27/01/2022
			      C 	; 13/07/2014
			      C 	; 12/07/2014
			      C 	; 15/04/2014 (modification for serial ports)
			      C 	; 26/01/2014
			      C 	; 13/01/2014
			      C 	; 06/12/2013
 16C6  8A F0		      C 	mov	dh, al ; tty number
			      C 	; 16/08/2013
 16C8  8B D8		      C 	mov 	bx, ax ; AL = tty number (0 to 9), AH = 0
 16CA  D0 E3		      C 	shl 	bl, 1  ; aligned to word
			      C 	;26/01/2014	
 16CC  81 C3 277A R	      C 	add 	bx, offset ttyl
 16D0  8B 0F		      C 	mov 	cx, word ptr [BX]
			      C 		   ; CL = lock value (0 or process number)
			      C 		   ; CH = open count 
 16D2  22 C9		      C 	and 	cl, cl
			      C 	; 13/01/2014
 16D4  74 1C		      C 	jz 	short otty_ret
			      C 	;
 16D6  3A 0E 27DF R	      C 	cmp 	cl, byte ptr [u.uno]
 16DA  74 16		      C 	je	short otty_ret
			      C 	;
 16DC  8A D9		      C 	mov 	bl, cl ; the process which has locked the tty
 16DE  D0 E3		      C 	shl 	bl, 1
 16E0  32 FF		      C 	xor 	bh, bh
 16E2  8B 87 2608 R	      C 	mov 	ax, word ptr [BX]+p.pid-2
 16E6  8A 1E 27DF R	      C 	mov 	bl, byte ptr [u.uno]
 16EA  D0 E3		      C 	shl 	bl, 1
 16EC  3B 87 2628 R	      C 	cmp 	ax, word ptr [BX]+p.ppid-2
			      C 	;je	short otty_ret
			      C 	; 03/03/2022
 16F0  75 21		      C 	jne 	short otty_err 
			      C 		  ; the tty is locked by another process
			      C 		  ; except the parent process (p.ppid)
			      C 
			      C ;;otty_err: ; 13/01/2014
			      C 	;or 	dl, dl ; DL = 0 -> called by sysstty
			      C 	;;jnz	error
			      C 	;; 27/01/2022
			      C 	;jz	short @f
			      C 	;jmp	error
			      C ;@@:
			      C 	;stc ; 03/03/2022
			      C 	;retn
			      C 
 16F2			      C otty_ret: 
			      C 	; 13/01/2014
 16F2  80 FE 07		      C 	cmp 	dh, 7
 16F5  76 7F		      C 	jna	short ottys_ret
 16F7			      C ottys:
			      C 	; 17/01/2013
 16F7  52		      C 	push	dx ; *
 16F8  8A E2		      C 	mov	ah, dl ; open mode
 16FA  8A D6		      C 	mov	dl, dh
 16FC  32 F6		      C 	xor	dh, dh
 16FE  80 EA 08		      C 	sub	dl, 8
			      C 	;
 1701  22 E4		      C 	and	ah, ah ; sysstty system call check
 1703  74 19		      C 	jz	short com_port_init
			      C 	;
 1705  23 C9		      C 	and	cx, cx
			      C 	;jz	short @f ; unlocked/free tty (serial port) 
			      C 	; 03/03/2022
 1707  74 13		      C 	jz	short com_port_init_xor
			      C 	;
			      C 	; 13/01/2014
			      C 	; DX = port number (COM1=0, COM2=1)
 1709  B4 03		      C 	mov	ah, 3
 170B  CD 14		      C 	int	14h   ; Get serial port status
			      C 	; 13/07/2014
 170D  5A		      C 	pop	dx ; *
 170E  F6 C4 80		      C 	test	ah, 80h
 1711  74 6B		      C 	jz	short ottys_rtn
			      C 
			      C 	; 03/03/2022
 1713			      C otty_err: ; 13/01/2014
			      C 	;or 	dl, dl ; DL = 0 -> called by sysstty
			      C 	;;jnz	error
			      C 	;;stc
			      C 	;;retn
			      C 	;; 27/01/2022
			      C 	;jz	short @b ; stc, retn
			      C 	;jmp	error
			      C 
 1713  80 FA 01		      C 	cmp	dl, 1 ; DL = 0 -> called by sysstty
 1716  72 03		      C 	jb	short @f ; cf = 1, retn
 1718  E9 EBD8		      C 	jmp	error
 171B			      C @@:	; 03/03/2022
 171B  C3		      C 	retn
			      C 
 171C			      C com_port_init_xor:
			      C ;@@:
 171C  32 E4		      C 	xor 	ah, ah ; 0
 171E			      C com_port_init:
 171E  BE 279A R	      C 	mov	si, offset com1p
 1721  0A D2		      C 	or	dl, dl ; COM1 ?
 1723  74 01		      C 	jz	short @f ; yes, it is COM1
 1725  46		      C 	inc	si 	 ; no, it is COM2
 1726			      C @@:
 1726  8A 04		      C 	mov 	al, byte ptr [SI] ; comm. parameters
			      C 	;		
			      C 	; Initializing serial port parameters
			      C 	;xor 	ah, ah ; 0
			      C 	; AL = Communication parameters
			      C 	; DX = Serial port number (COM1 = 0, COM2 = 1)
 1728  CD 14		      C 	int 	14h  ; Initialize serial port parameters
			      C 		;
			      C  		; (Note: Serial port interrupts 
			      C 		;	will be disabled here...)	
			      C 	       	; (INT 14h initialization code 
			      C 		;	disables interrupts.)
			      C 	; 13/07/2014
 172A  22 D2		      C 	and	dl, dl
 172C  74 19		      C 	jz	short com1p_eirq
			      C 	;
			      C 	;; COM2 - enabling IRQ 3
 172E  BA 02FC		      C 	mov	dx, 2FCh   ;modem control register
 1731  EC		      C 	in	al, dx 	   ;read register
 1732  0C 08		      C 	or	al, 8      ;enable bit 3 (OUT2)
 1734  EE		      C 	out	dx, al     ;write back to register
 1735  BA 02F9		      C 	mov	dx, 2F9h   ;interrupt enable register
 1738  EC		      C 	in	al, dx     ;read register
 1739  0C 01		      C 	or	al, 1      ;receiver data interrupt enable
 173B  EE		      C 	out	dx, al 	   ;write back to register
 173C  E4 21		      C 	in	al, 21h    ;read interrupt mask register
 173E  24 F7		      C 	and	al, 0F7h   ;enable IRQ 3 (COM2)
 1740  E6 21		      C 	out	21h, al    ;write back to register
 1742  BA 0001		      C 	mov	dx, 1
 1745  EB 16		      C 	jmp	short comp_get_stat
 1747			      C com1p_eirq:
			      C 	;; COM1 - enabling IRQ 4
 1747  BA 03FC		      C 	mov	dx, 3FCh   ;modem control register
 174A  EC		      C 	in	al, dx 	   ;read register
 174B  0C 08		      C 	or	al, 8      ;enable bit 3 (OUT2)
 174D  EE		      C 	out	dx, al     ;write back to register
 174E  BA 03F9		      C 	mov	dx, 3F9h   ;interrupt enable register
 1751  EC		      C 	in	al, dx     ;read register
 1752  0C 01		      C 	or	al, 1      ;receiver data interrupt enable
 1754  EE		      C 	out	dx, al 	   ;write back to register
 1755  E4 21		      C 	in	al, 21h    ;read interrupt mask register
 1757  24 EF		      C 	and	al, 0EFh   ;enable IRQ 4 (COM1)
 1759  E6 21		      C 	out	21h, al    ;write back to register
 175B  33 D2		      C 	xor	dx, dx
 175D			      C comp_get_stat:
 175D  B4 03		      C 	mov	ah, 3
 175F  CD 14		      C 	int	14h   ; Get serial port status
			      C 	;
 1761  F6 C4 80		      C 	test 	ah, 80h
 1764  74 0F		      C 	jz	short comp_init_ok ; successfully initialized
			      C 	; Initialization ERROR !
			      C  		; 11100011b ; E3h
			      C                 ; (111) Baud rate: 9600, (00) parity: none,
			      C                 ; (0) stop bits: 1, (11) word length: 8 bits
			      C 	; 15/04/2014
 1766  80 3C E3		      C 	cmp	byte ptr [SI], 0E3h
 1769  74 07		      C 	je	short @f
			      C 	;	
 176B  C6 04 E3		      C 	mov 	byte ptr [SI], 0E3h ; Reset comm. parameters
 176E  32 E4		      C 	xor	ah, ah
 1770  EB B4		      C 	jmp	short @b
 1772			      C @@:
			      C 	; 12/07/2014
 1772  5A		      C 	pop	dx ; *
			      C 	;stc
			      C 	;retn
			      C 	; 03/03/2022
 1773  EB 9E		      C 	jmp	short otty_err
			      C 
 1775			      C comp_init_ok:
			      C 	; 12/07/2014
 1775  5A		      C 	pop	dx ; *
 1776			      C ottys_ret:
 1776  0A C9		      C 	or	cl, cl  ; cl = lock/owner, ch = open count
 1778  75 04		      C 	jnz	short @f
 177A  8A 0E 27DF R	      C 	mov	cl, byte ptr [u.uno]
 177E			      C ottys_rtn:
 177E			      C @@: 
 177E  FE C5		      C 	inc 	ch
 1780  89 0F		      C 	mov 	word ptr [BX], cx ; set tty lock again
			      C 	; 06/12/2013
 1782  FE C6		      C 	inc	dh ; tty number + 1
 1784  BB 27C6 R	      C 	mov	bx, offset u.ttyp
			      C 	; 13/01/2014
 1787  F6 C2 02		      C 	test	dl, 2 ; open for read sign
 178A  75 01		      C 	jnz	short @f
 178C  43		      C 	inc	bx
 178D			      C @@:
			      C 	; Set 'u.ttyp' ('the recent TTY') value
 178D  88 37		      C 	mov 	byte ptr [BX], dh ; tty number + 1
 178F			      C sret:
 178F  0A D2		      C 	or	dl, dl ; sysstty system call check (DL=0)
 1791  74 01		      C 	jz	short @f
 1793  58		      C 	pop 	ax
 1794			      C @@:	
 1794  C3		      C 	retn
			      C 
			      C 	;
			      C 	; Original UNIX v1 'otty' routine:
			      C 	;	
			      C 	;mov    $100,*$tks / set interrupt enable bit (zero others) in
			      C         ;                 / reader status reg
			      C         ;mov    $100,*$tps / set interrupt enable bit (zero others) in
			      C         ;                 / punch status reg
			      C         ;mov    tty+[ntty*8]-8+6,r5 / r5 points to the header of the
			      C         ;                          / console tty buffer
			      C         ;incb   (r5) / increment the count of processes that opened the
			      C         ;            / console tty
			      C         ;tst    u.ttyp / is there a process control tty (i.e., has a tty
			      C         ;             / buffer header
			      C         ;bne    sret / address been loaded into u.ttyp yet)?  yes, branch
			      C         ;mov    r5,u.ttyp / no, make the console tty the process control
			      C         ;                 / tty
			      C         ;br     sret / ?
			      C ;sret:
			      C 		;clr *$ps / set processor priority to zero
			      C ;	pop	ax
			      C         	;mov (sp)+,r1 / pop stack to r1
			      C ;3:
			      C ;	retn
			      C         	;rts r0
			      C 	
			      C ;ocvt:	; < open tty >
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 16/09/2013
			      C 	; 03/09/2013
			      C 	; 27/08/2013
			      C 	; 16/08/2013
			      C 	; 16/07/2013
			      C 	; 27/05/2013
			      C 	; 21/05/2013
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; In original UNIX v1, 'ocvt' routine 
			      C 	;		(exactly different than this one)
			      C 	;	was in 'u9.s' file.
			      C 	;
			      C 	; 16/07/2013
			      C 	; Retro UNIX 8086 v1 modification:
			      C 	;  If a tty is open for read or write by
			      C 	;     a process (u.uno), only same process can open
			      C 	;     same tty to write or read (R->R&W or W->W&R).	
			      C 	;
			      C 	; INPUT: DL=2 for Read DL=1 for Write
			      C 
			      C 	; 16/09/2013
			      C 	; sub 	al, 10
			      C 	
			      C 	; 06/12/2013
			      C 	;cmp	al, 7
			      C         ;jna     short ottyp
			      C 	; 13/01/2014
			      C 	;jmp	short ottyp
			      C 
			      C 
			      C ;oppt: / open paper tape for reading or writing
			      C ;        mov    $100,*$prs / set reader interrupt enable bit
			      C ;        tstb   pptiflg / is file already open
			      C ;        bne    2f / yes, branch
			      C ;1:
			      C ;        mov    $240,*$ps / no, set processor priority to 5
			      C ;        jsr    r0,getc; 2 / remove all entries in clist
			      C ;               br .+4 / for paper tape input and place in free list
			      C ;        br     1b
			      C ;        movb   $2,pptiflg / set pptiflg to indicate file just open
			      C ;        movb   $10.,toutt+1 / place 10 in paper tape input tout entry
			      C ;        br     sret
			      C ;2:
			      C ;        jmp    error / file already open
			      C 
 1795			      C iclose: 
			      C 	; 04/02/2022
			      C 	; 13/01/2014
			      C 	; 12/01/2014
			      C 	; 27/08/2013
			      C 	; 16/08/2013
			      C 	; 30/07/2013
			      C 	; 16/07/2013
			      C 	; 21/05/2013
			      C 	;
			      C 	; close file whose i-number is in r1
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - inode number
			      C 	; OUTPUTS ->
			      C 	;    file's inode in core	
			      C 	;    r1 - inode number (positive)
			      C 	;
			      C 	; ((AX = R1))
			      C         ;    ((Modified registers: -BX-, DX)) 
			      C 	;        
			      C ;/ close file whose i-number is in r1
 1795  B2 02		      C 	mov	dl, 2 ; 12/01/2014
 1797  F6 C4 80		      C 	test	ah, 80h ; Bit 15 of AX
			      C 		;tst r1 / test i-number
			      C         ;jnz	short iclose_2
			      C 		;blt 2f / if neg., branch
 179A  74 04		      C 	jz	short iclose_0 ; 30/07/2013
			      C 	; 16/07/2013 
 179C  F7 D8		      C 	neg	ax ; make it positive
			      C 	; 12/01/2014
 179E  FE CA		      C 	dec	dl ; dl = 1 (open for write)
 17A0			      C iclose_0:
 17A0  83 F8 28		      C 	cmp	ax, 40
			      C 		;cmp r1,$40. / is it a special file
 17A3  77 EF		      C         ja	short @b  ; 13/01/2014
			      C 		;bgt 3b / no, return
			      C 	; 12/01/2014
			      C 	; DL=2 -> special file was opened for reading
			      C 	; DL=1 -> special file was opened for writing
 17A5  50		      C 	push	ax
			      C 		;mov r1,-(sp) / yes, save r1 on stack
 17A6  8B D8		      C 	mov	bx, ax
			      C 	; 04/02/2022
 17A8  D0 E3		      C 	shl	bl, 1
			      C 	;shl	bx, 1
			      C 		; asl r1
 17AA  81 C3 17AE R	      C 	add	bx, offset iclose_1 - 2
 17AE  FF 27		      C 	jmp	word ptr [BX]
			      C 		; jmp *1f-2(r1) / compute jump address and transfer
 17B0			      C iclose_1 :
 17B0  17D6 R		      C 	dw 	offset ctty ; tty, AX = 1 (runix)
 17B2  1811 R		      C 	dw	offset cret ; mem, AX = 2 (runix)
 17B4  1811 R		      C 	dw 	offset cret ; fd0, AX = 3 (runix only)
 17B6  1811 R		      C 	dw 	offset cret ; fd1, AX = 4 (runix only)
 17B8  1811 R		      C 	dw 	offset cret ; hd0, AX = 5 (runix only)
 17BA  1811 R		      C 	dw 	offset cret ; hd1, AX = 6 (runix only)	
 17BC  1811 R		      C 	dw 	offset cret ; hd2, AX = 7 (runix only)
 17BE  1811 R		      C 	dw 	offset cret ; hd3, AX = 8 (runix only)	
 17C0  1811 R		      C 	dw	offset cret ; lpr, AX = 9 (runix)
			      C 	;dw	offset error; lpr, AX = 9 (error !)
			      C 	;;dw	offset ejec ;;lpr, AX = 9  
 17C2  17E2 R		      C 	dw	offset ccvt ; tty0, AX = 10 (runix)	  
 17C4  17E2 R		      C 	dw	offset ccvt ; tty1, AX = 11 (runix)	  
 17C6  17E2 R		      C 	dw	offset ccvt ; tty2, AX = 12 (runix)	  
 17C8  17E2 R		      C 	dw	offset ccvt ; tty3, AX = 13 (runix)	  
 17CA  17E2 R		      C 	dw	offset ccvt ; tty4, AX = 14 (runix)	  
 17CC  17E2 R		      C 	dw	offset ccvt ; tty5, AX = 15 (runix)	  
 17CE  17E2 R		      C 	dw	offset ccvt ; tty6, AX = 16 (runix)	  
 17D0  17E2 R		      C 	dw	offset ccvt ; tty7, AX = 17 (runix)	  
 17D2  17E2 R		      C 	dw	offset ccvt ; COM1, AX = 18 (runix only)	  
 17D4  17E2 R		      C 	dw	offset ccvt ; COM2, AX = 19 (runix only)
			      C 
			      C 	; 1:
			      C 	;        ctty   / tty
			      C 	;        cppt   / ppt
			      C 	;        sret   / mem
			      C 	;        sret   / rf0
			      C 	;        sret   / rk0
			      C 	;        sret   / tap0
			      C 	;        sret   / tap1
			      C 	;        sret   / tap2
			      C 	;        sret   / tap3
			      C 	;        sret   / tap4
			      C 	;        sret   / tap5
			      C 	;        sret   / tap6
			      C 	;        sret   / tap7
			      C 	;        ccvt   / tty0
			      C 	;        ccvt   / tty1
			      C 	;        ccvt   / tty2
			      C 	;        ccvt   / tty3
			      C 	;        ccvt   / tty4
			      C 	;        ccvt   / tty5
			      C 	;        ccvt   / tty6
			      C 	;        ccvt   / tty7
			      C 	;        error / crd
			      C 
			      C ;iclose_2: ; 2: / negative i-number
			      C 	;neg	ax
			      C 		;neg r1 / make it positive
			      C 	;cmp	ax, 40
			      C 		;cmp r1,$40. / is it a special file?
			      C         ;ja	short @b
			      C 		;bgt    3b / no. return
			      C 	;push	ax
			      C 		;mov r1,-(sp)
			      C 	;mov	bx, ax
			      C 	;shl	bx, 1
			      C 		;asl r1 / yes. compute jump address and transfer
			      C 	;add	bx, offset iclose_3 - 2
			      C 	;jmp	word ptr [BX]
			      C 		;jmp *1f-2(r1) / figure out 
			      C ;iclose_3:
			      C 	;dw 	offset ctty ; tty, AX = 1 (runix)
			      C 	;dw	offset sret ; mem, AX = 2 (runix)
			      C 	;dw 	offset sret ; fd0, AX = 3 (runix only)
			      C 	;dw 	offset sret ; fd1, AX = 4 (runix only)
			      C 	;dw 	offset sret ; hd0, AX = 5 (runix only)
			      C 	;dw 	offset sret ; hd1, AX = 6 (runix only)	
			      C 	;dw 	offset sret ; hd2, AX = 7 (runix only)
			      C 	;dw 	offset sret ; hd3, AX = 8 (runix only)
			      C 	 ;dw	offset sret ; lpr, AX = 9	
			      C 	;dw	offset ejec ; lpr, AX = 9  (runix)
			      C 	;dw	offset ccvt ; tty0, AX = 10 (runix)	  
			      C 	;dw	offset ccvt ; tty1, AX = 11 (runix)	  
			      C 	;dw	offset ccvt ; tty2, AX = 12 (runix)	  
			      C 	;dw	offset ccvt ; tty3, AX = 13 (runix)	  
			      C 	;dw	offset ccvt ; tty4, AX = 14 (runix)	  
			      C 	;dw	offset ccvt ; tty5, AX = 15 (runix)	  
			      C 	;dw	offset ccvt ; tty6, AX = 16 (runix)	  
			      C 	;dw	offset ccvt ; tty7, AX = 17 (runix)	  
			      C 	;dw	offset ccvt ; COM1, AX = 18 (runix only)	  
			      C 	;dw	offset ccvt ; COM2, AX = 19 (runix only) 
			      C 	
			      C 	;1:
			      C 	;      	ctty   / tty
			      C 	;       leadr  / ppt
			      C 	;       sret   / mem
			      C 	;       sret   / rf0
			      C 	;       sret   / rk0
			      C 	;       sret   / tap0
			      C 	;       sret   / tap1
			      C 	;       sret   / tap2
			      C 	;       sret   / tap3
			      C 	;       sret   / tap4
			      C 	;       sret   / tap5
			      C 	;       sret   / tap6
			      C 	;       sret   / tap7
			      C 	;       ccvt   / tty0
			      C 	;       ccvt   / tty1
			      C 	;       ccvt   / tty2
			      C 	;       ccvt   / tty3
			      C 	;       ccvt   / tty4
			      C 	;       ccvt   / tty5
			      C 	;       ccvt   / tty6
			      C 	;       ccvt   / tty7
			      C 	;/       ejec / lpr
			      C 
 17D6			      C ctty: ; / close console tty
			      C 	; 27/01/2022
			      C 	; 26/01/2014
			      C 	; 17/01/2014
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 24/09/2013 consistency check -> OK
			      C 	; 17/09/2013
			      C 	; 16/09/2013
			      C 	; 03/09/2013
			      C 	; 16/08/2013
			      C 	; 13/08/2013
			      C 	; 05/08/2013
			      C 	; 30/07/2013
			      C 	; 16/07/2013
			      C 	; 27/05/2013
			      C        	; 21/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	;
			      C 	; (DL = 2 -> it is open for reading)
			      C 	; (DL = 1 -> it is open for writing)
			      C 	; (DL = 0 -> it is open for sysstty system call)
			      C 	;
			      C 	; 06/12/2013
 17D6  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 17DA  32 FF		      C 	xor	bh, bh
 17DC  8A 87 2669 R	      C 	mov	al, byte ptr [BX]+p.ttyc-1
			      C 	; 13/01/2014
 17E0  EB 02		      C 	jmp	short cttyp
 17E2			      C ccvt:
 17E2  2C 0A		      C 	sub	al, 10
 17E4			      C cttyp:	
			      C 	; 27/01/2022
			      C 	; 26/01/2014
			      C  	; 13/01/2014
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 16/08/2013
			      C 	; AH = 0
 17E4  8B D8		      C 	mov 	bx, ax ; tty number (0 to 9)
 17E6  D0 E3		      C 	shl 	bl, 1  ; aligned to word	
			      C 	; 26/01/2014
 17E8  81 C3 277A R	      C 	add 	bx, offset ttyl
 17EC  8A F0		      C 	mov 	dh, al ; tty number
 17EE  8B 07		      C 	mov 	ax, word ptr [BX]
			      C 		   ; AL = lock value (0 or process number)
			      C 		   ; AH = open count 
 17F0  22 E4		      C 	and 	ah, ah 
			      C 	;;jz 	short ctty_err ; open count = 0, it is not open !
			      C 	;jz	error
			      C 	; 27/01/2022
 17F2  75 03		      C 	jnz	short ctty_ret
 17F4  E9 EAFC		      C 	jmp	error
			      C 	; 26/01/2014
 17F7			      C ctty_ret:
 17F7  FE CC		      C 	dec 	ah ; decrease open count
 17F9  75 02		      C 	jnz	short @f
 17FB  32 C0		      C 	xor	al, al ; unlock/free tty
 17FD			      C @@:
 17FD  89 07		      C 	mov 	word ptr [BX], ax ; close tty instance
			      C 	;
 17FF  BB 27C6 R	      C 	mov	bx, offset u.ttyp
 1802  F6 C2 01		      C 	test	dl, 1 ; open for write sign
 1805  74 01		      C 	jz	short @f
 1807  43		      C 	inc	bx
 1808			      C @@:
 1808  FE C6		      C 	inc	dh ; tty number + 1
 180A  3A 37		      C 	cmp	dh, byte ptr [BX]
 180C  75 03		      C 	jne	short cret
			      C 	; Reset/Clear 'u.ttyp' ('the recent TTY') value
 180E  C6 07 00		      C 	mov	byte ptr [BX], 0
 1811			      C cret:
 1811  0A D2		      C 	or	dl, dl ; sysstty system call check (DL=0)
 1813  74 01		      C 	jz	short @f
 1815  58		      C 	pop	ax
 1816			      C @@:
 1816  C3		      C 	retn
			      C 
			      C ;ctty_err: ; 13/01/2014
			      C ;	or 	dl, dl ; DL = 0 -> called by sysstty
			      C ;	jnz	error
			      C ;	stc
			      C ;	retn
			      C 
			      C 	; Original UNIX v1 'ctty' routine:
			      C 	;	
			      C         ;mov    tty+[ntty*8]-8+6,r5 
			      C 	;		;/ point r5 to the console tty buffer
			      C         ;decb   (r5) / dec number of processes using console tty
			      C         ;br     sret / return via sret
			      C 
			      C ;ccvt:	; < close tty >
			      C 	; 13/01/2014
			      C 	; 06/12/2013 (major modification: p.ttyc, u.ttyp)
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 17/09/2013
			      C 	; 03/09/2013
			      C 	; 27/08/2013
			      C 	; 16/08/2013
			      C 	; 30/07/2013
			      C 	; 16/07/2013
			      C 	; 27/05/2013
			      C 	; 21/05/2013
			      C 	;
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; In original UNIX v1, 'ccvt' routine 
			      C 	;		(exactly different than this one)
			      C 	;	was in 'u9.s' file.
			      C 	;
			      C 	; DL = 2 -> it is open for reading
			      C 	; DL = 1 -> it is open for writing
			      C 	;
			      C 	; 17/09/2013
			      C 	;sub 	al, 10
			      C 	;cmp	al, 7
			      C 	;jna	short cttyp
			      C 	; 13/01/2014
			      C 	;jmp	short cttyp
			      C 
			      C 
			      C ;cppt: / close paper tape
			      C ;        clrb   pptiflg / set pptiflg to indicate file not open
			      C ;1:
			      C ;        mov    $240,*$ps /set process or priority to 5
			      C ;        jsr    r0,getc; 2 / remove all ppt input entries from clist
			      C ;                          / and assign to free list
			      C ;               br sret
			      C ;        br     1b
			      C 
			      C ;ejec:	
			      C ;	jmp	error
			      C ;/ejec:
			      C ;/       mov    $100,*$lps / set line printer interrupt enable bit
			      C ;/       mov    $14,r1 / 'form feed' character in r1 (new page).
			      C ;/       jsr    r0,lptoc / space the printer to a new page
			      C ;/       br     sret / return to caller via 'sret'
			      C 
 1817			      C ejec:
			      C 	; 13/06/2022 - Retro UNIX 8086 v1 (Kernel v0.1.0.3)
			      C 	;	Printer Initialization
 1817			      C lpt_init:	
			      C 	; Default printer port: 378h ; LPT1
			      C 	
 1817  B4 01		      C  	mov	ah, 1  ; INITIALIZE THE PRINTER PORT
			      C 	;xor	dx, dx ; 0 = LPT1
			      C 	;int	17h
 1819  E8 FCA3		      C 	call	PRNOP
 181C  74 0A		      C 	jz	short lpt_init_ok
			      C 	
 181E  8A C4		      C 	mov	al, ah ; printer port status flags
 1820  32 E4		      C 	xor	ah, ah
 1822  A3 27A8 R	      C 	mov	word ptr [u.r0], ax
 1825  E9 EACB		      C 	jmp	error
			      C 	
 1828			      C lpt_init_ok:
 1828  58		      C 	pop	ax    ; inode number
 1829  C3		      C 	retn
			      C 
				include u8.asm ; u8.s
			      C ; ****************************************************************************
			      C ;
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U8.ASM (include u8.asm) //// UNIX v1 -> u8.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (13/03/2013)
			      C ;
			      C ; [ Last Modification: 15/07/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C 
			      C ; 15/07/2022 - Retro UNIX 8086 v1 (Retro UNIX Kernel v0.1.0.4)
			      C ;	(simplified and improved buffer handling - retro unix feature only)
			      C ; 26/02/2022
			      C ; 04/02/2022
			      C ; 28/01/2022
			      C ; 27/01/2022
			      C ; 14/07/2015
			      C ; 18/01/2014
			      C ; 03/08/2013 dskwr
			      C ; 31/07/2013
			      C ; 29/07/2013
			      C ; 26/07/2013 bread, bwrite (bug) note
			      C ; 23/07/2013 poke
			      C ; 20/07/2013 poke, bufaloc, bread, bwrite, dskrd, dskwr, wslot
			      C ; 17/07/2013 poke
			      C ; 09/07/2013 bufaloc, poke
			      C ; 26/04/2013 device number modifications (cdev/0/1 -> 0/rdev, 1/mdev -> drv)
			      C ; 18/04/2013
			      C ; 24/03/2013 poke
			      C ; 15/03/2013 poke, diskio (runix)
			      C ; 14/03/2013
			      C ; 13/03/2013
			      C 
			      C ; 15/07/2022 - Retro UNIX 8086 v1 (Kernel v0.1.0.4)
			      C ;---------------------------------------------------------------------
			      C ; Buffer Header: -4 bytes-
			      C ; word 1 - byte 0 - device (disk index) number (0 to 5)
			      C ;	   byte 1 - status bits
			      C ;	 	bit 0 - valid buffer bit (1 = valid, 0 = invalid, new)
			      C ;		bit 1 - write bit (also modified bit)
			      C ;		bit 2 - read bit	
			      C ;		bit 3 to bit 7 are not used
			      C ; word 2 - physical block/sector address (16 bit LBA)
			      C ;---------------------------------------------------------------------
			      C 
			      C ;; I/O Buffer ((8+512 bytes in original Unix v1))
			      C ;;	      ((4+512 bytes in Retro UNIX 8086 v1))
			      C ;;
			      C ;; I/O Queue Entry (of original UNIX operating system v1)
			      C ;; Word 1, Byte 0 = device id
			      C ;; Word 1, Byte 1 = (bits 8 to 15)
			      C ;;          bit 9 = write bit
			      C ;;	    bit 10 = read bit	  
			      C ;;	    bit 12 = waiting to write bit	
			      C ;;	    bit 13 = waiting to read bit
			      C ;;	    bit 15 = inhibit bit
			      C ;; Word 2 = physical block number (In fact, it is LBA for Retro UNIX 8086 v1)
			      C ;;
			      C ;; Original UNIX v1 ->
			      C ;;		Word 3 = number of words in buffer (=256) 		
			      C ;; Original UNIX v1 -> 
			      C ;;		Word 4 = bus address (addr of first word of data buffer)
			      C ;;
			      C ;; Retro UNIX 8086 v1 -> Buffer Header (I/O Queue Entry) size is 4 bytes !
			      C ;;
			      C ;; Device IDs (of Retro Unix 8086 v1)
			      C ;;          0 = fd0
			      C ;;	    1 = fd1
			      C ;;	    2 = hd0
			      C ;;	    3 = hd1
			      C ;;	    4 = hd2
			      C ;;	    5 = hd3
			      C 
			      C 	; 04/02/2022
 182A			      C rfd:	; 26/04/2013
			      C    	; 13/03/2013 Retro UNIX 8086 v1 device (not an original unix v1 device)
			      C    	;sub 	ax, 3 ; zero based device number (Floppy disk)
 182A  B9 0B40		      C    	mov 	cx, 2880 ; size of floppy disks (1.44 MB)
 182D  E8 0012		      C    	call 	bread ; **** returns to routine that called readi ('jmp ret')
			      C 	; 04/02/2022			
 1830			      C wfd:    ; 26/04/2013
			      C    	; 14/03/2013 Retro UNIX 8086 v1 device (not an original unix v1 device)
			      C    	;sub 	ax, 3 ; zero based device number (Floppy disk)
 1830  B9 0B40		      C    	mov 	cx, 2880 ; size of floppy disks (1.44 MB)
 1833  E8 0053		      C    	call 	bwrite ; **** returns to routine that called writei ('jmp ret')
			      C 	; 04/02/2022
 1836			      C rhd:	; 26/04/2013
			      C    	; 14/03/2013 Retro UNIX 8086 v1 device (not an original unix v1 device)
			      C    	;sub 	ax, 3 ; zero based device number (Hard disk)
 1836  B9 FFFF		      C    	mov 	cx, 0FFFFh ; size of fixed disks (32 MB, first 65535 sectors)
 1839  E8 0006		      C    	call 	bread ; **** returns to routine that called readi ('jmp ret')
			      C 	; 04/04/2022
 183C			      C whd:	; 14/03/2013 Retro UNIX 8086 v1 device (not an original unix v1 device)
			      C    	;sub 	ax, 3 ; zero based device number (Hard disk)
 183C  B9 FFFF		      C    	mov 	cx, 0FFFFh ; size of fixed disks (32 MB, first 65535 sectors)
 183F  E8 0047		      C    	call 	bwrite ; **** returns to routine that called writei ('jmp ret')
			      C 
 1842			      C bread: 	
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 04/02/2022
			      C 	;	(Retro UNIX 8086 v1 2022 Bugfix, *[u.fofp] = block position)
			      C 	; 27/01/2022
			      C 	; 14/07/2015
			      C 	; 11/06/2015
			      C 	; 29/07/2013
			      C 	; 20/07/2013
			      C 	; 26/04/2013 Retro Unix 8086 v1 feature (device number) modifications
			      C 	; 14/03/2013
			      C 	; 13/03/2013 Retro UNIX 8086 v1 modification on original unix code
			      C 	;; / read a block from a block structured device
			      C 	;
			      C 	; INPUTS ->
			      C 	;    [u.fofp] points to the block number
			      C 	;    CX = maximum block number allowed on device
			      C 	;	 ; that was an arg to bread, in original Unix v1, but
			      C 	;	 ; CX register is used instead of arg in Retro Unix 8086 v1
			      C 	;    [u.count] number of bytes to read in
			      C 	; OUTPUTS ->
			      C 	;    [u.base] starting address of data block or blocks in user area
			      C 	;    [u.fofp] points to next consecutive block to be read
			      C 	;
			      C 	; ((Modified registers: AX, DX, CX, BX, SI, DI, BP))
			      C 	;
			      C 	; NOTE: Original UNIX v1 has/had a defect/bug here, even if read
			      C 	;       byte count is less than 512, block number in *u.fofp (u.off)
			      C 	;	is increased by 1. For example: If user/program request 
			      C 	;       to read 16 bytes in current block, 'sys read' increaces
			      C 	;  	the next block number just as 512 byte reading is done.
			      C 	;       This wrong is done in 'bread'. So, in Retro UNIX 8086 v1, 
			      C 	;       for user (u) structure compatibility (because 16 bit is not
			      C 	;       enough to keep byte position/offset of the disk), this
			      C 	;	defect will not be corrected, user/program must request
			      C 	;	512 byte read per every 'sys read' call to block devices
			      C 	;       for achieving correct result. In future version(s), 
			      C 	;	this defect will be corrected by using different 
			      C 	;       user (u) structure. 26/07/2013 - Erdogan Tan 	
			      C 
			      C 	   	; jsr r0,tstdeve / error on special file I/O 
			      C 			       ; / (only works on tape)
			      C 		; mov *u.fofp,r1 / move block number to r1
			      C 		; mov $2.-cold,-(sp) / "2-cold" to stack
			      C ; 1:
			      C 		; cmp r1,(r0) / is this block # greater than or equal to
			      C 			    ; / maximum block # allowed on device
			      C 		; jnb short @f
			      C 		; bhis	1f / yes, 1f (error)
			      C 		; mov r1,-(sp) / no, put block # on stack
			      C 		; jsr r0,preread / read in the block into an I/O buffer
			      C 		; mov (sp)+,r1 / return block # to r1
			      C 		; inc r1 / bump block # to next consecutive block
			      C 		; dec (sp) / "2-1-cold" on stack
			      C 		; bgt 1b / 2-1-cold = 0? No, go back and read in next block
			      C ;1:
			      C 		; tst (sp)+ / yes, pop stack to clear off cold calculation
			      C 	;push	cx ; **
			      C 	; 26/04/2013
			      C 	;sub	ax, 3 ; 3 to 8 -> 0 to 5
 1842  2C 03		      C 	sub	al, 3
			      C 		; AL = Retro Unix 8086 v1 disk (block device) number
 1844  BF 26EA R	      C 	mov	di, offset brwdev ; block device number for direct I/O
 1847  88 05		      C 	mov	byte ptr [DI], al
 1849			      C bread0:	
			      C 	;; 11/06/2015
			      C 	;push	cx ; ** ; number of disk sectors (disk capacity)
			      C 	; 14/07/2015 (Retro UNIX 8086 v1 modification!)
			      C 	; [u.fofp] points to byte position on disk, not sector/block !
 1849  8B 1E 27B6 R	      C 	mov	bx, word ptr [u.fofp]
			      C 		; mov *u.fofp,r1 / restore r1 to initial value of the
 184D			      C bread1:			       ; / block #
			      C 	; 04/02/2022
			      C 	;push	cx ; ** ; number of disk sectors (disk capacity)
			      C 
			      C 	;mov	al, byte ptr [BX+1]
			      C         ;cbw
			      C         ;shr	al, 1 ; convert byte position to block/sector number
			      C 
			      C 	; 04/02/2022
			      C 	; *[u.fofp] points to sector/block position on disk
 184D  8B 07		      C 	mov	ax, word ptr [BX] ; current block pos/addr (for block r/w)
			      C 	; ax = disk block address
			      C 	
 184F  3B C1		      C 	cmp	ax, cx
			      C 		; cmp r1,(r0)+ / block # greater than or equal to maximum
			      C        	                     ; / block number allowed
			      C 	;jnb	error 	     ; 18/04/2013
			      C 		; bhis error10 / yes, error
			      C 	; 27/01/2022
 1851  72 03		      C 	jb	short @f
 1853  E9 EA9D		      C 	jmp	error
 1856			      C @@:
			      C 	; 04/02/2022 (Retro UNIX 8086 v1 2022)
 1856  51		      C 	push	cx ; ** ; number of disk sectors (disk capacity)
 1857  53		      C 	push	bx ; * ; *u.fofp 
			      C 	;
			      C 	;inc 	word ptr [BX]
			      C 		; inc *u.fofp / no, *u.fofp has next block number
			      C 	; AX = Block number (zero based)
			      C 		;;jsr r0,preread / read in the block whose number is in r1
 1858			      C preread: ;; call preread
 1858  E8 00F5		      C 	call	bufaloc_0 ; 26/04/2013
			      C 	;;jc 	error
			      C 	; BX = Buffer (Header) Address (r5) (ES=CS=DS, system/kernel segment)
			      C         ; AX = Block/Sector number (r1)
			      C 	        ; jsr r0,bufaloc / get a free I/O buffer (r1 has block number)
			      C 	; 14/03/2013
 185B  74 07		      C         jz	short @f ; Retro UNIX 8086 v1 modification
			      C        		; br 1f / branch if block already in a I/O buffer
 185D  81 0F 0400	      C 	or	word ptr [BX], 400h ; set read bit (10) in I/O Buffer
			      C         	; bis $2000,(r5) / set read bit (bit 10 in I/O buffer)
 1861  E8 00BF		      C 	call	poke
			      C         	; jsr r0,poke / perform the read
			      C 	;;jc	error ; 20/07/2013
			      C ; 1:
			      C  		; clr *$ps / ps = 0
			      C         	; rts r0
			      C ;; return from preread
 1864			      C @@:
			      C 	; 15/07/2022
			      C 	;or	word ptr [BX], 4000h 
			      C 	;	; bis $40000,(r5) 
			      C 	;		; / set bit 14 of the 1st word of the I/O buffer
 1864			      C @@: ; 1:
			      C 	; 15/07/2022
			      C 	;test	word ptr [BX], 2400h
			      C 	;	; bit $22000,(r5) / are 10th and 13th bits set (read bits)
			      C 	;jz	short @f
			      C 	;	; beq 1f / no
			      C 	;	; cmp cdev,$1 / disk or drum?
			      C 	;	; ble 2f / yes
			      C 	;	; tstb uquant / is the time quantum = 0?
			      C 	;	; bne 2f / no, 2f
			      C 	;	; mov r5,-(sp) / yes, save r5 (buffer address)
			      C 	;	; jsr r0,sleep; 31. 
			      C 	;		; / put process to sleep in channel 31 (tape)
			      C 	;	; mov (sp)+,r5 / restore r5
			      C 	;	; br 1b / go back
			      C ;@@: ; 2: / drum or disk
			      C 	; 15/07/2022
			      C         ;; mov	cx, word ptr [s.wait_]+2 ;; 29/07/2013
			      C 	;call	idle
			      C 	;	; jsr r0,idle; s.wait+2 / wait
			      C 	;jmp	short @b
			      C        	;	; br 1b
 1864			      C @@: ; 1: / 10th and 13th bits not set
			      C 	; 15/07/2022
			      C 	;and	word ptr [BX], 0BFFFh ; 1011111111111111b
			      C 	;	; bic $40000,(r5) / clear bit 14
			      C        	;	; jsr r0,tstdeve / test device for error (tape)
			      C 	;
			      C 	;add	bx, 8
			      C 	; 26/04/2013
 1864  83 C3 04		      C 	add	bx, 4 ; Retro Unix 8086 v1 modification !
			      C 		; add $8,r5 / r5 points to data in I/O buffer
			      C 	; BX = system (I/O) buffer address
 1867  E8 005F		      C 	call	dioreg
			      C        		; jsr r0,dioreg / do bookkeeping on u.count etc.
			      C 	; 14/07/2015
			      C 	; SI = start address of the transfer (in the buffer)
			      C 	; DI = [u.base] value before it gets updated
			      C 	; CX = transfer count (in bytes)
			      C ;1: / r5 points to beginning of data in I/O buffer, r2 points to beginning
			      C ;   / of users data
 186A  A1 27E0 R	      C         mov     ax, word ptr [u.segmnt] 
			      C 		; Retro Unix 8086 v1 feature only
 186D  8E C0		      C 	mov	es, ax
 186F  F3/ A4		      C 	rep	movsb
 1871  8C D8		      C 	mov	ax, ds
 1873  8E C0		      C 	mov	es, ax
			      C 		; movb (r5)+,(r2)+ / move data from the I/O buffer
			      C        		; dec r3 / to the user's area in core starting at u.base
			      C        		; bne 1b
			      C 	; 04/02/2022
 1875  5B		      C 	pop	bx ; * ; *u.fofp
 1876  FF 07		      C 	inc	word ptr [BX] ; inc *u.fofp / increment block number
			      C 	; *[u.fofp] points to next sector/block
			      C 	;
 1878  59		      C 	pop	cx ; ** ; number of disk sectors (disk capacity)
 1879  83 3E 27C0 R 00	      C 	cmp	word ptr [u.count], 0
			      C 		; tst u.count / done
 187E  76 05		      C 	jna	short @f
			      C        		; beq 1f / yes, return
			      C 		; tst -(r0) / no, point r0 to the argument again
 1880  BF 26EA R	      C 	mov	di, offset brwdev ; 11/06/2015
			      C 	;jmp	short bread0
			      C        		; br bread / read some more
			      C 	; 04/02/2022
 1883  EB C8		      C 	jmp	short bread1
			      C 		; br bread / read some more
 1885			      C @@: ; 1:
 1885  58		      C 	pop	ax ; ****
			      C        		; mov (sp)+,r0
 1886  E9 FAFB		      C         jmp     ret_ 
			      C 		; jmp ret / jump to routine that called readi
			      C 
 1889			      C bwrite:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 04/02/2022
			      C 	;	(Retro UNIX 8086 v1 2022 Bugfix, *[u.fofp] = block position)
			      C 	; 27/01/2022
			      C 	; 14/07/2015
			      C 	; 11/06/2015
			      C 	; 20/07/2013
			      C 	; 26/04/2013 Retro Unix 8086 v1 feature (device number) modifications
			      C 	; 14/03/2013
			      C 	;; / write on block structured device
			      C 	; INPUTS ->
			      C 	;    [u.fofp] points to the block number
			      C 	;    CX = maximum block number allowed on device
			      C 	;	 ; that was an arg to bwrite, in original Unix v1, but
			      C 	;	 ; CX register is used instead of arg in Retro Unix 8086 v1
			      C 	;    [u.count] number of bytes to user desires to write
			      C 	; OUTPUTS ->
			      C 	;    [u.fofp] points to next consecutive block to be written into
			      C 	;
			      C 	; ((Modified registers: DX, CX, BX, SI, DI, BP))
			      C 	;
			      C 	; NOTE: Original UNIX v1 has/had a defect/bug here, even if write
			      C 	;       byte count is less than 512, block number in *u.fofp (u.off)
			      C 	;	is increased by 1. For example: If user/program request 
			      C 	;       to write 16 bytes in current block, 'sys write' increaces
			      C 	;  	the next block number just as 512 byte writing is done.
			      C 	;       This wrong is done in 'bwrite'. So, in Retro UNIX 8086 v1, 
			      C 	;       for user (u) structure compatibility (because 16 bit is not
			      C 	;       enough to keep byte position/offset of the disk), this
			      C 	;	defect will not be corrected, user/program must request
			      C 	;	512 byte write per every 'sys write' call to block devices
			      C 	;       for achieving correct result. In future version(s), 
			      C 	;	this defect will be corrected by using different 
			      C 	;       user (u) structure. 26/07/2013 - Erdogan Tan 	
			      C 
			      C        		; jsr r0,tstdeve / test the device for an error
			      C 	;push	cx ; **
			      C 	; 26/04/2013
			      C 	;sub	ax, 3 ; 3 to 8 -> 0 to 5
 1889  2C 03		      C 	sub	al, 3
			      C 		; AL = Retro Unix 8086 v1 disk (block device) number
 188B  BF 26EA R	      C 	mov	di, offset brwdev ; block device number for direct I/O
 188E  88 05		      C 	mov	byte ptr [DI], al
 1890			      C bwrite0: 
			      C 	;; 11/06/2015
			      C 	;push	cx ; ** ; number of disk sectors (disk capacity)
			      C 	; 14/07/2015 (Retro UNIX 8086 v1 modification!)
			      C 	; [u.fofp] points to byte position in disk, not sector/block !
 1890  8B 1E 27B6 R	      C 	mov	bx, word ptr [u.fofp]
			      C 		; mov *u.fofp,r1 / put the block number in r1
 1894			      C bwrite1:
			      C         ;mov	al, byte ptr [BX+1]
			      C         ;cbw        
			      C         ;shr    al, 1 ; convert byte position to block/sector number
			      C 
			      C 	; 04/02/2022
			      C 	; *[u.fofp] points to sector/block position on disk
 1894  8B 07		      C 	mov	ax, word ptr [BX] ; current block pos/addr (for block r/w)
			      C 	; ax = disk block address
			      C 
 1896  3B C1		      C 	cmp	ax, cx
			      C 		; cmp r1,(r0)+ / does block number exceed maximum allowable #
			      C        	                     ; / block number allowed
			      C 	;jnb	error	     ; 18/04/2013
			      C 		; bhis error10 / yes, error
			      C 	; 27/01/2022
 1898  72 03		      C 	jb	short @f
 189A  E9 EA56		      C 	jmp	error
 189D			      C @@:
			      C 	; 04/02/2022 (Retro UNIX 8086 v1 2022)
 189D  51		      C 	push	cx ; ** ; number of disk sectors (disk capacity)
 189E  53		      C 	push	bx ; * ; *u.fofp 
			      C 	;
			      C 	;inc 	word ptr [BX]
			      C 		; inc *u.fofp / no, increment block number
 189F  E8 0057		      C        	call	bwslot ; 26/04/2013 (wslot -> bwslot)
			      C 		; jsr r0,wslot / get an I/O buffer to write into
			      C 	; bx = disk buffer address
 18A2  E8 0024		      C         call	dioreg
			      C 		; jsr r0,dioreg / do the necessary bookkeeping
			      C 	; 14/07/2015
			      C 	; SI = destination address (in the buffer)
			      C 	;	SI = disk buffer (start) address ; 04/02/2022 
			      C 	; DI = [u.base] value before it gets updated
			      C 	; CX = byte count to transfer
			      C ; 1: / r2 points to the users data; r5 points to the I/O buffers data area
 18A5  87 F7		      C 	xchg 	si, di ; 14/07/2015
 18A7  A1 27E0 R	      C         mov     ax, word ptr [u.segmnt] 
			      C 		; Retro Unix 8086 v1 feature only
 18AA  8E D8		      C 	mov	ds, ax
 18AC  F3/ A4		      C 	rep	movsb
 18AE  8C C8		      C 	mov	ax, cs
 18B0  8E D8		      C 	mov	ds, ax
			      C 		; movb (r2)+,(r5)+ / ; r3, has the byte count
			      C        		; dec r3 / area to the I/O buffer
			      C        		; bne 1b
 18B2  E8 006A		      C 	call	dskwr
			      C 		; jsr r0,dskwr / write it out on the device
			      C 	; 04/02/2022
 18B5  5B		      C 	pop	bx ; * ; *u.fofp
 18B6  FF 07		      C 	inc	word ptr [BX] ; inc *u.fofp / increment block number
			      C 	; *[u.fofp] points to next sector/block
			      C 	;
 18B8  59		      C 	pop	cx ; ** ; number of disk sectors (disk capacity)
 18B9  83 3E 27C0 R 00	      C         cmp     word ptr [u.count], 0
			      C 		; tst u.count / done
 18BE  76 05		      C 	jna	short @f
			      C 		; beq 1f / yes, 1f
			      C 		; tst -(r0) / no, point r0 to the argument of the call
 18C0  BF 26EA R	      C 	mov	di, offset brwdev ; 11/06/2015
			      C 	;jmp	short bwrite0
			      C        		; br bwrite / go back and write next block
			      C 	; 04/02/2022
 18C3  EB CF		      C 	jmp	short bwrite1
			      C 		; br bwrite / go back and write next block
 18C5			      C @@: ; 1:
 18C5  58		      C 	pop	ax ; ****
			      C        		; mov (sp)+,r0
 18C6  E9 FABB		      C         jmp     ret_ 
			      C 		; jmp ret / return to routine that called writei
			      C 
			      C ;error10:
			      C ;       jmp     error  ; / see 'error' routine
			      C 
 18C9			      C dioreg:
			      C 	; 04/02/2022 
			      C 	;	(Retro UNIX 8086 v1 Bugfix, *[u.fofp] = block position)
			      C 	; 14/07/2015 
			      C 	;	(UNIX v1 bugfix - [u.fofp]: byte pos., not block)
			      C 	; 14/03/2013
			      C 	; bookkeeping on block transfers of data
			      C 	;
			      C 	; * returns value of u.base before it gets updated, in DI (r2)
			      C 	; * returns byte count (to transfer) in CX (<=512)
			      C 	; * returns byte offset from beginning of current sector buffer
			      C 	; (beginning of data) in SI
			      C 
 18C9  8B 0E 27C0 R	      C 	mov	cx, word ptr [u.count]
			      C 		; mov u.count,r3 / move char count to r3
 18CD  81 F9 0200	      C 	cmp 	cx, 512
			      C 		; cmp r3,$512.   / more than 512. char?
 18D1  76 03		      C 	jna	short @f
			      C 		; blos 1f        / no, branch
 18D3  B9 0200		      C 	mov	cx, 512
			      C 		; mov $512.,r3   / yes, just take 512.
 18D6			      C @@: ; 1:
 18D6  8B 3E 27BE R	      C 	mov	di, word ptr [u.base]
			      C 	        ; mov u.base,r2  / put users base in r2
 18DA  01 0E 27C2 R	      C 	add	word ptr [u.nread], cx
			      C 		; add r3,u.nread / add the number to be read to u.nread
 18DE  29 0E 27C0 R	      C 	sub	word ptr [u.count], cx
			      C 		; sub r3,u.count / update count
 18E2  01 0E 27BE R	      C 	add	word ptr [u.base], cx
			      C 		; add r3,u.base  / update base
			      C 
			      C 	;; 14/07/2015
			      C 	;; Retro UNIX 8086 v1 - modification !
			      C 	;; (File pointer points to byte position, not block/sector no.)
			      C 	;; (It will point to next byte position instead of next block no.)
			      C 	;mov	si, word ptr [u.fofp] ; u.fopf points to byte position pointer
			      C         ;mov	ax, word ptr [si] ; si points to current byte pos. on the disk
			      C         ;add	word ptr [si], cx ; cx is added to set the next byte position
			      C 	;and	ax, 1FFh ; get offset from beginning of current block	
			      C 	;mov	si, bx   ; beginning of data in sector/block buffer
			      C 	;add	si, ax   ; esi contains start address of the transfer
			      C 
			      C 	; 04/02/2022
			      C 	; Retro UNIX 8086 v1 2022 modification (BugFix)
 18E6  8B F3		      C 	mov	si, bx ; start address/offset of disk buffer
			      C 
 18E8  C3		      C 	retn
			      C 		; rts r0 / return
 18E9			      C dskrd:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 14/07/2015
			      C 	; 29/07/2013
			      C 	; 20/07/2013
			      C 	; 26/04/2013
			      C 	; 14/03/2013
			      C 	;
			      C 	; 'dskrd' acquires an I/O buffer, puts in the proper
			      C 	; I/O queue entries (via bufaloc) then reads a block
			      C 	; (number specified in r1) in the acquired buffer.)
			      C 	; If the device is busy at the time dskrd is called,	
			      C 	; dskrd calls idle.
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - block number
			      C 	;    cdev - current device number 
			      C 	; OUTPUTS ->
			      C 	;    r5 - points to first data word in I/O buffer
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	; ((BX = R5)) output 
			      C 	;
			      C         ; ((Modified registers: DX, CX, BX, SI, DI, BP))  
			      C 	;
 18E9  E8 0059		      C 	call 	bufaloc
			      C 		; jsr r0,bufaloc / shuffle off to bufaloc; 
			      C 			       ; / get a free I/O buffer
			      C 	;;jc	error ; 20/07/2013
 18EC  74 07		      C 	jz	short @f ; Retro UNIX 8086 v1 modification
			      C        		; br 1f / branch if block already in a I/O buffer
			      C 	
			      C 	; 15/07/2022
			      C 	; (buffer header byte 1, bit 2 is disk read bit/flag)
 18EE			      C dskrd_0:
 18EE  81 0F 0400	      C 	or	word ptr [BX], 400h ; set read bit (10) in I/O Buffer
			      C         	; bis $2000,(r5) / set bit 10 of word 1 of 
			      C 		               ; / I/O queue entry for buffer
 18F2  E8 002E		      C 	call	poke
			      C 		; jsr r0,poke / just assigned in bufaloc, 
			      C 			    ; /	bit 10=1 says read
			      C 	;;jc	error ; 20/07/2013
 18F5			      C @@: ; 1:
			      C 	; 15/07/2022
			      C 	;
			      C 	;clr *$ps
			      C 	;test	word ptr [BX], 2400h
			      C 	;	; bit $22000,(r5) / if either bits 10, or 13 are 1; 
			      C 	;	; jump to idle
			      C 	;jz	short @f
			      C 	;	; beq 1f
			      C 	;;mov	cx, word ptr [s.wait_]+2 ;; 29/07/2013
			      C 	;call	idle
			      C 	;	; jsr r0,idle; s.wait+2
			      C 	;jmp	short @b
			      C        	;	; br 1b
 18F5			      C @@: ; 1:
			      C         ;add	bx, 8
			      C 	; 26/04/2013
 18F5  83 C3 04		      C 	add	bx, 4 ; Retro Unix 8086 v1 modification !
			      C 		; add $8,r5 / r5 points to first word of data in block 
			      C 			  ; / just read in
 18F8  C3		      C        	retn
			      C 		; rts r0
			      C 
 18F9			      C bwslot:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 26/02/2022
			      C 	; 14/07/2015
			      C 	;	If the block/sector is not placed in a buffer
			      C 	;	before 'wslot', it must be read before
			      C 	;	it is written! (Otherwise transfer counts less
			      C 	;	than 512 bytes will be able to destroy existing 
			      C 	;	data on disk.)
			      C 	;
			      C 	; 26/04/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; ('bwslot' will be called from 'bwrite' only!)
			      C 	; INPUT -> DI - points to device id (in brwdev)	
			      C 	;	-> AX = block number
			      C 	;
 18F9  E8 0054		      C 	call	bufaloc_0
 18FC  74 19		      C 	jz	short @f ; wslot_0 ; sector already is in the buffer
			      C 	; 15/07/2022
			      C 	; bx = buffer header address
 18FE			      C bwslot_0:
			      C 	; 14/07/2015
 18FE  8B 36 27B6 R	      C 	mov	si, word ptr [u.fofp]
 1902  8B 04		      C 	mov	ax, word ptr [si]
			      C 	; 26/02/2022
			      C 	; (ax contains sector address, not byte offset/position!)
			      C 	; ((so, following buffer offset check is not needed))
			      C 	;and	ax, 1FFh ; offset from beginning of the sector/block
			      C 	;jnz 	short bwslot_1 ; it is not a full sector write
			      C 	;	       ; recent disk data must be placed in the buffer
 1904  81 3E 27C0 R 0200      C 	cmp	word ptr [u.count], 512
 190A  73 0B		      C 	jnb	short @f ; wslot_0
 190C			      C bwslot_1:
 190C  E8 FFDF		      C 	call	dskrd_0
 190F  83 EB 04		      C 	sub	bx, 4 ; set bx to the buffer header address again	
 1912  EB 03		      C 	jmp 	short @f ; wslot_0
			      C 
 1914			      C wslot:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 29/07/2013
			      C 	; 20/07/2013
			      C 	; 26/04/2013
			      C 	; 14/03/2013
			      C 	;
			      C 	; 'wslot' calls 'bufaloc' and obtains as a result, a pointer
			      C 	; to the I/O queue of an I/O buffer for a block structured
			      C 	; device. It then checks the first word of I/O queue entry.	
			      C 	; If bits 10 and/or 13 (read bit, waiting to read bit) are set,
			      C 	; wslot calls 'idle'. When 'idle' returns, or if bits 10 
			      C 	; and/or 13 are not set, 'wslot' sets bits 9 and 15 of the first
			      C 	; word of the I/O queue entry (write bit, inhibit bit).
			      C 	;
			      C 	; INPUTS ->
			      C  	;    r1 - block number
			      C 	;    cdev - current (block/disk) device number
			      C  	;
			      C 	; OUTPUTS ->
			      C 	;    bufp - bits 9 and 15 are set, 
			      C 	;           the remainder of the word left unchanged
			      C 	;    r5 - points to first data word in I/O buffer
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	; ((BX = R5)) output 
			      C 	;
			      C         ; ((Modified registers: DX, CX, BX, SI, DI, BP)) 
			      C 
 1914  E8 002E		      C 	call	bufaloc
			      C 		; jsr r0,bufaloc / get a free I/O buffer; pointer to first
			      C 	;;jc	error ; 20/07/2013
			      C 	; BX = Buffer (Header) Address (r5) (ES=CS=DS, system/kernel segment)
			      C         ; AX = Block/Sector number (r1)
			      C         ;jz	short @f
			      C 		; br 1f / word in buffer in r5
			      C ;wslot_0:
 1917			      C @@: ;1:
			      C 	; 15/07/2022
			      C 	;test	word ptr [BX], 2400h
			      C 	;	; bit $22000,(r5) / check bits 10, 13 (read, waiting to read)
			      C 	;			; / of I/O queue entry
			      C 	;jz	short @f
			      C 	;	; beq 1f / branch if 10, 13 zero (i.e., not reading, 
			      C 	;	       ; / or not waiting to read)
			      C 	;
			      C         ;;mov	cx, word ptr [s.wait_]+2 ; 29/07/2013
			      C 	;call	idle
			      C 	;	; jsr r0,idle; / if buffer is reading or writing to read,
			      C 	;                    ; / idle
			      C 	;jmp	short @b
			      C 	;	; br 1b / till finished
 1917			      C @@: ;1:
			      C 	; 15/07/2022
			      C 	;or	word ptr [BX], 8200h
			      C 	;	; bis $101000,(r5) / set bits 9, 15 in 1st word of I/O queue
			      C 	;                      	 ; / (write, inhibit bits)
			      C 	;	; clr *$ps / clear processor status
			      C 
			      C 	; 15/07/2022
			      C 	;or	word ptr [bx], 200h
 1917  43		      C 	inc	bx
 1918  80 0F 02		      C 	or	byte ptr [bx], 2
 191B  83 C3 03		      C 	add	bx, 3
			      C         
			      C 	;;add	bx, 8
			      C 	; 26/04/2013
			      C 	;add	bx, 4 ; Retro Unix 8086 v1 modification !
			      C 		; add $8,r5 / r5 points to first word in data area 
			      C 			  ; / for this block
 191E  C3		      C        	retn
			      C 		; rts r0
 191F			      C dskwr:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 03/08/2013
			      C 	; 31/07/2013
			      C 	; 20/07/2013
			      C 	; 26/04/2013
			      C 	; 14/03/2013
			      C 	;
			      C 	; 'dskwr' writes a block out on disk, via ppoke. The only
			      C 	; thing dskwr does is clear bit 15 in the first word of I/O queue
			      C 	; entry pointed by 'bufp'. 'wslot' which must have been called
			      C 	; previously has supplied all the information required in the
			      C 	; I/O queue entry.
			      C 	;
			      C 	; (Modified registers: CX, DX, BX, SI, DI)
			      C 	;
			      C 	;
			      C 	; 03/08/2013 (si -> bx)
 191F  8B 1E 26AA R	      C 	mov	bx, word ptr [bufp]
			      C 	; 15/07/2022
			      C 	;and	word ptr [bx], 7FFFh ; 0111111111111111b
			      C 	;	; bic $100000,*bufp / clear bit 15 of I/O queue entry at
			      C         ;	                  ; / bottom of queue
			      C 
 1923			      C ppoke:
			      C 		; mov $340,*$ps
			      C 		; jsr r0,poke
			      C 		; clr *$ps
			      C 		; rts r0
			      C 
 1923			      C poke:
			      C 	; 15/07/2022
			      C 	;	! Major Modification !
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 28/01/2022
			      C 	; 27/01/2022
			      C 	; 11/06/2015
			      C 	; 18/01/2014
			      C 	; 31/07/2013
			      C 	; 23/07/2013
			      C 	; 20/07/2013
			      C 	; 17/07/2013
			      C 	; 09/07/2013
			      C 	; 26/04/2013
			      C 	; 24/03/2013 AX (r1) -> push/pop (to save physical block number)
			      C 	; 15/03/2013 
			      C 	; (NOTE: There are some disk I/O code modifications & extensions
			      C 	; & exclusions on original 'poke' & other device I/O procedures of 
			      C 	; UNIX v1 OS for performing disk I/O functions by using IBM PC 
			      C 	; compatible rombios calls in Retro UNIX 8086 v1 kernel.)
			      C 	;
			      C 	; Basic I/O functions for all block structured devices
			      C 	; (Modified registers: CX, DX, SI, DI)
			      C 
			      C 	; 20/07/2013 modifications
			      C 	;            (Retro UNIX 8086 v1 features only !)
			      C 	; INPUTS -> 
			      C 	;        (BX = buffer header address)
			      C 	; OUTPUTS ->
			      C 	;	 cf=0 -> successed r/w (at least, for the caller's buffer) 
			      C 	;	 cf=1 -> error, word ptr [BX] = 0FFFFh
			      C 	;		(drive not readi or r/w error!)
			      C 	;	 (word ptr [BX]+2 <> 0FFFFh indicates r/w success)	
			      C 	;	 (word ptr [BX]+2 = FFFFh mean RW/IO error)
			      C 	;        (also it indicates invalid buffer data)
			      C 	
			      C 	; 15/07/2022 - Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; Buffer header:
			      C 	;	byte 0 - device/disk (index) number
			      C 	;	byte 1 - status
			      C 	;	    before 'poke'	
			      C 	;		bit 0 - valid bit 
			      C 	;		   (0 for new buffer)
			      C 	;		   (1 for existing buffer)	
			      C 	;		bit 1 - write (modified) bit, disk write flag
			      C 	;		bit 2 - read bit, disk read flag
			      C 	;	    after 'poke'
			      C 	;		if disk r/w is successed
			      C 	;		   bit 0 = 1
			      C 	;		   bit 1 = 0
			      C 	;		   bit 2 = 0
			      C 	;		if disk r/w is failed
			      C 	;		   bit 0 = 0 (invalid buffer)
			      C 	;		   bit 1 = 0 (write bit)
			      C 	;		   bit 2 = 0 (read bit)	
			      C  	;
			      C 	;	byte 2 & byte 3 - disk block/sector address
			      C 
			      C 	; 26/04/2013
 1923  8A 0F		      C 	mov	cl, byte ptr [BX] ; Device Id
			      C 			; movb (r1),r3 / get device id
 1925  32 ED		      C 	xor	ch, ch
			      C 	; 15/07/2022
 1927  8B F9		      C 	mov	di, cx
			      C 
			      C 	; 17/07/2013
 1929  50		      C 	push	ax
 192A  E8 0081		      C 	call	diskio	; Retro UNIX 8086 v1 Only !
 192D  88 A5 26C6 R	      C 	mov     byte ptr [DI]+drv.err, ah
 1931  58		      C 	pop	ax
			      C 	;jnc	short seta ; 20/07/2013
 1932  72 05		      C 	jc	short @f ; 15/07/2022
			      C 
 1934			      C seta: 
 1934  C6 47 01 01	      C 	mov	byte ptr [BX]+1, 1 ; clear write/read bits, set valid bit
			      C 	;clc
 1938  C3		      C 	retn
			      C 
 1939			      C @@:	
			      C 	; 15/07/2022
			      C 	; (invalidate buffer)
			      C 	
			      C 	; 15/07/2022
			      C 	; 20/07/2013
 1939  C7 47 02 FFFF	      C 	mov	word ptr [BX]+2, 0FFFFh ; -1 
			      C        		; mov $-1,2(r1) / destroy associativity
 193E  C7 07 00FF	      C 	mov	word ptr [BX], 0FFh
			      C 		; clrb 1(r1) / do not do I/O
 1942			      C @@:
			      C 	; 15/07/2022
 1942  E9 E9AE		      C 	jmp	error
			      C 
			      C ;poke:
			      C ;	; 28/01/2022
			      C ;	; 27/01/2022
			      C ;	; 11/06/2015
			      C ;	; 18/01/2014
			      C ;	; 31/07/2013
			      C ;	; 23/07/2013
			      C ;	; 20/07/2013
			      C ;	; 17/07/2013
			      C ;	; 09/07/2013
			      C ;	; 26/04/2013
			      C ;	; 24/03/2013 AX (r1) -> push/pop (to save physical block number)
			      C ;	; 15/03/2013 
			      C ;	; (NOTE: There are some disk I/O code modifications & extensions
			      C ;	; & exclusions on original 'poke' & other device I/O procedures of 
			      C ;	; UNIX v1 OS for performing disk I/O functions by using IBM PC 
			      C ;	; compatible rombios calls in Retro UNIX 8086 v1 kernel.)
			      C ;	;
			      C ;	; Basic I/O functions for all block structured devices
			      C ;	; (Modified registers: CX, DX, SI, DI)
			      C ;
			      C ;	; 20/07/2013 modifications
			      C ;	;            (Retro UNIX 8086 v1 features only !)
			      C ;	; INPUTS -> 
			      C ;	;        (BX = buffer header address)
			      C ;	; OUTPUTS ->
			      C ;	;	 cf=0 -> successed r/w (at least, for the caller's buffer) 
			      C ;	;	 cf=1 -> error, word ptr [BX] = 0FFFFh
			      C ;	;		(drive not readi or r/w error!)
			      C ;	;	 (word ptr [BX]+2 <> 0FFFFh indicates r/w success)	
			      C ;	;	 (word ptr [BX]+2 = FFFFh mean RW/IO error)
			      C ;	;        (also it indicates invalid buffer data)
			      C ;
			      C ;	; 17/07/2013
			      C ;	push	bx
			      C ;	; 24/03/2013
			      C ;      		; mov r1,-(sp)
			      C ;      		; mov r2,-(sp)
			      C ;      		; mov r3,-(sp)
			      C ;	push 	ax ; (save) Physical Block Number (r1) (mget)
			      C ;	;mov	si, offset bufp + nbuf + nbuf + 6 
			      C ;		; mov $bufp+nbuf+nbuf+6,r2 / r2 points to highest priority
			      C ;					 ; / I/O queue pointer
			      C ;       mov     si, offset bufp + (2*nbuf) + (2*2)  ; 09/07/2013 
			      C ;poke_1: ; 1:
			      C ;       dec	si
			      C ;	dec	si
			      C ;	mov	bx, word ptr [SI]
			      C ;		; mov -(r2),r1 / r1 points to an I/O queue entry
			      C ;	mov	ax, word ptr [BX] ; 17/07/2013
			      C ;      	test	ah, 06h
			      C ;	;test	word ptr [BX], 600h ; 0000011000000000b
			      C ;		; bit $3000,(r1) / test bits 9 and 10 of word 1 of I/O 
			      C ;			       ; / queue entry
			      C ;       jz      short poke_2
			      C ;		; beq 2f / branch to 2f if both are clear
			      C ;	; 31/07/2013
			      C ;	;test	ah, 0B0h ; (*)
			      C ;	;;test	word ptr [BX], 0B000h ; 1011000000000000b
			      C ;		; bit $130000,(r1) / test bits 12, 13, and 15
			      C ;       ;jnz	short poke_2 ; 31/07/2013 (*)
			      C ;		; bne 2f / branch if any are set
			      C ;	mov	cl, byte ptr [BX] ; 26/04/2013 ; Device Id
			      C ;   		; movb (r1),r3 / get device id
			      C ;	xor	ch, ch ; mov ch, 0 ; 26/04/2013
			      C ;	mov	di, cx ; 11/06/2015
			      C ;	xor 	ax, ax ; 0
			      C ;	;cmp 	byte ptr [DI]+drv.err, al ; 0 ; 26/04/2013
			      C ;		; tstb deverr(r3) / test for errors on this device
			      C ;      	;jna	short poke_3 
			      C ;		; beq 3f / branch if no errors
			      C ;	; 20/07/2013
			      C ;	;dec	ax
			      C ;	;mov	word ptr [BX]+2, ax ; FFFFh ; -1 
			      C ;      		; mov $-1,2(r1) / destroy associativity
			      C ;	;inc	ah ; 0
			      C ;	;mov	word ptr [BX], ax ; 00FFh, reset
			      C ;		; clrb 1(r1) / do not do I/O
			      C ;	;jmp	short poke_2
			      C ;       ;	; br 2f
			      C ;               ; rts r0
			      C ;poke_3: ; 3:
			      C ;	; 26/04/2013 Modification
			      C ;	inc	al ; mov ax, 1
			      C ;	or	cl, cl ; Retro UNIX 8086 v1 device id.
			      C ;	jz	short @f ; cl = 0
			      C ;	shl	al, cl ; shl ax, cl
			      C ;@@::
			      C ;	;test	word ptr [active], ax
			      C ;	test	byte ptr [active], al
			      C ;		; bit $2,active / test disk busy bit
			      C ;       jnz     short poke_2
			      C ;		; bne 2f / branch if bit is set
			      C ;	;or	word ptr [active], ax
			      C ;	or	byte ptr [active], al
			      C ;		; bis $2,active / set disk busy bit
			      C ;	push	ax ; 17/07/2013
			      C ;	call	diskio ; Retro UNIX 8086 v1 Only !
			      C ;	mov     byte ptr [DI]+drv.err, ah
			      C ;	pop	ax
			      C ;	jnc	short @f ; 20/07/2013	
			      C ;		; tstb deverr(r3) / test for errors on this device
			      C ;      		; beq 3f / branch if no errors
			      C ;	; 20/07/2013
			      C ;	mov	word ptr [BX]+2, 0FFFFh ; -1 
			      C ;      		; mov $-1,2(r1) / destroy associativity
			      C ;	mov	byte ptr [BX]+1, 0 
			      C ;		; clrb 1(r1) / do not do I/O
			      C ;	jmp     short poke_2
			      C ;@@:	; 20/07/2013
			      C ;	; 17/07/2013
			      C ;	not 	al 
			      C ;	and	byte ptr [active], al ; reset, not busy
			      C ;	; BX = system I/O buffer header (queue entry) address
			      C ;seta: 
			      C ;	; / I/O queue bookkeeping; set read/write waiting bits.
			      C ;	mov	ax, word ptr [BX]
			      C ;      		; mov (r1),r3 / move word 1 of I/O queue entry into r3
			      C ;       and	ax, 600h
			      C ;		; bic $!3000,r3 / clear all bits except 9 and 10
			      C ;	and 	word ptr [BX], 0F9FFh
			      C ;      		; bic $3000,(r1) / clear only bits 9 and 10
			      C ;	;shl	ax, 1
			      C ;	;shl	ax, 1
			      C ;	;shl	ax, 1
			      C ;      		; rol r3
			      C ;               ; rol r3
			      C ;               ; rol r3
			      C ;	; 23/07/2013
			      C ;	shl	ah, 1
			      C ;	shl	ah, 1
			      C ;	shl	ah, 1
			      C ;	or	word ptr [BX], ax
			      C ;		; bis r3,(r1) / or old value of bits 9 and 10 with 
			      C ;			   ; bits 12 and 13
			      C ;	call	idle ; 18/01/2014
			      C ;	;; sti
			      C ;	;hlt 	; wait for a hardware interrupt
			      C ;	;; cli
			      C ;	; NOTE: In fact, disk controller's 'disk I/O completed' 
			      C ;       ; interrupt would be used to reset busy bits, but INT 13h
			      C ;	; returns when disk I/O is completed. So, here, as temporary
			      C ;	; method, this procedure will wait for a time according to
			      C ;	; multi tasking and time sharing concept.
			      C ;	not	ax 
			      C ;	and	word ptr [BX], ax ; clear bits 12 and 13
			      C ;poke_2: ;2:
			      C ;       cmp     si, offset bufp
			      C ;               ; cmp r2,$bufp / test to see if entire I/O queue 
			      C ;                           ; / has been scanned
			      C ;       ja      short poke_1
			      C ;		; bhi 1b
			      C ;	; 24/03/2013
			      C ;      		; mov (sp)+,r3
			      C ;      		; mov (sp)+,r2
			      C ;      		; mov (sp)+,r1
			      C ;       pop 	ax  ; (restore) Physical Block Number (r1) (mget)
			      C ;	; 17/07/2013
			      C ;	pop 	bx
			      C ;	; 20/07/2013
			      C ;	cmp 	word ptr [BX]+2, 0FFFFh
			      C ;	;je 	error
			      C ;	; 27/01/2022
			      C ;	je	short @f
			      C ;
			      C ;	; 'poke' returns with cf=0 if the requested buffer is read 
			      C ;	; or written succesfully; even if an error occurs while
			      C ;	; reading to or writing from other buffers. 20/07/2013
			      C ;	;
			      C ;	;cmc
			      C ;
			      C ;	; 28/01/2022
			      C ;	; (poke will return to the caller if there is not an error)
			      C ;	; (carry flag may be 1 or 0 at return))
			      C ;
			      C ;	; 26/02/2022
			      C ;	; NOTE: here, cf is 1
			      C ;	;  (cf check is not used at return from poke/dskrd/dskwr)
			      C ;
			      C ;	retn
			      C ;               ; rts r0
			      C ;@@:
			      C ;	jmp	error
			      C 
 1945			      C bufaloc:
			      C 	; 15/07/2022
			      C 	;	Retro UNIX 8086 v1 2022 (Kernel v0.1.0.4)
			      C 	; 27/01/2022
			      C 	; 29/07/2013
			      C 	; 20/07/2013
			      C 	; 09/07/2013
			      C 	; 26/04/2013 (device number/id modifications)	
			      C 	; 13/03/2013
			      C 	; bufaloc - Block device I/O buffer allocation
			      C 	; 
			      C 	; INPUTS ->
			      C 	;    r1 - block number
			      C 	;    cdev - current (block/disk) device number
			      C 	;    bufp+(2*n)-2 --- n = 1 ... nbuff
			      C 	; OUTPUTS ->
			      C 	;    r5 - pointer to buffer allocated
			      C 	;    bufp ... bufp+12 --- (bufp), (bufp)+2
			      C 	;
			      C 	; ((AX = R1)) input/output
			      C 	; ((BX = R5)) output
			      C         ;    ((Modified registers: DX, CX, BX, SI, DI, BP))
			      C 	;    zf=1 -> block already in a I/O buffer
			      C 	;    zf=0 -> a new I/O buffer has been allocated
			      C 	;    ((DL = Device ID))
			      C 	;    (((DH = 0 or 1)))
			      C 	;    (((CX = previous value of word ptr [bufp])))
			      C 	;    ((CX and DH will not be used after return)))
			      C 
			      C 	;;push 	si ; ***
			      C 		; mov r2,-(sp) / save r2 on stack
			      C        		; mov $340,*$ps / set processor priority to 7
			      C 	; 20/07/2013
			      C 	; 26/04/2013
 1945  32 FF		      C 	xor 	bh, bh
 1947  8A 1E 26C2 R	      C 	mov	bl, byte ptr [cdev] ; 0 or 1
 194B  BF 26C4 R	      C 	mov	di, offset rdev  ; offset mdev = offset rdev + 1
 194E  03 FB		      C 	add	di, bx
 1950			      C bufaloc_0: ; 26/04/2013 !! here is called from bread or bwrite !!
			      C 			;; DI points to device id.
			      C 	; 20/07/2013
 1950  8A 1D		      C 	mov	bl, byte ptr [DI] ; DI -> rdev/mdev or brwdev
 1952  32 FF		      C 	xor	bh, bh
 1954  80 BF 26CC R FF	      C 	cmp 	byte ptr [BX]+drv.pdn, 0FFh ; Drive not ready !
			      C 	;je	error ; 20/07/2013
			      C 	; 27/01/2022
 1959  74 E7		      C 	je	short @b ; jmp error
 195B			      C @@:
 195B  8B D3		      C 	mov	dx, bx	; dh = 0, dl = device number (0 to 5)
			      C 	;xor 	bp, bp ; 0
			      C 	;push	bp ; 0
			      C         ; 15/07/2022
 195D  33 FF		      C 	xor	di, di ; 0
 195F  57		      C 	push	di ; 0
 1960  8B EC		      C 	mov     bp, sp	
			      C 	;
 1962			      C bufaloc_1: ;1:
			      C 		; clr -(sp) / vacant buffer
 1962  BE 26AA R	      C         mov 	si, offset bufp
			      C 		; mov $bufp,r2 / bufp contains pointers to I/O queue 
			      C 			     ; / entrys in buffer area
 1965			      C bufaloc_2: ;2:
 1965  8B 1C		      C 	mov	bx, word ptr [SI]
			      C 	; 15/07/2022
			      C 	;inc	si
			      C 	;inc	si
			      C        		; mov (r2)+,r5 / move pointer to word 1 of an I/O 
			      C 			       ; queue entry into r5
			      C 	; 15/07/2022
 1967  8B 0F		      C 	mov	cx, word ptr [BX]
			      C 	;test	word ptr [BX], 0F600h
			      C 	; 15/07/2022
 1969  F6 C5 01		      C 	test	ch, 1 ; valid buffer (content) ?
			      C 		; bit $173000,(r5) / lock+keep+active+outstanding
 196C  75 05		      C         jnz	short bufaloc_3
			      C 		; bne 3f / branch when 
			      C 		       ; / any of bits 9,10,12,13,14,15 are set
			      C                        ; / (i.e., buffer busy)
 196E  89 76 00		      C         mov     word ptr [BP], si ; pointer to word 2 of I/0 queue
			      C 				  ; entry
			      C                 ; mov  r2,(sp) ;/ save pointer to last non-busy buffer
			      C 			; / found points to word 2 of I/O queue entry)
			      C 	; 15/07/2022
			      C 	; continue to see if requested sector/block buffer
			      C 	;	already is one of existing (valid) buffers
 1971  EB 0E		      C 	jmp	short bufaloc_9
 1973			      C bufaloc_3: ;3:
			      C 	;mov	dl, byte ptr [DI] ; 26/04/2013
			      C 	;
			      C 	; 15/07/2022
 1973  38 D2		      C 	cmp	dl, dl
			      C 	;cmp	byte ptr [BX], dl	
			      C 		; cmpb (r5),cdev / is device in I/O queue entry same 
			      C 			       ; / as current device
 1975  75 08		      C 	jne	short bufaloc_4
			      C        		; bne 3f
 1977  39 47 02		      C 	cmp	word ptr [BX]+2, ax
			      C        		; cmp 2(r5),r1 / is block number in I/O queue entry, 
			      C 			     ; / same as current block number
 197A  75 03		      C        	jne	short bufaloc_4
			      C 		; bne 3f
			      C 	;add	sp, 2
 197C  59		      C 	pop	cx
			      C        		; tst (sp)+ / bump stack pointer
			      C 	; 15/07/2022
			      C 	;dec	si ; 09/07/2013
			      C 	;dec	si ; 09/07/2013
 197D  EB 1A		      C 	jmp	short bufaloc_7 ; Retro Unix 8086 v1 modification
			      C 				; jump to bufaloc_6 in original Unix v1
			      C        		; br 1f / use this buffer
 197F			      C bufaloc_4: ;3:
			      C 	; 15/07/2022
			      C 	; save (pointer to) last valid buffer 
			      C 	; (will be used if there is not a free buffer)
 197F  8B FE		      C 	mov	di, si
 1981			      C bufaloc_9:
			      C 	; 15/07/2022
 1981  46		      C 	inc	si
 1982  46		      C 	inc	si
			      C 	;
 1983  81 FE 26BA R	      C 	cmp	si, offset bufp + nbuf + nbuf
			      C 		; cmp r2,$bufp+nbuf+nbuf
 1987  72 DC		      C 	jb	short bufaloc_2
			      C 		; blo 2b / go to 2b if r2 less than bufp+nbuf+nbuf (all
			      C                        ; / buffers not checked)
 1989  5E		      C         pop	si
			      C 		; mov (sp)+,r2 / once all bufs are examined move pointer
			      C 			     ; / to last free block
 198A  0B F6		      C        	or	si, si 
 198C  75 02		      C 	jnz	short bufaloc_5
			      C 		; bne 2f / if (sp) is non zero, i.e., 
			      C 	        ; / if a free buffer is found branch to 2f
			      C 
			      C         ;; mov  cx, word ptr [s.wait_]+2 ;; 29/07/2013
			      C 	;call	idle
			      C 	;	; jsr r0,idle; s.wait+2 / idle if no free buffers
			      C 	;; 26/04/2013
			      C 	;;;xor 	dx, dx
			      C 	;;xor	dl, dl
			      C 	;;push	dx ; 0
			      C 	; 15/07/2022 (BugFix)
			      C 	;;mov	dl, byte ptr [DI] ; device number
			      C 	;push	si ; 0
			      C 	;;
			      C 	;jmp 	short bufaloc_1
			      C        	;	; br 1b
			      C 
			      C 	; 14/07/2022        
			      C 	; if there is not a free buffer
			      C 	; we can use last valid buffer (the oldest buffer)
			      C 	; ((ptr to new buffer is located at head of buff ptr chain))
 198E  8B F7		      C 	mov	si, di
			      C 
 1990			      C bufaloc_5: ;2:
			      C 		; tst (r0)+ / skip if warmed over buffer
			      C 	; 15/07/2022
			      C 	;inc	dh ; Retro UNIX 8086 v1 modification
 1990			      C bufaloc_6: ;1:
			      C 	; 15/07/2022
			      C 	;dec	si
			      C 	;dec	si
 1990  8B 1C		      C         mov    	bx, word ptr [SI] 
			      C 		; mov -(r2),r5 / put pointer to word 1 of I/O queue 
			      C 			     ; / entry in r5
			      C 	;; 26/04/2013
			      C 	;;mov	dl, byte ptr [DI] ; byte ptr [rdev] or byte ptr [mdev]
			      C 	;mov 	byte ptr [BX], dl
			      C 		; movb cdev,(r5) / put current device number 
			      C 			       ; / in I/O queue entry
			      C 	; 15/07/2022
			      C 	; invalidate buffer before r/w (new) disk sector/block
			      C 	;mov	word ptr [BX]+1, dh ; 0
			      C 	; 15/07/2022
 1992  89 17		      C 	mov	word ptr [BX], dx  ; dh = 0
			      C 
 1994  89 47 02		      C 	mov 	word ptr [BX]+2, ax
			      C 		; mov r1,2(r5) / move block number into word 2 
			      C 			     ; / of I/O queue entry
			      C 	; 15/07/2022
 1997  FE C6		      C 	inc	dh ; dh = 1
 1999			      C bufaloc_7: ;1:
 1999  81 FE 26AA R	      C         cmp	si, offset bufp
			      C 		; cmp r2,$bufp / bump all entrys in bufp 
			      C 			     ; / and put latest assigned
 199D  76 0A		      C 	jna	short bufaloc_8	
			      C        		; blos 1f / buffer on the top 
			      C 			; / (this makes if the lowest priority)
			      C 	; 15/07/2022
 199F  8B FE		      C 	mov	di, si
			      C 	;
 19A1  4E		      C 	dec	si
 19A2  4E		      C 	dec	si
			      C 	;
 19A3  8B 0C		      C 	mov	cx, word ptr [SI]
 19A5  89 0D		      C 	mov	word ptr [DI], cx ; 15/07/2022
			      C 	;mov	word ptr [SI]+2, cx
			      C 		; mov -(r2),2(r2) / job for a particular device
 19A7  EB F0		      C 	jmp 	short bufaloc_7        
			      C 		; br 1b
 19A9			      C bufaloc_8: ;1:
 19A9  89 1C		      C         mov	word ptr [SI], bx
			      C 		; mov r5,(r2)
			      C 	;;pop	si ; ***
			      C        		; mov (sp)+,r2 / restore r2
 19AB  0A F6		      C        	or 	dh, dh ; 0 or 1 ?
			      C 		; Retro UNIX 8086 v1 modification
			      C 		; zf=1 --> block already in a I/O buffer
			      C 		; zf=0 --> a new I/O buffer has been allocated
			      C 
 19AD  C3		      C 	retn
			      C 		; rts r0
			      C 
 19AE			      C diskio:
			      C 	; 28/01/2022
			      C 	; 26/04/2013 Device ID modifications
			      C 	; 15/03/2013
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; Derived from proc_chs_read procedure of TRDOS DISKIO.ASM (2011)
			      C 	; 04/07/2009 - 20/07/2011
			      C 	;
			      C 	; NOTE: Reads only 1 block/sector (sector/block size is 512 bytes)
			      C 	;
			      C         ; INPUTS ->
			      C 	; 	   BX = System I/O Buffer header address
			      C         ; OUTPUTS -> cf=0 --> done 
			      C 	; 	     cf=1 ---> error code in AH
			      C 	;		
			      C 	; (Modified registers: CX,DX,AX)
			      C 
			      C 	;; I/O Queue Entry (of original UNIX operating system v1)
			      C 	;; Word 1, Byte 0 = device id
			      C 	;; Word 1, Byte 1 = (bits 8 to 15)
			      C 	;;          bit  9 = write bit
			      C 	;;	    bit 10 = read bit	  
			      C 	;;	    bit 12 = waiting to write bit	
			      C 	;;	    bit 13 = waiting to read bit
			      C 	;;	    bit 15 = inhibit bit
			      C 	;; Word 2 = physical block number (In fact, it is LBA for Retro UNIX 8086 v1)
			      C 	;;
			      C 	;; Original UNIX v1 -> ; 26/04/2013
			      C 	;;		Word 3 = number of words in buffer (=256) 		
			      C 	;; Original UNIX v1 -> ; 26/04/2013
			      C 	;;		Word 4 = bus address (addr of first word of data buffer)
			      C 	;;
			      C 	;; Retro UNIX 8086 v1 -> Buffer Header (I/O Queue Entry) size is 4 bytes !
			      C 	;;
			      C 	;; Device IDs (of Retro Unix 8086 v1) ; 26/04/2013
			      C 	;;          0 = fd0
			      C 	;;	    1 = fd1
			      C 	;;	    2 = hd0
			      C 	;;	    3 = hd1
			      C 	;;	    4 = hd2
			      C 	;;	    5 = hd3
			      C 
 19AE  BA 0201		      C 	mov	dx, 0201h ; Read 1 sector/block
 19B1  8B 07		      C 	mov	ax, word ptr [BX] 
			      C 	; 26/04/2013
 19B3  56		      C 	push	si ; ******
 19B4  8A C8		      C 	mov	cl, al
 19B6  32 ED		      C 	xor	ch, ch
 19B8  8B F1		      C 	mov	si, cx
			      C 	;
 19BA  F6 C4 02		      C 	test	ah, 2
			      C 	;test	ax, 200h ; Bit 9 of word 0 (status word)
			      C 			 ; write bit
 19BD  74 02		      C 	jz	short @f
			      C 	;test	ah, 4
			      C 	;;test	ax, 400h ; Bit 10 of word 0 (status word)
			      C 	;		 ; read bit
			      C 	;jz	short diskio_ret
 19BF  FE C6		      C 	inc	dh ; 03h = write
 19C1			      C @@:	
			      C 	;mov	cx, 4 ; Retry Count
 19C1  B1 04		      C 	mov	cl, 4
			      C 
			      C 	; push	ds
			      C 	; pop	es
 19C3			      C @@:
 19C3  52		      C 	push	dx ; ***** ; **
 19C4  53		      C 	push	bx ; ****
 19C5  51		      C 	push	cx ; ***
 19C6  52		      C 	push	dx ; ** ; I/O type (Int 13h function, r/w)
 19C7  43		      C 	inc 	bx ; +1
 19C8  43		      C 	inc	bx ; +2
 19C9  8B 07		      C 	mov	ax, word ptr [BX]
			      C 			; Block/Sector number
 19CB  33 D2		      C 	xor 	dx, dx
 19CD  D1 E6		      C 	shl	si, 1	; 2 * device number ; 26/04/2013
 19CF  8B 8C 26D2 R	      C 	mov	cx, word ptr [SI]+drv.spt
			      C 			; Sectors per track
 19D3  F7 F1		      C 	div	cx
 19D5  8B CA		      C 	mov	cx, dx	; remainder, sector (zero based)
 19D7  41		      C 	inc	cx	; sector (1 based)
 19D8  51		      C 	push	cx ; *
 19D9  8B 8C 26DE R	      C 	mov	cx, word ptr [SI]+drv.hds ; Heads
 19DD  33 D2		      C 	xor 	dx, dx
			      C 	; ax = track number
 19DF  F7 F1		      C 	div	cx     	
 19E1  8A F2		      C 	mov	dh, dl	; head number (<=255)
 19E3  D1 EE		      C 	shr	si, 1	; device number	; 26/04/2013
 19E5  8A 94 26CC R	      C         mov     dl, byte ptr [SI]+drv.pdn ; 26/04/2013
			      C 			; Physical device number
 19E9  59		      C         pop	cx ; *	; cx = sector of track (1 to spt)
 19EA  43		      C 	inc 	bx ; +2
 19EB  43		      C 	inc	bx ; +3	; I/O Buffer (Data)
 19EC  8A E8		      C 	mov	ch, al	; low 8 bytes of cylinder number
 19EE  D0 CC		      C 	ror	ah, 1
 19F0  D0 CC		      C 	ror	ah, 1
 19F2  0A CC		      C 	or	cl, ah
 19F4  58		      C 	pop	ax ; ** ; AH=2-read, AH=3-write
 19F5  CD 13		      C 	int	13h 	; AL-count CH-track CL-sect
			      C                         ; DH-head DL-drive ES:BX-buffer
			      C                         ; CF-flag AH-stat AL-sec read
 19F7  59		      C        	pop	cx ; ***
 19F8  5B		      C 	pop	bx ; ****
 19F9  73 0D		      C 	jnc	short @f
 19FB  80 F9 01		      C 	cmp	cl, 1
 19FE  72 08		      C 	jb	short @f		
 1A00  32 E4		      C 	xor 	ah, ah	; Disk Reset
 1A02  CD 13		      C 	int	13h
 1A04  49		      C 	dec 	cx
 1A05  5A		      C 	pop	dx ; ***** ; **
 1A06  EB BB		      C 	jmp	short @b	
 1A08			      C @@:
 1A08  5A		      C 	pop	dx ; ***** ; **		
 1A09  5E		      C 	pop	si ; ******
			      C 
 1A0A  C3		      C 	retn
			      C 
				include u9.asm ; u9.s
			      C ; ****************************************************************************
			      C ; UNIX.ASM (RETRO UNIX 8086 Kernel - Only for 1.44 MB floppy disks)
			      C ; ----------------------------------------------------------------------------
			      C ; U9.ASM (include u9.asm) //// UNIX v1 -> u9.s
			      C 
			      C ; RETRO UNIX 8086 (Retro Unix == Turkish Rational Unix)
			      C ; Operating System Project (v0.1) by ERDOGAN TAN (Beginning: 11/07/2012) 
			      C ; 1.44 MB Floppy Disk 
			      C ; (11/03/2013)
			      C ;
			      C ; [ Last Modification: 14/06/2022 ] ;;; completed ;;;
			      C ;
			      C ; Derivation from UNIX Operating System (v1.0 for PDP-11) 
			      C ; (Original) Source Code by Ken Thompson (1971-1972)
			      C ; <Bell Laboratories (17/3/1972)>
			      C ; <Preliminary Release of UNIX Implementation Document>
			      C ;
			      C ; ****************************************************************************
			      C ; 26/01/2022 - 04/02/2022
			      C 
			      C ; 30/01/2022 - compact kernel (moving buffers to bss section)
			      C 
			      C ; 01/09/2014
			      C ; 28/08/2014
			      C ; 28/07/2014
			      C ; 27/07/2014
			      C ; 23/07/2014
			      C ; 20/07/2014
			      C ; 12/07/2014
			      C ; 04/07/2014
			      C ; 30/06/2014
			      C ; 27/06/2014
			      C ; 25/06/2014
			      C ; 11/06/2014
			      C ; 03/06/2014
			      C ; 02/06/2014
			      C ; 05/05/2014
			      C ; 30/04/2014
			      C ; 17/04/2014
			      C ; 15/04/2014
			      C ; 04/04/2014 scroll_up
			      C ; 07/03/2014
			      C ; 04/03/2014 act_disp_page --> tty_sw
			      C ; 03/03/2014 int_09h, int_16h
			      C ; 28/02/2014 int_16h
			      C ; 17/02/2014
			      C ; 14/02/2014
			      C ; 01/02/2014 write_tty
			      C ; 18/01/2014
			      C ; 17/01/2014
			      C ; 13/01/2014 getc, putc
			      C ; 12/12/2013
			      C ; 10/12/2013
			      C ; 07/12/2013
			      C ; 04/12/2013 getc, putc, write_tty
			      C ; 04/11/2013 drv_init
			      C ; 24/07/2013 bf_init
			      C ; 20/07/2013 bf_init
			      C ; 19/07/2013 drv_init
			      C ; 18/07/2013 drv_init
			      C ; 17/07/2013 bf_init
			      C ; 14/07/2013
			      C ; 13/07/2013 drv_init, dparam (Retro UNIX 8086 v1 features only!)
			      C ; 21/05/2013 'ocvt' & 'ccvt' routines (in U7.ASM)
			      C ; 15/05/2013 'rcvt' & 'xmtt' routines (in U6.ASM)
			      C ; 11/03/2013
			      C 
			      C ;;rcvt:
			      C ;; 'rcvt' routine is in U6.ASM (Retro UNIX 8086 v1 modification!)
			      C 
			      C ;;xmtt:
			      C ;; 'xmtt' routine is in U6.ASM (Retro UNIX 8086 v1 modification!)
			      C 
			      C ;;ocvt:
			      C ;; 'ocvt' routine is in U7.ASM (Retro UNIX 8086 v1 modification!)
			      C 
			      C ;;ccvt:
			      C ;; 'ccvt' routine is in U7.ASM (Retro UNIX 8086 v1 modification!)
			      C 
 1A0B			      C drv_init:
			      C 	; 30/01/2022
			      C 	; 04/11/2013
			      C 	; 19/07/2013
			      C 	; 18/07/2013
			      C 	; 14/07/2013
			      C 	; 13/07/2013
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; Derived from DRVINIT.ASM (DRVINIT4) file of TR-DOS project
			      C 	; by Erdogan Tan, (26/09/2009 --> 07/08/2011)
			      C 	;
			      C 	; Modified/Simplified for Retro UNIX 8086 v1
			      C 	;
			      C 	; (LBA disks excluded, hard disk file systems excluded)
			      C 	;
			      C 	; ((RUFS and/or TRFS/SINGLIX partitions will be validated
			      C 	;  in future RUNIX/TR-UNIX versions if they will be available.)	
			      C 	;
			      C 	; Input: none
			      C 	; Output:
			      C 	;	cf = 0 -> disk drive initialization is ok.
			      C 	;	cf = 1 -> error (error code in ah)
			      C 	; ((Modified registers: AX, BX, CX, DX, SI, DI)) 		
 1A0B			      C fd_init:
 1A0B  33 D2		      C         xor 	dx, dx  ; fd0
 1A0D  33 F6		      C         xor	si, si ; 0
 1A0F  E8 0064		      C 	call 	dparam
 1A12  46		      C 	inc	si ; 1
 1A13  3C 02		      C 	cmp	al, 2 ; 04/11/2013
 1A15  72 05		      C 	jb	short hd_init
 1A17  FE C2		      C 	inc 	dl ; fd1
 1A19  E8 005A		      C 	call	dparam
 1A1C			      C hd_init:
 1A1C  46		      C 	inc	si ; 2
 1A1D  B2 80		      C 	mov	dl, 80h ; hd0
 1A1F  E8 0054		      C 	call 	dparam
 1A22  72 15		      C 	jc 	short drv_init_lbs
			      C 	; al = number of hard disk drives
 1A24  3C 02		      C 	cmp	al, 2 ; 04/11/2013
 1A26  72 11		      C 	jb	short drv_init_lbs
 1A28  A2 26EA R	      C 	mov	byte ptr [brwdev], al ; 19/07/2013 
 1A2B			      C @@:
 1A2B  FE 0E 26EA R	      C 	dec	byte ptr [brwdev] ; 19/07/2013 
 1A2F  74 08		      C 	jz  	short drv_init_lbs
 1A31  46		      C 	inc	si
 1A32  FE C2		      C 	inc 	dl 
 1A34  E8 003F		      C 	call	dparam
 1A37  EB F2		      C 	jmp	short @b
			      C 
 1A39			      C drv_init_lbs:
 1A39  0E		      C 	push	cs ; 14/07/2013
 1A3A  07		      C 	pop	es ; 14/07/2013
 1A3B  33 DB		      C 	xor	bx, bx
 1A3D  8A 16 25E8 R	      C 	mov	dl, byte ptr [unixbootdrive]
 1A41			      C @@:
 1A41  3A 97 26CC R	      C 	cmp	dl, byte ptr [BX]+drv.pdn
 1A45  74 0E		      C 	je	short @f
 1A47  3B DE		      C         cmp     bx, si ; 19/07/2013      
 1A49  73 04		      C 	jnb	short drv_init_err
 1A4B  FE C3		      C 	inc	bl
 1A4D  EB F2		      C 	jmp	short @b
 1A4F			      C drv_init_err:
 1A4F  8A A7 26C6 R	      C 	mov	ah, byte ptr [BX]+drv.err
 1A53  F9		      C 	stc
 1A54  C3		      C 	retn
 1A55			      C @@:
 1A55  80 BF 26C6 R 00	      C 	cmp	byte ptr [BX]+drv.err, 0
 1A5A  77 F3		      C 	ja	short drv_init_err
			      C 	; 30/01/2022
 1A5C  BE 2A26 R	      C 	mov	si, sb0 ; mov si, offset sb0 ; super block buffer
 1A5F  88 1C		      C 	mov	byte ptr [SI], bl ; Device Id
 1A61  C6 44 01 04	      C 	mov	byte ptr [SI]+1, 4 ; Bit 10,
			      C 				   ; read bit
 1A65  88 1E 26C4 R	      C 	mov	byte ptr [rdev], bl ; 19/07/2013
 1A69  8B DE		      C 	mov	bx, si
 1A6B  FE 47 02		      C 	inc	byte ptr [BX]+2 ; physical block number = 1
 1A6E  E8 FF3D		      C 	call 	diskio
 1A71  C6 47 01 00	      C 	mov	byte ptr [BX]+1, 0 ; 18/07/2013
 1A75  C3		      C 	retn
			      C 
 1A76			      C dparam:
			      C 	; 13/07/2013
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
 1A76  52		      C         push 	dx
 1A77  B4 08		      C         mov 	ah, 08h
 1A79  CD 13		      C         int 	13h
 1A7B  88 A4 26C6 R	      C         mov 	byte ptr [SI]+drv.err, ah
 1A7F  73 02		      C         jnc 	short @f
 1A81			      C dparam_error:
 1A81  5A		      C 	pop 	dx
 1A82  C3		      C 	retn
 1A83			      C @@:
 1A83  8A C2		      C    	mov	al, dl ; Number of disk drives
			      C 	;cmp	al, 1
			      C 	;jb	short dparam_err
			      C 	; dh = last head number
 1A85  FE C6		      C 	inc 	dh
 1A87  8A D6		      C         mov     dl, dh
 1A89  32 F6		      C         xor     dh, dh
 1A8B  D1 E6		      C         shl	si, 1 ; align to word ptr drv.hds
 1A8D  89 94 26DE R	      C         mov     word ptr [SI]+drv.hds, dx
			      C 			        ; number of heads
 1A91  83 E1 3F		      C         and     cx, 3Fh
			      C 	; SI is already aligned for word ptr drv.spt
 1A94  89 8C 26D2 R	      C         mov     word ptr [SI]+drv.spt, cx
 1A98  D1 EE		      C 	shr	si, 1 ; align to byte ptr drv.pdn
 1A9A  5A		      C 	pop	dx
 1A9B  88 94 26CC R	      C 	mov	byte ptr [SI]+drv.pdn, dl
			      C 			     ; Physical drive number
 1A9F  C3		      C 	retn
			      C 
 1AA0			      C bf_init:
			      C 	; 30/01/2022
			      C 	; 24/07/2013 (from last to first)
			      C 	; 20/07/2013 Device id reset (0FFh)
			      C 	; 17/07/2013
			      C 	; Buffer (pointer) initialization !
			      C 	;
			      C 	;   Retro UNIX 8086 v1 feature only !
			      C 	;
 1AA0  B1 08		      C 	mov	cl, nbuf
 1AA2  BF 26AA R	      C 	mov	di, offset bufp 
			      C 	; 24/07/2013
			      C 	;mov	ax, offset Buffer + (nbuf*516) 
			      C 	; 30/01/2022
 1AA5  B8 3E4E R	      C 	mov	ax, Buffer+(nbuf*516)
 1AA8  BA FFFF		      C 	mov	dx, 0FFFFh
 1AAB			      C @@:
			      C 	; 24/07/2013
 1AAB  2D 0204		      C 	sub	ax, 516 ; 4 header + 512 data
 1AAE  AB		      C 	stosw
 1AAF  8B F0		      C 	mov	si, ax ; 24/07/2013
			      C 	; mov 	word ptr [SI], dx ; 0FF00h
 1AB1  88 14		      C 	mov	byte ptr [SI], dl ; 0FFh
			      C 			    ; Not a valid device sign
			      C 	;mov	word ptr [SI]+2, dx ; 0FFFFh
			      C 		      ; Not a valid block number sign 	 	
 1AB3  FE C9		      C 	dec	cl
 1AB5  75 F4		      C 	jnz	short @b
			      C 	; 30/01/2022
 1AB7  B8 2A26 R	      C 	mov	ax, sb0 ; mov ax, offset sb0
 1ABA  AB		      C 	stosw
			      C 	; 30/01/2022
 1ABB  B8 2C2A R	      C 	mov	ax, sb1 ; mov ax, offset sb1
 1ABE  AB		      C 	stosw
			      C 	; 20/07/2013
 1ABF  8B F0		      C 	mov	si, ax ; offset sb1
 1AC1  88 14		      C 	mov	byte ptr [SI], dl ; 0FFh
			      C 	;mov	word ptr [SI]+2, dx ; 0FFFFh
			      C         ; 
 1AC3  C3		      C 	retn
			      C 
 1AC4			      C getc: 
			      C 	;04/07/2014 (rcvc has been removed)
			      C 	;	    (serial port interrupts)	
			      C 	;27/06/2014 (rcvc, EOT)
			      C 	;03/06/2014 (rcvc)
			      C 	;02/06/2014 (rcvc has been moved here again) 
			      C 	;05/05/2014 (rcvc has been moved from here)
			      C 	;17/04/2014
			      C 	;15/04/2014 (rcvc) 
			      C 	;17/02/2014
			      C 	;14/02/2014
			      C 	;17/01/2014
			      C 	;13/01/2014
			      C 	;10/12/2013
			      C 	;20/10/2013
			      C 	;10/10/2013
			      C 	;05/10/2013
			      C 	;24/09/2013 
			      C 	;20/09/2013
			      C 	;29/07/2013 (getc_s, sleep -> idle)
			      C 	;28/07/2013 (byte ptr [u.ttyn] = tty number)
			      C 	;16/07/2013
			      C 	;20/05/2013
			      C 	;14/05/2013 (AH input instead of 'mov ax, byte ptr [ptty]')
			      C 	;13/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; 'getc' gets (next) character 
			      C 	;	 from requested TTY (keyboard) buffer 
			      C 	; INPUTS ->
			      C 	;     [u.ttyn] = tty number (0 to 7) (8 is COM1, 9 is COM2)	
			      C 	;     AL=0 -> Get (next) character from requested TTY buffer
			      C 	;	(Keyboard buffer will point to 
			      C 	;			next character at next call)
			      C 	;     AL=1 -> Test a key is available in requested TTY buffer
			      C 	;	(Keyboard buffer will point to 
			      C 	;			current character at next call)
			      C 	; OUTPUTS ->
			      C 	;     (If AL input is 1) ZF=1 -> 'empty buffer' (no chars)
			      C 	;     			 ZF=0 -> AX has (current) character
			      C 	;      AL = ascii code
			      C 	;      AH = scan code	(AH = line status for COM1 or COM2)	 			
			      C 	; 		        (cf=1 -> error code/flags in AH)
			      C 	; Original UNIX V1 'getc': 
			      C 	;		get a character off character list
			      C 	;
			      C 	; ((Modified registers: AX, BX, -CX-, -DX-, -SI-, -DI-))	
			      C 	;
			      C 
			      C 	; 16/07/2013
			      C 	; mov 	byte ptr [getctty], ah
			      C 	;
			      C 
 1AC4  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn] ; 28/07/2013
 1AC8			      C getc_n:
			      C 	; 10/10/2013
 1AC8  BB 2766 R	      C 	mov	bx, offset ttychr
 1ACB  22 E4		      C 	and	ah, ah
 1ACD  74 07		      C 	jz	short @f
 1ACF  D0 E4		      C 	shl	ah, 1
			      C 	; 17/02/2014
 1AD1  02 DC		      C 	add	bl, ah
 1AD3  80 D7 00		      C 	adc	bh, 0
			      C 	; 24/09/2013
			      C 	;mov	bl, ah
			      C 	;xor	bh, bh
			      C 	;shl	bl, 1
			      C 	;add	bx, offset ttychr
 1AD6			      C @@:
 1AD6  8B 0F		      C 	mov	cx, word ptr [BX] ; ascii & scan code
			      C 				  ; (by kb_int)	
 1AD8  0B C9		      C 	or	cx, cx
 1ADA  75 07		      C 	jnz	short @f
 1ADC  22 C0		      C 	and 	al, al
 1ADE  74 11		      C 	jz	short getc_s
 1AE0  33 C0		      C 	xor	ax, ax
 1AE2  C3		      C 	retn
 1AE3			      C @@:	
 1AE3  22 C0		      C 	and	al, al
 1AE5  8B C1		      C 	mov	ax, cx
 1AE7  B9 0000		      C 	mov	cx, 0
 1AEA  75 04		      C 	jnz	short @f
 1AEC			      C getc_sn:
 1AEC  89 0F		      C 	mov	word ptr [BX], cx ; 0, reset
 1AEE  3B C1		      C 	cmp	ax, cx  ; zf = 0
 1AF0			      C @@:
 1AF0  C3		      C 	retn
 1AF1			      C getc_s:
			      C 	; 14/02/2014 uquant -> u.quant
			      C 	; 10/12/2013
			      C 	; 20/10/2013 
			      C 	; 05/10/2013
			      C 	; 24/09/2013
			      C 	; 20/09/2013
			      C 	; 29/07/2013
			      C 	; 28/07/2013
			      C 	; 16/07/2013
			      C 	; tty  of the current process is not 
			      C 	; current tty (ptty); so, current process only 
			      C 	; can use keyboard input when its tty becomes 
			      C 	; current tty (ptty).
			      C 	; 'sleep' is for preventing an endless lock
			      C 	; during this tty input request.
			      C 	; (Because, the user is not looking at the video page
			      C 	; of the process to undersand there is a keyboard
			      C 	; input request.)
			      C 	;; 29/07/2013
			      C 	; 20/09/2013
			      C 	;((Modified registers: AX, BX, CX, DX, SI, DI))
			      C 	;
			      C 	; 05/10/2013
			      C 	; ah = byte ptr [u.ttyn] ; (tty number)
			      C 	;
			      C 	; 10/10/2013
 1AF1			      C gcw0:
 1AF1  B1 0A		      C 	mov	cl, 10 ; ch = 0
 1AF3			      C gcw1:	
 1AF3  E8 F4B4		      C 	call	idle
 1AF6  8B 07		      C 	mov	ax, word ptr [BX] ; ascii & scan code
			      C 				  ; (by kb_int)
 1AF8  0B C0		      C 	or	ax, ax
 1AFA  75 1E		      C 	jnz	short gcw3
 1AFC  E2 F5		      C 	loop	gcw1
			      C 	;
 1AFE  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn] ; 20/10/2013
			      C 	; 10/12/2013
 1B02  3A 26 2736 R	      C 	cmp 	ah, byte ptr [ptty]
 1B06  75 07		      C 	jne	short gcw2
			      C 	; 14/02/2014
 1B08  80 3E 27DF R 01	      C 	cmp	byte ptr [u.uno], 1
 1B0D  76 E2		      C 	jna	short gcw0		
 1B0F			      C gcw2:
 1B0F  E8 F51C		      C 	call	sleep
			      C 
			      C 	; 20/09/2013
 1B12  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn]
 1B16  32 C0		      C 	xor 	al, al
 1B18  EB AE		      C 	jmp	short getc_n
 1B1A			      C gcw3:
			      C 	; 10/10/2013
 1B1A  32 C9		      C 	xor	cl, cl
 1B1C  EB CE		      C 	jmp	short getc_sn
			      C 
			      C 
 1B1E			      C sndc:   ; <Send character>
			      C 	;
			      C 	; 28/07/2014
			      C 	; 27/07/2014
			      C 	; 23/07/2014
			      C 	; 20/07/2014
			      C 	; 12/07/2014
			      C 	; 04/07/2014
			      C 	; 27/06/2014
			      C 	; 25/06/2014
			      C 	; 15/04/2014
			      C 	; 13/01/2014
			      C 	; 16/07/2013 bx
			      C 	; 14/05/2013	
			      C 	;
			      C 	; Retro UNIX 8086 v1 feature only !
			      C 	;
			      C 	; 12/07/2014
 1B1E  32 F6		      C 	xor 	dh, dh
 1B20  8A D4		      C 	mov 	dl, ah
			      C 	; 27/07/2014
 1B22  80 EA 08		      C 	sub	dl, 8
			      C 	; 25/06/2014
 1B25  50		      C 	push	ax
 1B26			      C sndcs:
			      C 	; 28/07/2014
			      C ;	; 27/07/2014
			      C ;	mov	cx, 10
			      C ;@@:
 1B26  B4 03		      C 	mov	ah, 3 	; Get serial port status
 1B28  CD 14		      C 	int	14h
 1B2A  F6 C4 20		      C 	test	ah, 20h	; Transmitter holding register empty ?
 1B2D  75 15		      C 	jnz	short @f
			      C ;	call	idle
			      C ;	loop	@b
			      C 	;
 1B2F  52		      C 	push	dx
 1B30  53		      C 	push	bx
			      C 	; 27/07/2014
 1B31  8B DA		      C 	mov 	bx, dx
 1B33  81 C3 2798 R	      C 	add	bx, offset tsleep
			      C 	;
 1B37  8A 26 27E2 R	      C 	mov	ah, byte ptr [u.ttyn]
			      C 	;
 1B3B  88 27		      C 	mov	byte ptr [BX], ah ; 27/07/2014
			      C 	;
 1B3D  E8 F4EE		      C 	call	sleep
 1B40  5B		      C 	pop	bx
 1B41  5A		      C 	pop	dx
 1B42  EB E2		      C 	jmp	short sndcs
 1B44			      C @@:
 1B44  58		      C 	pop	ax
 1B45			      C @@:
			      C 	;mov 	ah, 1	; Send character
			      C 	;int 	14h
			      C 	; 13/07/2014
 1B45  52		      C 	push	dx
 1B46  0A D2		      C 	or	dl, dl
 1B48  BA 02F8		      C 	mov	dx, 2F8h   ;data port (COM2)
 1B4B  75 04		      C 	jnz	short @f
 1B4D  81 C2 0100	      C 	add	dx, 100h   ;3F8h, data port (COM1)
 1B51			      C @@:
 1B51  EE		      C 	out	dx, al	   ;send on serial port
 1B52  5A		      C 	pop	dx
			      C 	; 27/07/2014
 1B53  E8 F454		      C 	call	idle
			      C 	; 
 1B56  B4 03		      C 	mov	ah, 3 	; Get serial port status
 1B58  CD 14		      C 	int	14h
 1B5A  80 FC 80		      C 	cmp	ah, 80h ; time out error
 1B5D  F5		      C 	cmc	; cf = 0 (OK), cf = 1 (error!)
 1B5E			      C @@:	
 1B5E  C3		      C 	retn
			      C 
 1B5F			      C putc:
			      C 	; 04/02/2022	
			      C 	; 26/01/2022 (BugFix)
			      C 	; 27/07/2014
			      C 	; 23/07/2014
			      C 	; 20/07/2014
			      C 	; 27/06/2014 (sndc, EOT)
			      C 	; 25/06/2014
			      C 	; 05/05/2014
			      C 	; 15/04/2014
			      C 	; 13/01/2014
			      C 	; 04/12/2013 write_tty
			      C 	; 03/12/2013 write_tty, beep, waitf
			      C 	;	   (for video page switch bug-fixing)	
			      C 	; 30/11/2013
			      C 	; 04/11/2013
			      C 	; 30/10/2013   
			      C 	; 24/09/2013 consistency check -> ok
			      C 	; 20/09/2013 (cx = repeat count)
			      C 	;  (int 10h, function 0Eh -> function 09h)
			      C 	;  (video page can be selected in function 09h only!) 
			      C 	; 26/08/2013
			      C 	; 14/05/2013
			      C 	; Retro UNIX 8086 v1 modification !
			      C 	; 
			      C 	; 'putc' puts a character 
			      C 	;	 onto requested (tty) video page or
			      C 	;	 serial port
			      C 	; INPUTS ->
			      C 	;     AL = ascii code of the character
			      C 	;     AH = video page (tty) number (0 to 7)
			      C 	;			  (8 is COM1, 9 is COM2)	
			      C 	; OUTPUTS ->
			      C 	;    (If AL input is 1) ZF=1 -> 'empty buffer' (no chars)
			      C 	;      			ZF=0 -> AX has (current) character
			      C 	;     cf=0 and AH = 0 -> no error
			      C 	;     cf=1 and AH > 0 -> error (only for COM1 and COM2)		 			
			      C 	; 
			      C 	; Original UNIX V1 'putc': 
			      C 	;     put a character at the end of character list
			      C 	;
			      C 	; ((Modified registers: AX, BX, CX, DX, SI, DI))
			      C 	;
 1B5F  80 FC 07		      C 	cmp	ah, 7
 1B62  77 BA		      C 	ja	short sndc ; send character
			      C 
 1B64			      C write_tty:
			      C 	; 04/02/2022
			      C 	; 29/01/2022
			      C 	; Ref: IBM PC/AT BIOS v3 (VIDEO1.ASM, 15/11/1985)
			      C 	; 26/01/2022 (BugFix)
			      C 	; 01/02/2014
			      C 	; 18/01/2014
			      C 	; 12/12/2013
			      C 	; 04/12/2013 
			      C 	; 03/12/2013
			      C 	; (Modified registers: AX, BX, CX, DX, SI, DI)
			      C 
 = 0008			      C RVRT	equ	00001000b	; VIDEO VERTICAL RETRACE BIT
 = 0001			      C RHRZ	equ	00000001b	; VIDEO HORIZONTAL RETRACE BIT
			      C 
			      C 	; mov 	bl, 07h
			      C 
			      C ; Derived from "WRITE_TTY" procedure of IBM "pc-at" rombios source code
			      C ; (06/10/1985), 'video.asm', INT 10H, VIDEO_IO
			      C ;
			      C ; 06/10/85  VIDEO DISPLAY BIOS
			      C ;
			      C ;--- WRITE_TTY ------------------------------------------------------------------
			      C ;										:
			      C ;   THIS INTERFACE PROVIDES A TELETYPE LIKE INTERFACE TO THE			:
			      C ;   VIDEO CARDS. THE INPUT CHARACTER IS WRITTEN TO THE CURRENT			:
			      C ;   CURSOR POSITION, AND THE CURSOR IS MOVED TO THE NEXT POSITION.		:
			      C ;   IF THE CURSOR LEAVES THE LAST COLUMN OF THE FIELD, THE COLUMN		:
			      C ;   IS SET TO ZERO, AND THE ROW VALUE IS INCREMENTED. IF THE ROW		:
			      C ;   ROW VALUE LEAVES THE FIELD, THE CURSOR IS PLACED ON THE LAST ROW,		:
			      C ;   FIRST COLUMN, AND THE ENTIRE SCREEN IS SCROLLED UP ONE LINE.		:
			      C ;   WHEN THE SCREEN IS SCROLLED UP, THE ATTRIBUTE FOR FILLING THE		:
			      C ;   NEWLY BLANKED LINE IS READ FROM THE CURSOR POSITION ON THE PREVIOUS		:
			      C ;   LINE BEFORE THE SCROLL, IN CHARACTER MODE. IN GRAPHICS MODE,		:
			      C ;   THE 0 COLOR IS USED.							:
			      C ;   ENTRY --									:
			      C ;     (AH) = CURRENT CRT MODE							:
			      C ;     (AL) = CHARACTER TO BE WRITTEN						:
			      C ;	    NOTE THAT BACK SPACE, CARRIAGE RETURN, BELL AND LINE FEED ARE	:
			      C ;	    HANDLED AS COMMANDS RATHER THAN AS DISPLAY GRAPHICS CHARACTERS	:
			      C ;     (BL) = FOREGROUND COLOR FOR CHAR WRITE IF CURRENTLY IN A GRAPHICS MODE	:
			      C ;   EXIT -- 									:
			      C ;     ALL REGISTERS SAVED							:
			      C ;--------------------------------------------------------------------------------
			      C 
			      C 	;;push	ax 		; save character and video page number
			      C 	;;mov	bh, ah 		; get page setting
			      C 	;;mov	ah, 03h		; (read cursor position)
			      C 	;;int 	10h
			      C 	;;pop	ax 		; recover character and video page
			      C 
			      C 	;cli	; 29/01/2022
			      C 
			      C 	; READ CURSOR (04/12/2013)
 1B64  32 FF		      C 	xor	bh, bh
 1B66  8A DC		      C 	mov	bl, ah
 1B68  D0 E3		      C 	shl	bl, 1
			      C 	;add	bx, offset cursor_posn
			      C 	;mov	dx, word ptr [BX]
			      C 	; 29/01/2022
 1B6A  8B 97 2726 R	      C 	mov	dx, word ptr [BX + offset cursor_posn]
			      C 	;mov	cx, word ptr [cursor_mode]	
			      C 
			      C 	;mov	bl, 07h		;
			      C 	;mov	bh, ah		;
			      C 	; 29/01/2022		
			      C 	;mov	bl, ah		; video page number
 1B6E  D0 EB		      C 	shr	bl, 1
			      C 	;xor	bh, bh
			      C 
			      C 	; dx now has the current cursor position
			      C 	
 1B70  3C 0D		      C 	cmp	al, 0Dh		; is it carriage return or control character
 1B72  76 24		      C 	jbe	short u8
			      C 	
			      C 	; write the char to the screen
 1B74			      C u0:	
			      C 	;mov	ah, 0Ah 	; write character only command
			      C 	;mov	cx, 1		; only one character
			      C 	;int	10h		; write the character
			      C 
 1B74  B4 07		      C 	mov 	ah, 07h ; attribute/color
			      C 	; al = character
			      C 	; bl = video page number (0 to 7)
			      C 	;
 1B76  E8 0180		      C 	call	write_c_current
			      C 
			      C 	; position the cursor for next char
			      C 
 1B79  FE C2		      C 	inc	dl
 1B7B  80 FA 50		      C 	cmp	dl, 80 		; test for column overflow
			      C 	;;jne	short u7
			      C 	;jne	set_cpos
			      C 	; 26/01/2022
			      C 	;je	short @f
			      C 	;jmp	set_cpos
			      C 	; 04/02/2022
 1B7E  75 4A		      C 	jne	short set_cpos
			      C ;@@:
 1B80  B2 00		      C 	mov	dl, 0
 1B82			      C u10:	; 29/01/2022
 1B82  80 FE 18		      C 	cmp	dh, 25-1 	; check for last row
 1B85  75 0D		      C 	jne	short u6
			      C 
			      C 	; scroll required
 1B87			      C u1:	
			      C 	;;mov	ah, 02h
			      C 	;;int	10h		; set the cursor
			      C 	; SET CURSOR POSITION (04/12/2013)
 1B87  E8 0040		      C 	call	set_cpos
			      C 
			      C 	; determine value to fill with during scroll
 1B8A			      C u2:
			      C 	;;mov	ah, 08h		; get read cursor command
			      C 	;;int	10h		; read char/attr at current cursor
			      C 
			      C 	; READ_AC_CURRENT		:
			      C 	;   THIS ROUTINE READS THE ATTRIBUTE AND CHARACTER
			      C 	;    AT THE CURRENT CURSOR POSITION
			      C 	;
			      C 	; INPUT				
			      C 	;	(AH) = CURRENT CRT MODE
			      C 	;	(BH) = DISPLAY PAGE ( ALPHA MODES ONLY )
			      C 	;	(DS) = DATA SEGMENT
			      C 	;	(ES) = REGEN SEGMENT
			      C 	; OUTPUT			
			      C 	;	(AL) = CHARACTER READ
			      C 	;	(AH) = ATTRIBUTE READ
			      C 	
			      C 	; mov	ah, byte ptr [crt_mode]	; move current mode into ah
			      C 	;
			      C 	; bl = video page number
			      C 
			      C 	; 29/01/2022
			      C 
			      C ;	call	find_position	; get regen location and port address
			      C ;	; dx = status port
			      C ;	;mov	si, di 		; establish addressing in si
			      C ;	; si = cursor location/address
			      C ;	;push	es		; get regen segment for quick access
			      C ;	;pop	ds
			      C ;p11:
			      C ;	sti			; enable interrupts
			      C ;	nop			; allow for small interrupts window
			      C ;	cli			; blocks interrupts for single loop
			      C ;	in	al, dx		; get status from adapter
			      C ;	test	al, RHRZ	; is horizontal retrace low
			      C ;	jnz	short p11	; wait until it is
			      C ;	;
			      C ;p12:				; now wait for either retrace high
			      C ;	in	al, dx		; get status
			      C ;	test	al, RVRT+RHRZ	; is horizontal or vertical retrace high
			      C ;	jz	short p12	; wait until either is active	
			      C ;p13:
			      C ;	;lodsw			; get the character and attribute
			      C ;	;
			      C ;	push	ds
			      C ;	mov	ax, 0B800h
			      C ;	mov 	ds, ax
			      C ;	mov	ax, word ptr [SI]
			      C ;	pop	ds
			      C ;	;	
			      C ;	; al = character, ah = attribute
			      C ;	;
			      C ;	sti
			      C 
			      C 	; 29/01/2022
			      C 	; bl = video page number
 1B8A  E8 01C9		      C 	call	read_ac_current
			      C 	; al = character, ah = attribute
			      C 
 1B8D  8A FC		      C 	mov	bh, ah		; store in bh
			      C 	; bl = video page number 	
 1B8F			      C u3:
			      C 	;;mov	ax, 0601h 	; scroll one line
			      C 	;;sub	cx, cx		; upper left corner
			      C 	;;mov	dh, 25-1 	; lower right row
			      C 	;mov	dl, 80		; lower right column	
			      C 	;dec	dl
			      C 	;;mov	dl, 79
			      C 
			      C 	;call	scroll_up	; 04/12/2013
 1B8F  B0 01		      C 	mov	al, 1		; scroll one line
 1B91  E9 0106		      C 	jmp	scroll_up
			      C ;u4:
			      C 	;;int	10h		; video-call return
			      C 				; scroll up the screen
			      C 				; tty return
			      C ;u5:
			      C 	;retn			; return to the caller
			      C 			
 1B94			      C u6:				; set-cursor-inc
 1B94  FE C6		      C 	inc	dh		; next row
			      C 				; set cursor
			      C ;u7:					
			      C 	;;mov	ah, 02h
			      C 	;;jmp	short u4 	; establish the new cursor
			      C 	;call	set_cpos
			      C 	;jmp 	short u5
			      C 	; 04/02/2022
			      C 	;jmp	set_cpos
 1B96  EB 32		      C 	jmp	short set_cpos
			      C 
			      C 	; check for control characters
 1B98			      C u8:
 1B98  74 2E		      C 	je	short u9
 1B9A  3C 0A		      C 	cmp	al, 0Ah		; is it a line feed (0Ah)
 1B9C  74 E4		      C 	je	short u10
 1B9E  3C 07		      C 	cmp	al, 07h 	; is it a bell
 1BA0  74 65		      C 	je	short u11
 1BA2  3C 08		      C 	cmp	al, 08h		; is it a backspace
			      C 	;jne	short u0
 1BA4  74 1B		      C 	je	short bs	; 12/12/2013
			      C 	; 12/12/2013 (tab stop)
 1BA6  3C 09		      C 	cmp	al, 09h		; is it a tab stop
 1BA8  75 CA		      C 	jne	short u0
 1BAA  8A C2		      C 	mov	al, dl
 1BAC  98		      C 	cbw
 1BAD  B1 08		      C 	mov	cl, 8
 1BAF  F6 F1		      C 	div	cl
 1BB1  2A CC		      C 	sub	cl, ah
 1BB3			      C ts:
 1BB3  51		      C 	push	cx
 1BB4  B0 20		      C 	mov	al, 20h
			      C 	; 26/01/2022 (BugFix)
 1BB6  8A E3		      C 	mov	ah, bl  ; video page number
 1BB8  E8 FFA9		      C 	call	write_tty
			      C 	; bl = video page number ; 29/01/2022
 1BBB  59		      C 	pop	cx
 1BBC  FE C9		      C 	dec	cl
 1BBE  75 F3		      C 	jnz	short ts
 1BC0  C3		      C 	retn
			      C 
			      C 	; back space found
 1BC1			      C bs:	
 1BC1  0A D2		      C 	or	dl, dl 		; is it already at start of line
			      C 	;je	short u7 	; set_cursor
 1BC3  74 05		      C 	jz	short set_cpos
 1BC5  4A		      C 	dec	dx     		; no -- just move it back
			      C 	;jmp	short u7
 1BC6  EB 02		      C 	jmp	short set_cpos
			      C 
			      C 	; carriage return found
 1BC8			      C u9:
 1BC8  B2 00		      C 	mov	dl, 0 		; move to first column
			      C 	;jmp	short u7
			      C 	; 04/02/2022
			      C 	;jmp	short set_cpos
			      C 
			      C ;	; line feed found
			      C ;	; 29/01/2022
			      C ;u10:
			      C ;	cmp	dh, 25-1 	; bottom of screen
			      C ;	jne	short u6 	; no, just set the cursor
			      C ;	jmp	short u1 	; yes, scroll the screen
			      C 
			      C 	; 14/06/2022 (Retro UNIX 8086 v1, Kernel v0.1.0.3)
			      C 	; 04/02/2022
 1BCA			      C set_cpos:
			      C 	; 26/01/2022
			      C 	; 01/09/2014
			      C 	; 12/12/2013
			      C 	; 10/12/2013
			      C 	; 04/12/2013
			      C 	;
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
			      C 	;
			      C 	; SET_CPOS
			      C 	;	THIS ROUTINE SETS THE CURRENT CURSOR POSITION TO THE
			      C 	;	NEW X-Y VALUES PASSED
			      C 	; INPUT
			      C 	;	DX - ROW,COLUMN OF NEW CURSOR
			      C 	;	BH - DISPLAY PAGE OF CURSOR
			      C 	; OUTPUT
			      C 	;	CURSOR ID SET AT 6845 IF DISPLAY PAGE IS CURRENT DISPLAY
			      C 
			      C 	;mov	al, bh 	; move page number to work register
 1BCA  8A C3		      C 	mov	al, bl 	; page number
 1BCC  98		      C 	cbw		; convert page to word value
 1BCD  8B F0		      C 	mov	si, ax  ; ah = 0, al = video page number
 1BCF  D1 E6		      C 	shl	si, 1	; word offset
 1BD1  89 94 2726 R	      C 	mov	word ptr [SI + offset cursor_posn], dx ; save the pointer
			      C 	; 01/09/2014
 1BD5  38 1E 2736 R	      C 	cmp	byte ptr [active_page], bl ; al
 1BD9  75 2A		      C 	jne	short m17
			      C 	;
 1BDB  8B C2		      C 	mov	ax, dx	; get row/column to ax
			      C 	;call	m18	; CURSOR SET
			      C ;m17:			; SET_CPOS_RETURN
			      C ;	; 01/09/2014
			      C ;	retn
 1BDD			      C m18:
 1BDD  E8 0086		      C 	call	position ; determine location in regen buffer	
 1BE0  8B C8		      C 	mov	cx, ax
			      C 	; 01/09/2014
 1BE2  03 0E 2724 R	      C 	add	cx, word ptr [crt_start]
			      C 			; add in the start address for this page
			      C 	;sar	cx, 1
 1BE6  D1 E9		      C 	shr	cx, 1	; divide by 2 for char only count
 1BE8  B4 0E		      C 	mov	ah, 14	; register number for cursor
			      C 	;call	m16	; output value to the 6845	
			      C 	;retn
			      C 
			      C 	;-----	THIS ROUTINE OUTPUTS THE CX REGISTER
			      C 	;	TO THE 6845 REGISTERS NAMED IN (AH)
 1BEA			      C m16:
 1BEA  FA		      C 	cli
			      C 	;mov	dx, word ptr [addr_6845] ; address register
 1BEB  BA 03D4		      C 	mov 	dx, 03D4h ; I/O address of color card
 1BEE  8A C4		      C 	mov	al, ah	; get value
 1BF0  EE		      C 	out	dx, al	; register set
 1BF1  42		      C 	inc	dx	; data register
 1BF2  EB 00		      C 	jmp	$+2	; i/o delay
 1BF4  8A C5		      C 	mov	al, ch	; data
 1BF6  EE		      C 	out	dx, al	
 1BF7  4A		      C 	dec	dx	
 1BF8  8A C4		      C 	mov	al, ah
 1BFA  FE C0		      C 	inc	al	; point to other data register
 1BFC  EE		      C 	out	dx, al	; set for second register
 1BFD  42		      C 	inc	dx
 1BFE  EB 00		      C 	jmp	$+2	; i/o delay
 1C00  8A C1		      C 	mov	al, cl	; second data value
 1C02  EE		      C 	out	dx, al
 1C03  FB		      C 	sti ; 26/01/2022
			      C ;m17:
			      C 	; 01/09/2014
 1C04  C3		      C 	retn
 1C05			      C m17:
			      C 	; 14/06/2022
			      C 	; ('write_tty' must not return to 'putc' with cf)
 1C05  F8		      C 	clc
 1C06  C3		      C 	retn
			      C 
 1C07			      C beeper: ; 18/01/2014 (sti)
			      C 	; 17/01/2014 (call from 'kb_int')
			      C 	;sti
			      C 
			      C 	; bell found
 1C07			      C u11:
			      C 	; 26/01/2022
 1C07  FB		      C 	sti ; 01/02/2014
			      C 	; 12/12/2013
			      C 	;cmp	bl, byte ptr [active_page]
			      C 	;;jne	short @f	; Do not sound the beep 
			      C 	; 26/01/2022		; if it is not written on the active page
			      C 	;je	short @f
			      C 	;xor	al, al  ; clc
			      C 	;retn
			      C 	; 26/01/2022
 1C08  32 1E 2736 R	      C 	xor	bl, byte ptr [active_page]
 1C0C  75 48		      C 	jnz	short @f
			      C ;@@:
 1C0E  B9 0533		      C 	mov	cx, 1331 	; divisor for 896 hz tone
 1C11  B3 1F		      C 	mov	bl, 31		; set count for 31/64 second for beep
			      C 	;call	beep		; sound the pod bell
			      C 	;jmp	short u5 	; tty_return
			      C 	;retn
			      C 	
 = 0040			      C TIMER	equ 	040h   		; 8254 TIMER - BASE ADDRESS
 = 0061			      C PORT_B	equ	061h		; PORT B READ/WRITE DIAGNOSTIC REGISTER
 = 0001			      C GATE2	equ	00000001b	; TIMER 2 INPUT CATE CLOCK BIT
 = 0002			      C SPK2	equ	00000010b	; SPEAKER OUTPUT DATA ENABLE BIT
			      C 
 1C13			      C beep:
			      C 	; 18/01/2014
			      C 	; 10/12/2013
			      C 	; 07/12/2013 (sti)
			      C 	; 03/12/2013
			      C 	;
			      C 	; TEST4.ASM - 06/10/85  POST AND BIOS UTILITY ROUTINES
			      C 	;
			      C 	; ROUTINE TO SOUND THE BEEPER USING TIMER 2 FOR TONE
			      C 	;
			      C 	; ENTRY:
			      C 	;    (BL) = DURATION COUNTER ( 1 FOR 1/64 SECOND )
			      C 	;    (CX) = FREQUENCY DIVISOR (1193180/FREQUENCY) (1331 FOR 886 HZ)
			      C 	; EXIT:			:
			      C 	;    (AX),(BL),(CX) MODIFIED.
			      C 
 1C13  9C		      C 	pushf  ; 18/01/2014	; save interrupt status
 1C14  FA		      C 	cli			; block interrupts during update
 1C15  B0 B6		      C 	mov	al, 10110110b	; select timer 2, lsb, msb binary
 1C17  E6 43		      C 	out	TIMER+3, al 	; write timer mode register
 1C19  EB 00		      C 	jmp	$+2		; I/O delay
 1C1B  8A C1		      C 	mov	al, cl		; divisor for hz (low)
 1C1D  E6 42		      C 	out	TIMER+2,AL	; write timer 2 count - lsb
 1C1F  EB 00		      C 	jmp	$+2		; I/O delay
 1C21  8A C5		      C 	mov	al, ch		; divisor for hz (high)
 1C23  E6 42		      C 	out	TIMER+2, al	; write timer 2 count - msb
 1C25  E4 61		      C 	in	al, PORT_B	; get current setting of port
 1C27  8A E0		      C 	mov	ah, al		; save that setting
 1C29  0C 03		      C 	or	al, GATE2+SPK2	; gate timer 2 and turn speaker on
 1C2B  E6 61		      C 	out	PORT_B, al	; and restore interrupt status
			      C 	;popf	; 18/01/2014
 1C2D  FB		      C 	sti
 1C2E			      C g7:				; 1/64 second per count (bl)
 1C2E  B9 040B		      C 	mov	cx, 1035	; delay count for 1/64 of a second	
 1C31  E8 0023		      C 	call	waitf		; go to beep delay 1/64 count
 1C34  FE CB		      C 	dec	bl		; (bl) length count expired?
 1C36  75 F6		      C 	jnz	short g7	; no - continue beeping speaker
			      C 	;
			      C 	;pushf			; save interrupt status
 1C38  FA		      C 	cli  	; 18/01/2014	; block interrupts during update
 1C39  E4 61		      C 	in	al, PORT_B	; get current port value
 1C3B  0C FC		      C 	or	al, not (GATE2+SPK2) ; isolate current speaker bits in case
 1C3D  22 E0		      C 	and	ah, al		; someone turned them off during beep
 1C3F  8A C4		      C 	mov	al, ah		; recover value of port
 1C41  0C FC		      C 	or	al, not (GATE2+SPK2) ; force speaker data off
 1C43  E6 61		      C 	out	PORT_B, al	; and stop speaker timer
			      C 	;popf			; restore interrupt flag state
 1C45  FB		      C 	sti
 1C46  B9 040B		      C 	mov	cx, 1035	; force 1/64 second delay (short)
 1C49  E8 000B		      C 	call	waitf		; minimum delay between all beeps
			      C 	;pushf			; save interrupt status
 1C4C  FA		      C 	cli			; block interrupts during update
 1C4D  E4 61		      C 	in	al, PORT_B	; get current port value in case	
 1C4F  24 03		      C 	and	al, GATE2+SPK2	; someone turned them on
 1C51  0A C4		      C 	or	al, ah		; recover value of port_b
 1C53  E6 61		      C 	out	PORT_B, al	; restore speaker status
 1C55  9D		      C 	popf			; restore interrupt flag state
 1C56			      C @@:
 1C56  C3		      C 	retn
			      C 
 = 0010			      C REFRESH_BIT equ	00010000b 	; REFRESH TEST BIT
			      C 
 1C57			      C waitf:
			      C 	; 03/12/2013
			      C 	;
			      C 	; TEST4.ASM - 06/10/85  POST AND BIOS UTILITY ROUTINES
			      C 	;
			      C 	; WAITF - FIXED TIME WAIT ROUTINE HARDWARE CONTROLLED - NOT PROCESSOR	
			      C 	;
			      C 	; ENTRY:
			      C 	;    (CX) = COUNT OF 15.,085737 MICROSECOND INTERVALS TO WAIT
			      C 	;	    MEMORY REFRESH TIMER 1 OUTPUT USED AS REFERENCE
			      C 	; EXIT:	
			      C 	;	    AFTER (CX) TIME COUNT (PLUS OR MINUS 16 MICROSECONDS)
			      C 	;    (CX) = 0
			      C 
			      C 	; delay for (cx)*15.085737 us
 1C57  50		      C 	push	ax		; save work register (ah)	
 1C58			      C waitf1:
			      C 				; use timer 1 output bits
 1C58  E4 61		      C 	in	al, PORT_B	; read current counter output status
 1C5A  24 10		      C 	and	al, REFRESH_BIT	; mask for refresh determine bit
 1C5C  38 E0		      C 	cmp	al, ah		; did it just change
 1C5E  74 F8		      C 	je	short waitf1	; wait for a change in output line
			      C 	;
 1C60  8A E0		      C 	mov	ah, al		; save new lflag state
 1C62  E2 F4		      C 	loop	waitf1		; decrement half cycles till count end		
			      C 	;
 1C64  58		      C 	pop	ax		; restore (ah)
 1C65  C3		      C 	retn			; return (cx)=0
			      C 
 1C66			      C position:
			      C 	; 04/12/2013
			      C 	;
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
			      C 	;
			      C 	; POSITION
			      C 	;	THIS SERVICE ROUTINE CALCULATES THE REGEN BUFFER ADDRESS
			      C 	;	OF A CHARACTER IN THE ALPHA MODE
			      C 	; INPUT
			      C 	;	AX = ROW, COLUMN POSITION
			      C 	; OUTPUT
			      C 	;	AX = OFFSET OF CHAR POSITION IN REGEN BUFFER
			      C 
 1C66  53		      C 	push	bx	; save register
 1C67  8A D8		      C 	mov	bl, al
 1C69  8A C4		      C 	mov	al, ah	; rows to al
			      C 	;mul	byte ptr [crt_cols] ; determine bytes to row	
 1C6B  B7 50		      C 	mov	bh, 80
 1C6D  F6 E7		      C 	mul	bh
 1C6F  32 FF		      C 	xor	bh, bh
 1C71  03 C3		      C 	add	ax, bx	; add in column value
			      C 	;sal	ax, 1	
 1C73  D1 E0		      C 	shl	ax, 1	; * 2 for attribute bytes
 1C75  5B		      C 	pop	bx
 1C76  C3		      C 	retn
			      C 
 1C77			      C find_position:
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
 1C77  8A CB		      C 	mov	cl, bl ; video page number
 1C79  32 ED		      C 	xor	ch, ch
 1C7B  8B F1		      C 	mov	si, cx 	; ch = 0, cl = video page number
 1C7D  D1 E6		      C 	shl	si, 1
 1C7F  8B 84 2726 R	      C 	mov	ax, word ptr [SI + Offset cursor_posn]
 1C83  74 08		      C 	jz	short p21
			      C 	;
 1C85  33 F6		      C 	xor	si, si ; else set buffer address to zero
			      C 	;
 1C87			      C p20:
			      C 	;add	si, word ptr [crt_len] ; add length of buffer for one page
 1C87  81 C6 0FA0	      C 	add	si, 80*25*2
 1C8B  E2 FA		      C 	loop	p20
 1C8D			      C p21:
 1C8D  23 C0		      C 	and	ax, ax
 1C8F  74 05		      C 	jz	short @f
 1C91  E8 FFD2		      C 	call 	position ; determine location in regen in page
 1C94  03 F0		      C 	add	si, ax	 ; add location to start of regen page
 1C96			      C @@:
			      C 	;mov	dx, word ptr [addr_6845] ; get base address of active display			
			      C 	;mov	dx, 03D4h ; I/O address of color card
			      C 	;add	dx, 6	; point at status port
 1C96  BA 03DA		      C 	mov	dx, 03DAh
			      C 	; cx = 0
 1C99  C3		      C 	retn
			      C 
 1C9A			      C scroll_up:
			      C 	; 04/04/2014 (BugFix)
			      C 	; 12/12/2013
			      C 	; 04/12/2013
			      C 	;
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
			      C 	;
			      C 	; SCROLL UP
			      C 	;	THIS ROUTINE MOVES A BLOCK OF CHARACTERS UP
			      C 	;	ON THE SCREEN
			      C 	; INPUT
			      C 	;	(AH) = CURRENT CRT MODE
			      C 	;	(AL) = NUMBER OF ROWS TO SCROLL
			      C 	;	(CX) = ROW/COLUMN OF UPPER LEFT CORNER
			      C 	;	(DX) = ROW/COLUMN OF LOWER RIGHT CORNER
			      C 	;	(BH) = ATTRIBUTE TO BE USED ON BLANKED LINE
			      C 	;	(DS) = DATA SEGMENT
			      C 	;	(ES) = REGEN BUFFER SEGMENT
			      C 	; OUTPUT
			      C 	;	NONE -- THE REGEN BUFFER IS MODIFIED
			      C 	;
			      C 	; ((ah = 3))
			      C 	; dl = 79
			      C 	; dh = 24
			      C 	;
			      C 	; al = line count (0 or 1) ((0 == clear video page))
			      C 	; 	((al = 1 for write_tty (putc) procedure))	
			      C 	; bl = video page number (0 to 7)
			      C 	; bh = attribute to be used on blanked line	
			      C 
			      C 	;cli
 1C9A  50		      C 	push	ax
 1C9B  3A 1E 2736 R	      C 	cmp	bl, byte ptr [active_page]
 1C9F  74 12		      C 	je	short n0
 1CA1  33 F6		      C 	xor	si, si
 1CA3  22 DB		      C 	and	bl, bl
 1CA5  74 1D		      C 	jz	short n9
 1CA7  8A CB		      C 	mov	cl, bl
 1CA9			      C @@:
 1CA9  81 C6 0FA0	      C 	add	si, 25*80*2 ; 04/04/2014
 1CAD  FE C9		      C 	dec	cl
 1CAF  75 F8		      C 	jnz	short @b
 1CB1  EB 11		      C 	jmp	short n9
 1CB3			      C n0:
 1CB3  8B 36 2724 R	      C 	mov	si, word ptr [crt_start]
 1CB7			      C n1:	; 04/04/2014
			      C 	;mov	di, si
			      C 	;
			      C 	;inc	dh
			      C 	;inc	dl	 ; increment for origin
			      C 	; dl = 80
			      C 	; dh = 25
			      C 	;cmp	bl, byte ptr [active_page]
			      C 	;jne	short n9
			      C 	;
 1CB7  BA 03DA		      C 	mov	dx, 3DAh ; guaranteed to be color card here	
 1CBA			      C n8:			 ; wait_display_enable
 1CBA  EC		      C 	in	al, dx	 ; get port
 1CBB  A8 08		      C 	test	al, RVRT ; wait for vertical retrace	
 1CBD  74 FB		      C 	jz	short n8 ; wait_display_enable
 1CBF  B0 25		      C 	mov	al, 25h
 1CC1  B2 D8		      C 	mov	dl, 0D8h ; address control port
 1CC3  EE		      C 	out	dx, al	 ; turn off video during vertical retrace
 1CC4			      C n9:
 1CC4  59		      C 	pop	cx    	 ; al = line count
			      C 	;
 1CC5  8B FE		      C 	mov	di, si   ; 04/04/2014
			      C 	;
 1CC7  06		      C 	push	es
 1CC8  1E		      C 	push	ds
 1CC9  B8 B800		      C 	mov	ax, 0B800h
 1CCC  8E C0		      C 	mov	es, ax
 1CCE  8E D8		      C 	mov	ds, ax
			      C 	;
 1CD0  22 C9		      C 	and	cl, cl
 1CD2  75 05		      C 	jnz	short @f
			      C 	; clear video page
 1CD4  B9 07D0		      C 	mov 	cx, 25 * 80
 1CD7  EB 0B		      C 	jmp	short n3
 1CD9			      C @@:
			      C 	;mov	ax, 160
			      C ;	mov	al, 160 ;  2 * (80 columns)
			      C ;	mul	cl
			      C 	;add	si, ax
 1CD9  81 C6 00A0	      C 	add	si, 160
			      C ;	;mov	cx, 24
			      C ;n2:			; row loop
			      C ;	;call	n10	; move one row
			      C ;	;add	si, ax
			      C ;	;add	di, ax
			      C ;	;loop	n2
			      C ;	mov	al, cl
			      C ;	mov	cl, 25
			      C ;	sub	cl, al	
			      C ;	xor	ch, ch	
			      C ;	; cx = line count to move
			      C ;@@:
			      C ;	push	cx		
 1CDD			      C n10:
			      C 	;mov	cx, 80
 1CDD  B9 0780		      C 	mov	cx, 24*80 ; 24 rows/lines
 1CE0  F3/ A5		      C 	rep	movsw	; move one line (up)
			      C 	;loop	n2
			      C ;	pop	cx
			      C ;	loop	@b
			      C ;	mov	cl, al
 1CE2  B1 50		      C 	mov	cl, 80	
 1CE4			      C n3:			; clear entry
 1CE4  8A E7		      C 	mov	ah, bh	; attribute in ah
 1CE6  B0 20		      C 	mov	al, 20h ; fill with blanks
			      C 	; cx = word count to clear (80 or 25*80)
			      C ;@@:
			      C ;	push	cx
 1CE8			      C n11:	
			      C ;	mov	cl, 80  ; get # of columns to clear
 1CE8  F3/ AB		      C 	rep	stosw	; store the fill character
			      C ;	pop	cx
			      C ;	loop	@b
 1CEA			      C n5:			; SCROLL_END
 1CEA  1F		      C 	pop	ds
 1CEB  3A 1E 2736 R	      C 	cmp	bl, byte ptr [active_page]
 1CEF  75 06		      C 	jne	short @f
			      C 	;mov	al, byte ptr [crt_mode_set] ; get the value of mode set
 1CF1  B0 29		      C 	mov	al, 29h ; (ORGS.ASM), M7 mode set table value for mode 3	
 1CF3  BA 03D8		      C 	mov	dx, 03D8h ; always set color card port
 1CF6  EE		      C 	out	dx, al
 1CF7			      C @@:
 1CF7  07		      C 	pop	es
			      C 	;sti
 1CF8  C3		      C 	retn
			      C 
 1CF9			      C write_c_current:
			      C 	; 29/01/2022
			      C 	; (Ref: IBM PC/AT BIOS v3 (VIDEO1.ASM, 15/11/1985)
			      C 	; 18/01/2014
			      C 	; 04/12/2013
			      C 	;
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
			      C 	;
			      C 	; WRITE_C_CURRENT
			      C 	;	THIS ROUTINE WRITES THE CHARACTER AT
			      C 	;	THE CURRENT CURSOR POSITION, ATTRIBUTE UNCHANGED
			      C 	; INPUT	
			      C 	;	(AH) = CURRENT CRT MODE
			      C 	;	(BH) = DISPLAY PAGE
			      C 	;	(CX) = COUNT OF CHARACTERS TO WRITE
			      C 	;	(AL) = CHAR TO WRITE
			      C 	;	(DS) = DATA SEGMENT
			      C 	;	(ES) = REGEN SEGMENT
			      C 	; OUTPUT
			      C 	;	DISPLAY REGEN BUFFER UPDATED
			      C 
			      C 	;cli	; 29/01/2022	
			      C 	
			      C 	; bl = video page
			      C 	; al = character
			      C 	; ah = color/attribute
 1CF9  52		      C 	push	dx
 1CFA  50		      C 	push	ax	; save character & attribute/color
 1CFB  E8 FF79		      C 	call 	find_position  ; get regen location and port address
			      C 	; si = regen location
			      C 	; dx = status port
			      C 	;
			      C 
			      C 	; WAIT FOR HORIZONTAL RETRACE OR VERTICAL RETRACE
			      C 	;
 1CFE			      C p41:			; wait for horizontal retrace is low or vertical
 1CFE  FB		      C 	sti		; enable interrupts first
 1CFF  3A 1E 2736 R	      C 	cmp     bl, byte ptr [active_page]
 1D03  75 0F		      C 	jne	short p44 ; 18/01/2014
 1D05  FA		      C 	cli 		  ; block interrupts for single loop
 1D06  EC		      C 	in	al, dx	  ; get status from the adapter
 1D07  A8 08		      C 	test	al, RVRT  ; check for vertical retrace first
 1D09  75 09		      C 	jnz	short p43 ; Do fast write now if vertical retrace
 1D0B  A8 01		      C 	test	al, RHRZ  ; is horizontal retrace low
 1D0D  75 EF		      C 	jnz	short p41 ; wait until it is
 1D0F			      C p42:			; wait for either retrace high
 1D0F  EC		      C 	in	al, dx ; get status again
 1D10  A8 09		      C 	test	al, RVRT+RHRZ ; is horizontal or vertical retrace high
 1D12  74 FB		      C 	jz	short p42 ; wait until either retrace active
 1D14			      C p43:	; 18/01/2014
			      C 	;sti
 1D14			      C p44:
 1D14  58		      C 	pop	ax	; restore the character (al) & attribute (ah)
 1D15  1E		      C 	push	ds
 1D16  B9 B800		      C 	mov	cx, 0B800h
 1D19  8E D9		      C 	mov	ds, cx
 1D1B  89 04		      C 	mov	word ptr [SI], ax
 1D1D  1F		      C 	pop	ds
 1D1E  5A		      C 	pop	dx
 1D1F  FB		      C 	sti  ; 29/01/2022
 1D20  C3		      C 	retn
			      C 	
 1D21			      C tty_sw:
 1D21  C6 06 27D2 R 00	      C 	mov	byte ptr [u.quant], 0  ; 04/03/2014
			      C 	;
			      C ;act_disp_page: 
			      C 	; 30/06/2015
			      C 	; 04/03/2014  (act_disp_page --> tty_sw)
			      C 	; 10/12/2013
			      C 	; 04/12/2013
			      C 	;
			      C 	; VIDEO.ASM - 06/10/85  VIDEO DISPLAY BIOS
			      C 	;
			      C 	; ACT_DISP_PAGE
			      C 	;	THIS ROUTINE SETS THE ACTIVE DISPLAY PAGE, ALLOWING
			      C 	;	THE FULL USE OF THE MEMORY SET ASIDE FOR THE VIDEO ATTACHMENT
			      C 	; INPUT
			      C 	;	AL HAS THE NEW ACTIVE DISPLAY PAGE
			      C 	; OUTPUT
			      C 	;	THE 6845 IS RESET TO DISPLAY THAT PAGE
			      C 
			      C 	;cli
			      C 
			      C 	;push	bx
 1D26  51		      C 	push	cx
 1D27  52		      C 	push	dx
			      C 	;
 1D28  A2 2736 R	      C 	mov	byte ptr [active_page], al ; save active page value ; [ptty]
			      C 	;mov	cx, word ptr [crt_len] ; get saved length of regen buffer
 1D2B  B9 0FA0		      C 	mov	cx, 25*80*2
 1D2E  98		      C 	cbw		; convert AL to word
 1D2F  50		      C 	push	ax	; save page value
 1D30  F7 E1		      C 	mul 	cx	; display page times regen length
			      C 	; 10/12/2013
 1D32  A3 2724 R	      C 	mov	word ptr [crt_start], ax ; save start address for later
 1D35  8B C8		      C 	mov	cx, ax	; start address to cx
			      C 	;sar	cx, 1
 1D37  D1 E9		      C 	shr	cx, 1	; divide by 2 for 6845 handling
 1D39  B4 0C		      C 	mov	ah, 12	; 6845 register for start address
 1D3B  E8 FEAC		      C 	call	m16
 1D3E  5B		      C 	pop	bx	; recover page value
			      C 	;sal	bx, 1
 1D3F  D1 E3		      C 	shl	bx, 1	; *2 for word offset
 1D41  8B 87 2726 R	      C 	mov	ax, word ptr [BX + offset cursor_posn] ; get cursor for this page
 1D45  E8 FE95		      C 	call	m18
			      C 	;
 1D48  5A		      C 	pop	dx
 1D49  59		      C 	pop	cx
			      C 	;pop	bx
			      C 	;
			      C 	;sti
			      C 	;
 1D4A  C3		      C 	retn
			      C 
 1D4B			      C get_cpos:
			      C 	; 29/01/2022
			      C 	; 04/12/2013 (sysgtty)
			      C 	;
			      C 	; INPUT -> bl = video page number
			      C 	; RETURN -> dx = cursor position
			      C 
 1D4B  53		      C 	push	bx
 1D4C  32 FF		      C 	xor	bh, bh
 1D4E  D0 E3		      C 	shl	bl, 1
			      C 	;add	bx, offset cursor_posn
			      C 	;mov	dx, word ptr [BX]
			      C 	; 29/01/2022
 1D50  8B 97 2726 R	      C 	mov	dx, word ptr [BX + offset cursor_posn]
 1D54  5B		      C 	pop	bx
 1D55  C3		      C 	retn
			      C 
 1D56			      C read_ac_current:
			      C 	; 29/01/2022
			      C 	; (Ref: IBM PC/AT BIOS v3 (VIDEO1.ASM, 15/11/1985)
			      C 	; 04/12/2013 (sysgtty)
			      C 	;
			      C 	; INPUT -> bl = video page number
			      C 	; RETURN -> ax = character (al) and attribute (ah)
			      C 
 1D56  E8 FF1E		      C 	call 	find_position
			      C 
			      C 	; 29/01/2022
			      C 	;
			      C 	; WAIT FOR HORIZONTAL RETRACE OR VERTICAL RETRACE
			      C 	;
 1D59			      C p11:			; wait for horizontal retrace is low or vertical
 1D59  FB		      C 	sti		; enable interrupts first
			      C 	;nop		; allow for small interrupt window
 1D5A  3A 1E 2736 R	      C 	cmp     bl, byte ptr [active_page]
 1D5E  75 0B		      C 	jne	short p13
 1D60  FA		      C 	cli 		; block interrupts for single loop
 1D61  EC		      C 	in	al, dx	; get status from the adapter
 1D62  A8 01		      C 	test	al, RHRZ ; is horizontal retrace low
 1D64  75 F3		      C 	jnz	short p11 ; wait until it is
 1D66			      C p12:			;  wait for either retrace high
 1D66  EC		      C 	in	al, dx ; get status again
 1D67  A8 09		      C 	test	al, RVRT+RHRZ ; is horizontal or vertical retrace high
 1D69  74 FB		      C 	jz	short p12 ; wait until either retrace active
 1D6B			      C p13:
 1D6B  1E		      C 	push	ds
 1D6C  B8 B800		      C 	mov	ax, 0B800h
 1D6F  8E D8		      C 	mov	ds, ax
 1D71  8B 04		      C 	mov	ax, word ptr [SI]
 1D73  1F		      C 	pop	ds
 1D74  FB		      C 	sti	; 29/01/2022
 1D75  C3		      C 	retn
			      C 
			      C ; 11/06/2014
			      C ; Retro UNIX 8086 v1 feature only
			      C ; (INPUT -> none)
 1D76			      C syssleep:
 1D76  8A 1E 27DF R	      C 	mov	bl, byte ptr [u.uno] ; process number
 1D7A  32 FF		      C 	xor	bh, bh
 1D7C  8A A7 2669 R	      C 	mov	ah, byte ptr [BX]+p.ttyc-1 ; current/console tty
 1D80  E8 F2AB		      C 	call	sleep
 1D83  E9 E58A		      C 	jmp	sysret		
			      C 
			      C ; COMMENT 
			      C 
			      C ; 28/02/2014
			      C ; Keyboard function variables (for INT 16h)
			      C ; DS = 40h
			      C ;;DDSDATA    equ 40h
			      C ;
			      C ;;KB_FLAG    equ 17h ; byte
			      C ;;;KB_FLAGS  equ 17h ; word ; initial value = 0
			      C ;;BUFF_HEAD  equ 1Ah ; word ; initial value = offset KB_BUFF
			      C ;;BUFF_TAIL  equ 1Ch ; word ; initial value = offset KB_BUFF	 
			      C ;;BUFF_START equ 80h ; word ; initial value = offset KB_BUFF
			      C ;;BUFF_END   equ 82h ; word ; initial value = offset KB_BUFF + 32
			      C ;;;KB_BUFF   equ 1Eh ; 32 bytes ; Keyboard buffer (circular queue buffer)
			      C 
			      C ; 03/03/2014
 = 0040			      C BIOS_DSEGM      equ     40h
 = 0072			      C RESET_FLAG	equ 	72h	; WORD=1234H IF KEYBOARD RESET UNDERWAY 
			      C 				; (40h:72h)
			      C ;----------------------------------------
			      C ;	VIDEO DISPLAY DATA AREA		;
			      C ;----------------------------------------
 = 0049			      C CRT_MODE	equ	49h	; CURRENT DISPLAY MODE (TYPE)
 = 0065			      C CRT_MODE_SET	equ	65h	; CURRENT SETTING OF THE 3X8 REGISTER
			      C 
			      C ;--------- 8042 COMMANDS -------------------------------------------------------
 = 00AE			      C ENA_KBD		equ	0AEh	; ENABLE KEYBOARD COMMAND
 = 00AD			      C DIS_KBD		equ	0ADh	; DISABLE KEYBOARD COMMAND
			      C ;--------- 8042 KEYBOARD INTERFACE AND DIAGNOSTIC CONTROL REGISTERS ------------
 = 0064			      C STATUS_PORT	equ	064h	; 8042 STATUS PORT
 = 0002			      C INPT_BUF_FULL	equ	00000010b ; 1 = +INPUT BUFFER FULL
 = 0060			      C PORT_A		equ	060h	; 8042 KEYBOARD SCAN CODE/CONTROL PORT
			      C ;---------- 8042 KEYBOARD RESPONSE ---------------------------------------------
 = 00FA			      C KB_ACK		equ	0FAh	; ACKNOWLEDGE PROM TRANSMISSION
 = 00FE			      C KB_RESEND	equ	0FEh	; RESEND REQUEST
 = 00FF			      C KB_OVER_RUN	equ	0FFh	; OVER RUN SCAN CODE
			      C ;---------- KEYBOARD/LED COMMANDS ----------------------------------------------
 = 00F4			      C KB_ENABLE	equ	0F4h		; KEYBOARD ENABLE
 = 00ED			      C LED_CMD		EQU	0EDH		; LED WRITE COMMAND
			      C 
			      C ;---------- KEYBOARD SCAN CODES ------------------------------------------------
 = 00AB			      C ID_1		equ	0ABh		; 1ST ID CHARACTER FOR KBX
 = 0041			      C ID_2		equ	041h		; 2ND ID CHARACTER FOR KBX
 = 0038			      C ALT_KEY		equ	56		; SCAN CODE FOR	 ALTERNATE SHIFT KEY
 = 001D			      C CTL_KEY		equ	29		; SCAN CODE FOR	 CONTROL KEY
 = 003A			      C CAPS_KEY	equ	58		; SCAN CODE FOR	 SHIFT LOCK KEY
 = 0053			      C DEL_KEY		equ	83		; SCAN CODE FOR	 DELETE KEY
 = 0052			      C INS_KEY		equ	82		; SCAN CODE FOR	 INSERT KEY
 = 002A			      C LEFT_KEY	equ	42		; SCAN CODE FOR	 LEFT SHIFT
 = 0045			      C NUM_KEY		equ	69		; SCAN CODE FOR	 NUMBER LOCK KEY
 = 0036			      C RIGHT_KEY	equ	54		; SCAN CODE FOR	 RIGHT SHIFT
 = 0046			      C SCROLL_KEY	equ	70		; SCAN CODE FOR	 SCROLL LOCK KEY
 = 0054			      C SYS_KEY		equ	84		; SCAN CODE FOR	 SYSTEM KEY
			      C ;---------- FLAG EQUATES WITHIN @KB_FLAG----------------------------------------
 = 0001			      C RIGHT_SHIFT	equ	00000001b	; RIGHT SHIFT KEY DEPRESSED
 = 0002			      C LEFT_SHIFT	equ	00000010b	; LEFT SHIFT KEY DEPRESSED
 = 0004			      C CTL_SHIFT	equ	00000100b	; CONTROL SHIFT KEY DEPRESSED
 = 0008			      C ALT_SHIFT	equ	00001000b	; ALTERNATE SHIFT KEY DEPRESSED
 = 0010			      C SCROLL_STATE	equ	00010000b	; SCROLL LOCK STATE HAS BEEN TOGGLED
 = 0020			      C NUM_STATE	equ	00100000b	; NUM LOCK STATE HAS BEEN TOGGLED
 = 0040			      C CAPS_STATE	equ	01000000b	; CAPS LOCK STATE HAS BEEN TOGGLED
 = 0080			      C INS_STATE	equ	10000000b	; INSERT STATE IS ACTIVE
			      C 
			      C ;---------- FLAG EQUATES WITHIN	@KB_FLAG_1 -------------------------------------
 = 0004			      C SYS_SHIFT	equ	00000100b	; SYSTEM KEY DEPRESSED AND HELD
 = 0008			      C HOLD_STATE	equ	00001000b	; SUSPEND KEY HAS BEEN TOGGLED
 = 0010			      C SCROLL_SHIFT	equ	00010000b	; SCROLL LOCK KEY IS DEPRESSED
 = 0020			      C NUM_SHIFT	equ	00100000b	; NUM LOCK KEY IS DEPRESSED
 = 0040			      C CAPS_SHIFT	equ	01000000b	; CAPS LOCK KEY IS DEPRE55ED
 = 0080			      C INS_SHIFT	equ	10000000b	; INSERT KEY IS DEPRESSED
			      C 
			      C ;---------- FLAGS EQUATES WITHIN @KB_FLAG_2 ------------------------------------
 = 0007			      C KB_LEDS		equ	00000111b	; KEYBOARD LED STATE BITS
			      C ;		equ	00001000b	; RESERVED (MUST BE ZERO)
 = 0010			      C KB_FA		equ	00010000b	; ACKNOWLEDGMENT RECEIVED
 = 0020			      C KB_FE		equ	00100000b	; RESEND RECEIVED FLAG
 = 0040			      C KB_PR_LED	equ	01000000b	; MODE INDICATOR UPDATE
 = 0080			      C KB_ERR		equ	10000000b	; REYBOARD TRANSMIT ERROR FLAG
			      C 
			      C ;---------- FLAGS EQUATES WITHIN @KB_FLAG_3 ------------------------------------
 = 0001			      C KBX		equ	00000001b	; KBX INSTALLED
 = 0002			      C LC_HC		equ	00000010b	; LAST SCAN CODED WAS A HIDDEN CODE
 = 0004			      C GRAPH_ON	equ	00000100b	; ALL GRAPHICS KEY DOWN (W.T. ONLY)
			      C ;		equ	00011000b	; RESERVED (MUST BE ZERO)
 = 0020			      C SET_NUM_LK	equ	00100000b	; FORCE NUM LOCK IF READ ID AND KBX
 = 0040			      C LC_AB		equ	01000000b	; LAST CHARACTER WAS FIRST ID CHARACTER
 = 0080			      C RD_ID		equ	10000000b	; DOING A READ ID (MUST BE BIT0)
			      C 
			      C ;----- THIS CODE CONTAINS THE KBX SUPPORT FOR INT 09H EQUATES ------------------
 = 00D9			      C F11_M		equ	217		; FUNC 11 MAKE
 = 00D7			      C F11_B		equ	215		; FUNC 11 BREAK
 = 00DA			      C F12_M		equ	218		; FUNC 12 MAKE
 = 00D8			      C F12_B		equ	216		; FUNC 12 BREAK
 = 0056			      C K102_M		equ	86		; KEY 102 MAKE
 = 00D6			      C K102_B		equ	214		; KEY 102 BREAK
			      C ;
 = 0052			      C INS_M		equ	82		; INSERT KEY MAKE
 = 0053			      C DEL_M		equ	83		; DELETE KEY MAKE
 = 004B			      C LEFT_M		equ	75		; CURSOR LEFT MAKE
 = 004D			      C RIGHT_M		equ	77		; CURSOR RIGHT MARE
 = 0048			      C UP_M 		equ	72		; CURSOR UP MAKE
 = 0050			      C DN_M		equ	80		; CURSOR DOWN MAKE
 = 0049			      C PGUP_M		equ	73		; PG UP MAKE
 = 0051			      C PGDN_M		equ	81		; PG DN MAKE
 = 0047			      C HOME_M		equ	71		; HOME MAKE
 = 004F			      C END_M		equ	79		; END MAKE
			      C ;
 = 0085			      C FUNC11		equ	133		; FUNCTION 11 KEY
 = 00E0			      C HC		equ	224		; HIDDEN CODE
			      C 
			      C ;----------- INTERRUPT EQUATES -------------------------------------------------
 = 0020			      C EOI		equ	020h		; END OF INTERRUPT COMMAND TO 8259
 = 0020			      C INTA00		equ	020h		; 8259 PORT
			      C 
 1D86			      C int_16h:
			      C 	; 29/01/2022
			      C 	; Ref: IBM PC/AT BIOS v2 (KYBD.ASM, 10/06/1985)
			      C 	; 28/08/2014
			      C 	; 30/06/2014
			      C 	; 03/03/2014
			      C 	; 28/02/2014
			      C 	; Derived from "KEYBOARD_IO_1" procedure of IBM "pc-at" 
			      C 	; rombios source code (10/06/1985)
			      C 	;	 'keybd.asm', INT 16H, KEYBOARD_IO
			      C 	;
			      C 	; 06/10/85  KEYBOARD BIOS
			      C 	;
			      C 	;--- INT 16 H --------------------------------------------------------------------
			      C 	; KEYBOARD I/O									:
			      C 	;	THESE ROUTINES PROVIDE READ KEYBOARD SUPPORT				:
			      C 	; INPUT										:
			      C 	;	(AH)= 00H  READ THE NEXT ASCII CHARACTER ENTERED FROM THE KEYBOARD,	:
			      C 	;			RETURN THE RESULT IN (AL), SCAN CODE IN (AH).		:
			      C 	;										:
			      C 	;	(AH)= 01H	SET THE ZERO FLAG TO INDICATE IF AN ASCII CHARACTER IS	:
			      C 	;			AVAILABLE TO BE READ FROM THE KEYBOARD BUFFER.		:
			      C 	;			(ZF)= 1 -- NO CODE AVAILABLE				:
			      C 	;			(ZF)= 0 -- CODE IS AVAILABLE (AX)= CHARACTER		:
			      C 	;			IF (ZF)= 0, THE NEXT CHARACTER IN THE BUFFER TO BE READ IS :
			      C 	;			IN (AX), AND THE ENTRY REMAINS IN THE BUFFER.		:
			      C 	;	(AH)= 02H	RETURN THE CURRENT SHIFT STATUS IN (AL) REGISTER	:
			      C 	;			THE BIT SETTINGS FOR THIS CODE ARE INDICATED IN THE	:
			      C 	;			EQUATES FOR @KB_FLAG					:
			      C 	; OUTPUT									:
			      C 	;	AS NOTED ABOVE, ONLY (AX) AND FLAGS CHANGED				:
			      C 	;	ALL REGISTERS RETAINED							:
			      C 	;---------------------------------------------------------------------------------
			      C 	
 1D86  FB		      C 	sti
 1D87  1E		      C 	push	ds			; SAVE CURRENT DS
 1D88  53		      C 	push	bx			; SAVE BX TEMPORARILY
 1D89  8C CB		      C         mov     bx, cs 
 1D8B  8E DB		      C 	mov	ds, bx			; PUT SEGMENT VALUE OF DATA AREA INTO DS
 1D8D  0A E4		      C 	or	ah, ah			; CHECK FOR (AH)= 00H
 1D8F  74 0B		      C 	jz	short k1b		; ASCII_READ
			      C 	;
 1D91  FE CC		      C 	dec	ah
 1D93  74 40		      C 	jz	short k2		; CHECK FOR (AH)= 01H
			      C 					; ASCII_STATUS
 1D95  FE CC		      C 	dec	ah			; CHECK FOR (AH)= 02H
 1D97  74 62		      C 	jz	short k3		; SHIFT STATUS
 1D99  5B		      C 	pop	bx			; RECOVER REGISTER
 1D9A  1F		      C 	pop	ds			; RECOVER SEGMENT
 1D9B  CF		      C 	iret				; INVALID COMMAND EXIT
			      C 
			      C 	;-----	READ THE KEY TO FIGURE OUT WHAT TO DO
 1D9C			      C k1b:
 1D9C  8B 1E 2742 R	      C         mov     bx, word ptr [BUFFER_HEAD] ; GET POINTER TO HEAD OF BUFFER
 1DA0  3B 1E 2744 R	      C         cmp     bx, word ptr [BUFFER_TAIL] ; TEST END OF BUFFER
			      C 	;; 28/08/2014
 1DA4  75 02		      C 	jne	short k1c		; IF ANYTHING IN BUFFER SKIP INTERRUPT
			      C 	; 29/01/2022
			      C 	;jne	short k1d	
			      C 	;
			      C 	;;mov	ax, 09002h		; MOVE IN WAIT CODE A TYPE
			      C 	;;int	15h			; PERFORM OTHER FUNCTION
 1DA6			      C k1:					; ASCII READ
 1DA6  FB		      C 	sti				; INTERRUPTS BACK ON DURING LOOP
 1DA7  90		      C 	nop				; ALLOW AN INTERRUPT TO OCCUR
 1DA8  FA		      C k1c:	cli				; INTERRUPTS BACK OFF
 1DA9  8B 1E 2742 R	      C         mov     bx, word ptr [BUFFER_HEAD] ; GET POINTER TO HEAD OF BUFFER
 1DAD  3B 1E 2744 R	      C         cmp     bx, word ptr [BUFFER_TAIL] ; TEST END OF BUFFER
 1DB1			      C k1d:	
			      C 	; 30/06/2014 (original code again)
 1DB1  53		      C 	push	bx			; SAVE ADDRESS		
 1DB2  9C		      C 	pushf				; SAVE FLAGS
 1DB3  E8 0509		      C 	call	make_led		; GO GET MODE INDICATOR DATA BYTE
 1DB6  8A 1E 273B R	      C 	mov	bl, byte ptr [KB_FLAG_2] ; GET PREVIOUS BITS
 1DBA  32 D8		      C 	xor	bl, al			; SEE IF ANY DIFFERENT
 1DBC  80 E3 07		      C 	and	bl, KB_LEDS		; ISOLATE INDICATOR BITS
 1DBF  74 04		      C 	jz	short k1a		; IF NO CHANGE BYPASS UPDATE
 1DC1  E8 04BD		      C 	call	snd_led1
 1DC4  FA		      C 	cli
 1DC5			      C k1a:
 1DC5  9D		      C 	popf				; RESTORE FLAGS
 1DC6  5B		      C 	pop	bx			; RESTORE ADDRESS
 1DC7  74 DD		      C 	jz	short k1		; LOOP UNTIL SOMETHING IN BUFFER
			      C 	;
 1DC9  8B 07		      C 	mov	ax, word ptr [BX] 	; GET SCAN CODE AND ASCII CODE
 1DCB  E8 0033		      C 	call	k4			; MOVE POINTER TO NEXT POSITION
			      C 	; 03/03/2014
 1DCE  89 1E 2742 R	      C         mov     word ptr [BUFFER_HEAD], bx ; STORE VALUE IN VARIABLE
 1DD2  5B		      C 	pop	bx			; RECOVER REGISTER
 1DD3  1F		      C 	pop	ds			; RECOVER SEGMENT
 1DD4  CF		      C 	iret				; RETURN TO CALLER
			      C 
			      C 	;-----	ASCII STATUS
 1DD5			      C k2:
 1DD5  FA		      C 	cli				; INTERRUPTS OFF
 1DD6  8B 1E 2742 R	      C         mov     bx, word ptr [BUFFER_HEAD] ; GET HEAD POINTER
 1DDA  3B 1E 2744 R	      C         cmp     bx, word ptr [BUFFER_TAIL] ; IF EQUAL (Z=1) THEN NOTHING THERE
 1DDE  8B 07		      C 	mov	ax, word ptr [BX]
			      C 	; 30/06/2014 (original code again)
 1DE0  9C		      C 	pushf				; SAVE FLAGS
 1DE1  50		      C 	push	ax			; SAVE CODE
 1DE2  E8 04DA		      C 	call	make_led		; GO GET MODE INDICATOR DATA BYTE
 1DE5  8A 1E 273B R	      C 	mov	bl, byte ptr [KB_FLAG_2] ; GET PREVIOUS BITS
 1DE9  32 D8		      C 	xor	bl, al			; SEE IF ANY DIFFERENT
 1DEB  80 E3 07		      C 	and	bl, KB_LEDS		; ISOLATE INDICATOR BITS
 1DEE  74 03		      C 	jz	short sk2		; IF NO CHANGE BYPASS UPDATE
			      C 	;
 1DF0  E8 048E		      C 	call	snd_led1
 1DF3			      C sk2:
 1DF3  58		      C 	pop	ax			; RESTORE CODE
 1DF4  9D		      C 	popf				; RESTORE FLAGS
 1DF5  FB		      C 	sti				; INTERRUPTS BACK ON
 1DF6  5B		      C 	pop	bx			; RECOVER REGISTER
 1DF7  1F		      C         pop     ds                      ; RECOVER SEGMENT
 1DF8  CA 0002		      C 	retf	2			; THROW AWAY FLAGS
			      C 
			      C 	;-----	SHIFT STATUS
 1DFB			      C k3:
 1DFB  A0 2739 R	      C 	mov	al, byte ptr [KB_FLAG]	; GET THE SHIFT STATUS FLAGS
 1DFE  5B		      C 	pop	bx			; RECOVER REGISTERS
 1DFF  1F		      C 	pop	ds
 1E00  CF		      C 	iret			; RETURN TO CALLER
			      C 
			      C 	; 03/03/2014
			      C 	;-----	INCREMENT A BUFFER POINTER
 1E01  43		      C k4:	inc	bx
 1E02  43		      C 	inc	bx			; MOVE TO NEXT WORD IN LIST
 1E03  3B 1E 2740 R	      C         cmp     bx, word ptr [BUFFER_END] ; AT END OF BUFFER?
			      C 	;jne	short k5		; NO, CONTINUE
 1E07  72 04		      C 	jb	short k5
 1E09  8B 1E 273E R	      C         mov     bx, word ptr [BUFFER_START] ; YES, RESET TO BUFFER BEGINNING
 1E0D			      C k5:
 1E0D  C3		      C 	retn
			      C 
 1E0E			      C int_09h:
			      C 	; 29/01/2022
			      C 	; Ref: IBM PC/AT BIOS v2 (KYBD.ASM, 10/06/1985)
			      C 	; 27/01/2022
			      C 	; 07/03/2014
			      C 	; 03/03/2014
			      C 	; Derived from "KEYBOARD_INT_1" procedure of IBM "pc-at" 
			      C 	; rombios source code (10/06/1985)
			      C 	;	 'keybd.asm', INT 16H, KEYBOARD_IO
			      C 	;
			      C 	; 06/10/85  KEYBOARD BIOS
			      C 	;
			      C 	;--- HARDWARE INT 09 H - ( IRQ LEVEL 1 )------------------------------------------
			      C 	;
			      C 	;	KEYBOARD INTERRUPT ROUTINE
			      C 	;
			      C 	;---------------------------------------------------------------------------------
			      C 
 1E0E  FB		      C 	sti				; ENABLE INTERRUPTS
 1E0F  55		      C 	push	bp
 1E10  50		      C 	push	ax
 1E11  53		      C 	push	bx
 1E12  51		      C 	push	cx
 1E13  52		      C 	push	dx
 1E14  56		      C 	push	si
 1E15  57		      C 	push	di
 1E16  1E		      C 	push	ds
 1E17  06		      C 	push	es
 1E18  FC		      C 	cld				; FORWARD DIRECTION
			      C 	;call 	dds			; SET UP ADDRESSING
			      C 	;mov	ax, offset DDSData	; 
 1E19  8C C8		      C 	mov	ax, cs
 1E1B  8E D8		      C 	mov	ds, ax
 1E1D  8E C0		      C 	mov	es, ax
			      C 	;
			      C 	;-----	WAIT FOR KEYBOARD DISABLE COMMAND TO BE ACCEPTED
 1E1F  B0 AD		      C 	mov	al, DIS_KBD		; DISABLE THE KEYBOARD COMMAND
 1E21  E8 04A9		      C 	call	ship_it			; EXECUTE DISABLE
 1E24  FA		      C 	cli				; DISABLE INTERRUPTS
			      C 	;sub	cx, cx			; SET MAXIMUM TIMEOUT
 1E25  33 C9		      C 	xor	cx, cx
 1E27			      C kb_int_01:
 1E27  E4 64		      C 	in	al, STATUS_PORT		; READ ADAPTER STATUS
 1E29  A8 02		      C 	test	al, INPT_BUF_FULL	; CHECK INPUT BUFFER FULL STATUS BIT
 1E2B  E0 FA		      C 	loopnz	kb_int_01		; WAIT FOR COMMAND TO BE ACCEPTED
			      C 	;
			      C 	;-----	READ CHARACTER FROM KEYBOARD INTERFACE
 1E2D  E4 60		      C 	in	al, PORT_A		; READ IN THE CHARACTER
			      C 	;
			      C 	;----- SYSTEM HOOK INT 15H - FUNCTION 4FH (ON HARDWARE INTERRUPT LEVEL 9HI
			      C 	;mov	ah, 04Fh		; SYSTEM INTERCEPT - KEY CODE FUNCTION
			      C 	;stc				; SET CY= 1 (IN CASE OF IRET)
			      C 	;int	15h			; CASSETTE CALL (AL)= KEY SCAN CODE
			      C 					; RETURNS CY= 1 FOR INVALID FUNCTION
			      C 	;jc	short kb_int_02		; CONTINUE IF CARRY FLAG SET ((AL)=CODE)
			      C 	;
			      C 	;jmp	short k26		; EXIT IF SYSTEM HANDLED SCAN CODE
			      C 					; EXIT HANDLES HARDWARE EOI AND ENABLE
			      C 	;jnc	k26
			      C 
			      C 	;
			      C 	;-----	CHECK FOR A RESEND COMMAND TO KEYBOARD
 1E2F			      C kb_int_02:				; 	  (AL)= SCAN CODE
 1E2F  FB		      C 	sti				; ENABLE INTERRUPTS AGAIN
 1E30  3C FE		      C 	cmp	al, KB_RESEND		; IS THE INPUT A RESEND
 1E32  74 0D		      C         je      short kb_int_03          ; GO IF RESEND
			      C 	;
			      C 	;-----	CHECK FOR RESPONSE TO A COMMAND TO KEYBOARD
 1E34  3C FA		      C 	cmp	al, KB_ACK		; IS THE INPUT AN ACKNOWLEDGE
 1E36  75 12		      C         jne     short kb_int_04         ; GO IF NOT
			      C 	;
			      C 	;-----	A COMMAND TO THE KEYBOARD WAS ISSUED
 1E38  FA		      C 	cli				; DISABLE INTERRUPTS
 1E39  80 0E 273B R 10	      C 	or	byte ptr [KB_FLAG_2], KB_FA ; INDICATE ACK RECEIVED
 1E3E  E9 020D		      C         jmp     k26                      ; RETURN IF NOT (ACK RETURNED FOR DATA)
			      C 	;
			      C 	;-----	RESEND THE LAST BYTE
 1E41			      C kb_int_03:
 1E41  FA		      C 	cli				; DISABLE INTERRUPTS
 1E42  80 0E 273B R 20	      C 	or	byte ptr [KB_FLAG_2], KB_FE ; INDICATE RESEND RECEIVED
 1E47  E9 0204		      C         jmp     k26                     ; RETURN IF NOT ACK RETURNED FOR DATA)
			      C 	;
 1E4A			      C kb_int_04:
			      C 	;-----	UPDATE MODE INDICATORS IF CHANGE IN STATE
 1E4A  50		      C 	push 	ax			; SAVE DATA IN
 1E4B  E8 0471		      C 	call	make_led		; GO GET MODE INDICATOR DATA BYTE
 1E4E  8A 1E 273B R	      C 	mov	bl, byte ptr [KB_FLAG_2] ; GET PREVIOUS BITS
 1E52  32 D8		      C 	xor	bl, al			; SEE IF ANY DIFFERENT
 1E54  80 E3 07		      C 	and	bl, KB_LEDS		; ISOLATE INDICATOR BITS
 1E57  74 03		      C 	jz	short up0		; IF NO CHANGE BYPASS UPDATE
 1E59  E8 0412		      C 	call	snd_led			; GO TURN ON MODE INDICATORS
 1E5C  58		      C up0:	pop	ax			; RESTORE DATA IN
 1E5D  8A E0		      C 	mov	ah, al			; SAVE SCAN CODE IN AH ALSO
			      C 	;
			      C 	;-----	TEST FOR OVERRUN SCAN CODE FROM KEYBOARD
 1E5F  3C FF		      C 	cmp	al, KB_OVER_RUN		; IS THIS AN OVERRUN CHAR
			      C 	; 27/01/2022
 1E61  75 03		      C 	jne	short k16		; NO, TEST FOR SHIFT KEY
 1E63  E9 03BE		      C 	jmp	k62			; BUFFER_FULL_BEEP
			      C         ;je	k62
 1E66			      C k16:
 1E66  24 7F		      C 	and	al, 07Fh		; REMOVE BREAK BIT
			      C 	;push	cs
			      C 	;pop	es			; ESTABLISH ADDRESS OF TABLES
			      C 	;
 1E68  F6 06 273C R C0	      C 	test 	byte ptr [KB_FLAG_3], RD_ID+LC_AB ; ARE WE DOING A READ ID?
 1E6D  74 35		      C 	jz	short not_id		; CONTINUE IF NOT
 1E6F  79 12		      C 	jns	short tst_id_2		; IS THE RD_ID FLAG ON?
 1E71  80 FC AB		      C 	cmp	ah, ID_1		; IS THIS THE 1ST ID CHARACTER?
 1E74  75 05		      C 	jne	short rst_rd_id
 1E76  80 0E 273C R 40	      C 	or	byte ptr [KB_FLAG_3], LC_AB ; INDICATE 1ST ID WAS OK
 1E7B			      C rst_rd_id:
 1E7B  80 26 273C R 7F	      C 	and	byte ptr [KB_FLAG_3], NOT RD_ID	; RESET THE READ ID FLAG
			      C 	;jmp	short do_ext
 1E80			      C @@:
 1E80  E9 01CB		      C         jmp     k26
 1E83			      C tst_id_2:
 1E83  80 26 273C R BF	      C 	and	byte ptr [KB_FLAG_3], NOT LC_AB	; RESET FLAG
 1E88  80 FC 41		      C 	cmp	ah, ID_2		; IS THIS THE 2ND ID CHARACTER?
			      C 	;;jne	short do_ext		; LEAVE IF NOT
			      C         ;jne	k26
			      C 	; 27/01/2022
			      C 	;je	short @f
			      C 	;jmp	k26
 1E8B  75 F3		      C 	jne	short @b
			      C ;@@:
			      C 	;-----	A READ ID SAID THAT IT WAS KBX
 1E8D  80 0E 273C R 01	      C 	or	byte ptr [KB_FLAG_3], KBX ; INDICATE KBX WAS FOUND
 1E92  F6 06 273C R 20	      C 	test	byte ptr [KB_FLAG_3], SET_NUM_LK ; SHOULD WE SET NUM LOCK?
			      C 	;;jz	short do_ext		; EXIT IF NOT
			      C         ;jz	k26
			      C 	; 27/01/2022
 1E97  74 08		      C 	jz	short @f ; jmp k26
 1E99  80 0E 2739 R 20	      C 	or	byte ptr [KB_FLAG], NUM_STATE ; FORCE NUM LOCK ON
 1E9E  E8 03CD		      C 	call	snd_led			; GO SET THE NUM LOCK INDICATOR
			      C 	;jmp	short exit	
 1EA1			      C @@:
 1EA1  E9 01AA		      C 	jmp     k26
			      C 	;
 1EA4			      C not_id:
 1EA4  F6 06 273C R 02	      C 	test	byte ptr [KB_FLAG_3], LC_HC ; WAS THE LAST CHARACTER A HIDDEN CODE
 1EA9  74 60		      C 	jz	short not_lc_hc		; JUMP IF NOT
			      C 	;
			      C 	;-----	THE LAST CHARACTER WAS A HIDDEN CODE
 1EAB  80 26 273C R FD	      C 	and	byte ptr [KB_FLAG_3], NOT LC_HC	; RESET LAST CHAR HIDDEN CODE FLAG
 1EB0  3C 52		      C 	cmp	al, INS_M		; WAS IT THE INSERT KEY?
 1EB2  74 05		      C 	je	short not_i
 1EB4  F6 C4 80		      C 	test	ah, 80h			; IS THIS A BREAK CODE
			      C 	;;jnz	short exit		; IGNORE BREAK ON REST OF THESE KEYS
			      C         ;jnz	k26
			      C 	; 27/01/2022
 1EB7  75 E8		      C 	jnz	short @b ; jmp k26
 1EB9			      C not_i:
 1EB9  BF 23E0 R	      C 	mov	di, offset K_TAB1	; TEST FOR ONE OF THE KEYPAD CURSOR FUNC
 1EBC  B9 000A		      C 	mov	cx, L_TAB1
 1EBF  F2/ AE		      C 	repne	scasb			; SCAN FOR THE KEY
 1EC1  75 55		      C 	jne	short not_cur		; GO ON IF NOT FOUND
 1EC3  F6 06 273A R 08	      C 	test 	byte ptr [KB_FLAG_1], HOLD_STATE ; ARE WE IN HOLD STATE?
 1EC8  74 08		      C 	jz	short n_hld
 1ECA  80 26 273A R F7	      C 	and	byte ptr [KB_FLAG_1], NOT HOLD_STATE ; EXIT HOLD STATE
			      C ;do_ext:
			      C ;	jmp	short exit		; IGNORE THIS KEY
 1ECF			      C @@: 
 1ECF  E9 017C		      C 	jmp	k26
 1ED2			      C n_hld:
 1ED2  F6 06 2739 R 08	      C 	test 	byte ptr [KB_FLAG], ALT_SHIFT ; IS ALT DOWN?
 1ED7  74 0E		      C 	jz	short not_alt
 1ED9  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; HOW ABOUT CTRL?
			      C 	;;jz	short exit		; IGNORE ALL IF ONLY ALT DOWN
			      C 	;jz	k26
			      C 	; 27/01/2022
 1EDE  74 EF		      C 	jz	short @b ; jmp k26
 1EE0  3C 53		      C 	cmp	al, DEL_M		; WAS IT THE DELETE KEY'
			      C 	;;jne	short exit		; IGNORE IF NOT
			      C 	;jne	k26
			      C 	; 27/01/2022
 1EE2  75 EB		      C 	jne	short @b ; jmp k26
 1EE4  E9 0183		      C         jmp     k29                     ; GO DO THE CTL, ALT, DEL RESET
			      C 	;
 1EE7			      C not_alt:
 1EE7  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; IS CTL DOWN?
 1EEC  75 15		      C 	jnz	short ctl_on		; SPECIAL CASE IF SO
 1EEE  3C 52		      C 	cmp	al, INS_M		; IS THIS THE INSERT KEY?
			      C 	;;jne	short n_ins
			      C         ;jne	k49
			      C 	; 27/01/2022
 1EF0  74 03		      C 	je	short @f
 1EF2  E9 029F		      C 	jmp	k49
 1EF5			      C @@:
			      C 	;-----	SPECIAL HANDLING FOR INSERT KEY
 1EF5  8A C4		      C 	mov	al, ah			; RECOVER SCAN CODE
 1EF7  B4 80		      C 	mov	ah, INS_SHIFT		; AH = MASK FOR INSERT
 1EF9  A8 80		      C 	test	al, 80h			; WAS THIS A BREAK CODE?
			      C 	;;jnz	short b_c
			      C         ;jnz	k24
			      C 	; 27/01/2022
 1EFB  74 03		      C 	jz	short @f
 1EFD  E9 0132		      C 	jmp	k24
 1F00			      C @@:
 1F00  E9 00EE		      C         jmp     k22                     ; GO HANDLE INSERT SHIFT
			      C ;b_c:
			      C ;	jmp	short k24		; HANDLE BREAK
			      C ;n_ins:
			      C ;	jmp	short k49		; HANDLE & IGNORE NUMLOCK
 1F03			      C ctl_on:
 1F03  80 F9 05		      C         cmp     cl, 5                   ; WAS IT INS, DEL, UP OR DOWN?
			      C 	;;ja	short exit		; IGNORE IF DO
			      C         ;ja	k26
			      C 	; 27/01/2022
 1F06  77 0D		      C 	ja	short @f
 1F08  E9 023B		      C         jmp     k42                     ; GO HANDLE CTRL CASE
			      C 	;
 1F0B			      C not_lc_hc:				; LAST CHARACTER WAS NOT A HIDDEN CODE
 1F0B  80 FC E0		      C 	cmp	ah, HC			; IS THIS CHARACTER A HIDDEN CODE?
 1F0E  75 08		      C 	jne	short not_cur
 1F10  80 0E 273C R 03	      C 	or	byte ptr [KB_FLAG_3], LC_HC+KBX	; SET LAST CHAR WAS A HIDDEN CODE & KOX
			      C ;exit:
 1F15			      C @@:
 1F15  E9 0136		      C 	jmp     k26                     ; THROW AWAY THIS CODE
			      C 	;
 1F18			      C not_cur:
 1F18  80 FC D9		      C 	cmp	ah, F11_M		; WAS IT F11?
 1F1B  75 0E		      C 	jne	short t_f12		; HANDLE IF SO
 1F1D  B1 85		      C 	mov	cl, FUNC11		; SET BASE FUNCTION 11
 1F1F  80 FC D7		      C 	cmp	ah, F11_B		; IS THIS A BREAK CODE
			      C 	;;je	short exit		; IGNORE SPEAK CODES
			      C 	;je	k26
			      C 	; 27/01/2022
 1F22  74 F1		      C 	je	short @b  ; jmp k26
 1F24  80 FC D8		      C 	cmp	ah, F12_B		; IS THIS A BREAK CODE
			      C 	;;je	short exit		; IGNORE BREAK CODES
			      C 	;je	k26
			      C 	; 27/01/2022
 1F27  74 EC		      C 	je	short @b  ; jmp k26
 1F29  EB 07		      C 	jmp	short do_fn
 1F2B			      C t_f12:
 1F2B  80 FC DA		      C 	cmp	ah, F12_M		; WAS IT F12?
 1F2E  75 39		      C 	jne	short t_sys_key		; GO TEST FOR SYSTEM KEY
 1F30  B1 86		      C 	mov	cl, FUNC11+1		; SET BASE FUNCTION 12
 1F32			      C do_fn:
 1F32  F6 06 273A R 08	      C 	test	byte ptr [KB_FLAG_1], HOLD_STATE ; ARE WE IN HOLD STATE?
 1F37  74 07		      C 	jz	short n_hld1
 1F39  80 26 273A R F7	      C 	and	byte ptr [KB_FLAG_1], NOT HOLD_STATE ; EXIT HOLD STATE
			      C 	;;jmp	short exit		; IGNORE THIS KEY
			      C 	;je	k26
			      C 	; 27/01/2022
 1F3E  74 D5		      C 	je	short @b  ; jmp k26
 1F40			      C n_hld1:
 1F40  8A E1		      C 	mov	ah, cl
			      C 	;
 1F42  F6 06 2739 R 08	      C 	test	byte ptr [KB_FLAG], ALT_SHIFT ; ARE WE IN ALT
 1F47  74 05		      C 	jz	short t_ctl
 1F49  80 C4 06		      C         add     ah, 6			; CNVT TO ALT FN 11-12
 1F4C  EB 16		      C 	jmp	short set_fn
 1F4E			      C t_ctl:
 1F4E  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; ARE WE IN CTRL
 1F53  74 05		      C 	jz	short t_shf
 1F55  80 C4 04		      C 	add	ah, 4			; CNVT TO CTRL FN 11-12
 1F58  EB 0A		      C 	jmp	short set_fn
 1F5A			      C t_shf:
 1F5A  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT ; IS EITHER SHIFT ON?
 1F5F  74 03		      C 	jz	short set_fn
 1F61  80 C4 02		      C 	add	ah, 2			; CNVT TO SHIFT FN 11-12
 1F64			      C set_fn:
 1F64  2A C0		      C 	sub	al, al			; FORCE PSEUDO SCAN CODE
 1F66  E9 0290		      C         jmp     k61                     ; PUT IT INTO BUFFER
			      C 	;
			      C 	;-----	TEST FOR SYSTEM KEY
 1F69			      C t_sys_key:
 1F69  3C 54		      C 	cmp	al, SYS_KEY		; IS IT THE SYSTEM KEY?
 1F6B  75 2E		      C 	jnz	short k16a		; CONTINUE IF NOT
			      C 	;
 1F6D  F6 C4 80		      C 	test	ah, 80h			; CHECK IF THIS A BREAK CODE
 1F70  75 18		      C 	jnz	short k16c		; DO NOT TOUCH SYSTEM INDICATOR IF TRUE
			      C 	;
 1F72  F6 06 273A R 04	      C 	test	byte ptr [KB_FLAG_1], SYS_SHIFT	; SEE IF IN SYSTEM KEY HELD DOWN 
			      C 	;;jnz	short k16b		; IF YES, DO NOT PROCESS SYSTEM INDICATOR
			      C         ;jnz	k26
			      C 	; 27/01/2022
 1F77  75 9C		      C 	jnz	short @b  ; jmp k26
			      C 	;
 1F79  80 0E 273A R 04	      C 	or	byte ptr [KB_FLAG_1], SYS_SHIFT	; INDICATE SYSTEM KEY DEPRESSED
 1F7E  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT COMMAND
 1F80  E6 20		      C 	out	INTA00, al		; SEND COMMAND TO INTERRUPT CONTROL PORT
			      C 					; INTERRUPT-RETURN-NO-EOI
 1F82  B0 AE		      C 	mov	al, ENA_KBD		; INSURE KEYBOARD 15 ENABLED
 1F84  E8 0346		      C 	call	ship_it			; EXECUTE ENABLE
			      C 	;mov	ax, 8500h		; FUNCTION VALUE FOR MAKE OF SYSTEM KEY
			      C 	;sti				; MAKE SURE INTERRUPTS ENABLED
			      C 	;int	15h			; USER INTERRUPT
 1F87  E9 00CE		      C         jmp     k27a                    ; END PROCESSING
			      C ;k16b:
			      C ;	jmp	short k26		; IGNORE SYSTEM KEY
			      C 
 1F8A			      C k16c:
 1F8A  80 26 273A R FB	      C 	and	byte ptr [KB_FLAG_1], NOT SYS_SHIFT ; TURN OFF SHIFT KEY HELD DOWN
 1F8F  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT COMMAND
 1F91  E6 20		      C 	out	INTA00, al		; SEND COMMAND TO INTERRUPT CONTROL PORT
			      C 					; INTERRUPT-RETURN-NO-EOI
 1F93  B0 AE		      C 	mov	al, ENA_KBD		; INSURE KEYBOARD IS ENABLED
 1F95  E8 0335		      C 	call	ship_it			; EXECUTE ENABLE
			      C 	;mov	ax, 08501h		; FUNCTION VALUE FOR BREAK OF SYSTEM KEY
			      C 	;sti				; MAKE SURE INTERRUPTS ENABLED
			      C 	;int	15h			; USER INTERRUPT
 1F98  E9 00BD		      C         jmp     k27a                    ; IGNORE SYSTEM KEY
 1F9B			      C k16a:
 1F9B  BF 22DC R	      C 	mov	di, offset K6		; SHIFT KEY TABLE
 1F9E  B9 0008		      C 	mov	cx, K6L			; LENGTH
 1FA1  F2/ AE		      C 	repne	scasb			; LOOK THROUGH THE TABLE FOR A MATCH
 1FA3  8A C4		      C 	mov	al, ah			; RECOVER SCAN CODE
			      C 	; 27 /01/2022
 1FA5  74 03		      C 	je	short k17		; JUMP IF MATCH FOUND
 1FA7  E9 0090		      C 	jmp	k25			; IF NO MATCH, THEN SHIFT NOT FOUND
			      C         ;jne	k25
			      C 	;
			      C 	;------	SHIFT KEY FOUND
 1FAA			      C k17:
 1FAA  81 EF 22DD R	      C 	sub	di, offset K6+1		; ADJUST PTR TO SCAN CODE MATCH
 1FAE  81 C7 22E4 R	      C         add	di, offset K7
 1FB2  8A 25		      C 	mov     ah, byte ptr [DI]       ; GET MASK INTO AH
 1FB4  A8 80		      C 	test	al, 80h			; TEST FOR BREAK KEY
			      C 	;jz	short k17c		; BREAK_SHIFT_FOUND
			      C 	;jmp	short k23		; CONTINUE
 1FB6  75 5B		      C 	jnz	short k23
			      C 	;
			      C 	;-----	DETERMINE SET OR TOGGLE
 1FB8			      C k17c:
 1FB8  80 FC 10		      C 	cmp	ah, SCROLL_SHIFT
 1FBB  73 07		      C 	jae	short k18		; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY
			      C 	;
			      C 	;-----	PLAIN SHIFT KEY, SET SHIFT ON
 1FBD  08 26 2739 R	      C 	or	byte ptr [KB_FLAG], ah	; TURN ON SHIFT BIT
 1FC1  E9 008A		      C         jmp     k26                     ; INTERRUPT_RETURN
			      C 	;
			      C 	;-----	TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT
 1FC4			      C k18:					; SHIFT-TOGGLE
 1FC4  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; CHECK CTL SHIFT STATE
 1FC9  75 6F		      C 	jnz	short k25		; JUMP IF CTL STATE
			      C 	;
 1FCB  3C 52		      C 	cmp	al, INS_KEY		; CHECK FOR INSERT KEY
 1FCD  75 22		      C 	jnz	short k22		; JUMP IF NOT INSERT KEY
 1FCF  F6 06 2739 R 08	      C 	test	byte ptr [KB_FLAG], ALT_SHIFT ; CHECK FOR ALTERNATE SHIFT
 1FD4  75 64		      C 	jnz	short k25		; JUMP IF ALTERNATE SHIFT
			      C 	;
 1FD6  F6 06 2739 R 20	      C 	test	byte ptr [KB_FLAG], NUM_STATE ; CHECK FOR BASE STATE
 1FDB  75 0D		      C 	jnz	short k21		; JUMP IF NUM LOCK IS ON
 1FDD  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT
 1FE2  74 0D		      C 	jz	short k22		; JUMP IF BASE STATE
			      C 	;
 1FE4			      C k20:					; NUMERIC ZERO, NOT INSERT KEY
 1FE4  B8 5230		      C 	mov	ax, 5230h		; PUT OUT AN ASCII ZERO
 1FE7  E9 01DF		      C         jmp     k57                     ; BUFFER FILL
 1FEA			      C k21:					; MIGHT BE NUMERIC
 1FEA  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT
 1FEF  74 F3		      C 	jz	short k20		; JUMP NUMERIC, NOT INSERT
			      C 	;
 1FF1			      C k22:					; SHIFT TOGGLE KEY HIT; PROCESS IT
 1FF1  84 26 273A R	      C 	test	ah, byte ptr [KB_FLAG_1] ; IS KEY ALREADY DEPRESSED
			      C 	;jz	short k22a0		; GO IF NOT
			      C 	;jmp	short k26		; JUMP IF KEY ALREADY DEPRESSED
			      C 	; 29/01/2022
 1FF5  75 57		      C 	jnz	short k26
 1FF7			      C k22a0:
 1FF7  08 26 273A R	      C         or      byte ptr [KB_FLAG_1], ah ; INDICATE THAT THE KEY IS DEPRESSED
 1FFB  30 26 2739 R	      C 	xor	byte ptr [KB_FLAG], ah	; TOGGLE THE SHIFT STATE
			      C 	;
			      C 	;-----	TOGGLE LED IF CAPS OR NUM KEY DEPRESSED
 1FFF  F6 C4 70		      C 	test	ah, CAPS_SHIFT+NUM_SHIFT+SCROLL_SHIFT ; SHIFT TOGGLE?
 2002  74 05		      C 	jz	short k22b		; GO IF NOT
			      C 	;
 2004  50		      C 	push	ax			; SAVE SCAN CODE AND SHIFT MASK
 2005  E8 0266		      C 	call	snd_led			; GO TURN MODE INDICATORS ON
 2008  58		      C 	pop	ax			; RESTORE SCAN CODE
 2009			      C k22b:
 2009  3C 52		      C 	cmp	al, INS_KEY		; TEST FOR 1ST MAKE OF INSERT KEY
 200B  75 41		      C 	jne	short k26		; JUMP IF NOT INSERT KEY
 200D  B8 5200		      C 	mov	ax, INS_KEY*100h	; SET SCAN CODE INTO AH, 0 INTO AL
 2010  E9 01B6		      C         jmp     k57                     ; PUT INTO OUTPUT BUFFER
			      C 	;
			      C 	;-----	BREAK SHIFT FOUND
 2013			      C k23:					; BREAK-SHIFT-FOUND
 2013  80 FC 10		      C 	cmp	ah, SCROLL_SHIFT	; IS THIS A TOGGLE KEY
 2016  73 1A		      C 	jae	short k24		; YES, HANDLE BREAK TOGGLE
 2018  F6 D4		      C 	not	ah			; INVERT MASK
 201A  20 26 2739 R	      C 	and	byte ptr [KB_FLAG], ah	; TURN OFF SHIFT BIT
 201E  3C B8		      C 	cmp	al, ALT_KEY+80h		; IS THIS ALTERNATE SHIFT RELEASE
 2020  75 2C		      C 	jne	short k26		; INTERRUPT_RETURN
			      C 	;
			      C 	;-----	ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER
 2022  A0 273D R	      C 	mov	al, byte ptr [ALT_INPUT]
 2025  B4 00		      C 	mov	ah, 0			; SCAN CODE OF 0
 2027  88 26 273D R	      C 	mov	byte ptr [ALT_INPUT], ah ; ZERO OUT THE FIELD
 202B  3C 00		      C 	cmp	al, 0			; WAS THE INPUT=0
 202D  74 1F		      C 	je	short k26		; INTERRUPT_RETURN
 202F  E9 01A0		      C         jmp     k58                     ; IT WASN'T, SO PUT IN BUFFER
			      C 	;
 2032			      C k24:					; BREAK-TOGGLE
 2032  F6 D4		      C 	not	ah			; INVERT MASK
 2034  20 26 273A R	      C 	and	byte ptr [KB_FLAG_1], ah ; INDICATE NO LONGER DEPRESSED
 2038  EB 14		      C 	jmp	short k26		; INTERRUPT_RETURN
			      C 	;
			      C 	;-----	TEST FOR HOLD STATE
 203A			      C k25:					; NO-SHIFT-FOUND
 203A  3C 80		      C 	cmp	al, 80h			; TEST FOR BREAK KEY
 203C  73 10		      C 	jae	short k26		; NOTHING FOR BREAK CHARS FROM HERE ON
 203E  F6 06 273A R 08	      C 	test	byte ptr [KB_FLAG_1], HOLD_STATE ; ARE WE IN HOLD STATE
 2043  74 1E		      C 	jz	short k28		; BRANCH AROUND TEST IF NOT
 2045  3C 45		      C 	cmp	al, NUM_KEY
 2047  74 05		      C 	je	short k26		; CAN'T END HOLD ON NUM_LOCK
 2049  80 26 273A R F7	      C 	and	byte ptr [KB_FLAG_1], NOT HOLD_STATE ; TURN OFF THE HOLD STATE BIT
			      C 	;
 204E			      C k26:					; INTERRUPT-RETURN
 204E  FA		      C 	cli				; TURN OFF INTERRUPTS
 204F  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT COMMAND
 2051  E6 20		      C 	out	INTA00, al		; SEND COMMAND TO INTERRUPT CONTROL PORT
 2053			      C k27:					; INTERRUPT-RETURN-NO-EOI
 2053  B0 AE		      C 	mov	al, ENA_KBD		; INSURE KEYBOARD IS ENABLED
 2055  E8 0275		      C 	call	ship_it			; EXECUTE ENABLE
 2058			      C k27a:
 2058  FA		      C 	cli				; DISABLE INTERRUPTS
 2059  07		      C 	pop	es			; RESTORE REGISTERS
 205A  1F		      C 	pop	ds
 205B  5F		      C 	pop	di
 205C  5E		      C 	pop	si
 205D  5A		      C 	pop	dx
 205E  59		      C 	pop	cx
 205F  5B		      C 	pop	bx
 2060  58		      C 	pop	ax
 2061  5D		      C 	pop	bp
 2062  CF		      C 	iret				; RETURN, INTERRUPTS ON WITH FLAG CHANGE
			      C 
			      C 	;-----	NOT IN	HOLD STATE
 2063			      C k28:					; NO-HOLD-STATE
 2063  F6 06 2739 R 08	      C 	test	byte ptr [KB_FLAG], ALT_SHIFT ; ARE WE IN ALTERNATE SHIFT
			      C 	;jnz	short k29		; JUMP IF ALTERNATE SHIFT
			      C 	;jmp	short k38		; JUMP IF NOT ALTERNATE
 2068  74 79		      C         jz      short k38
			      C 	;
			      C 	;-----	TEST FOR CONTROL KEY AND RESET KEY SEQUENCE (CTL ALT DEL)
 206A			      C k29:					; TEST-RESET
 206A  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; ARE WE IN CONTROL SHIFT ALSO
 206F  74 1B		      C 	jz	short k31		; NO RESET
 2071  3C 45		      C 	cmp	al, NUM_KEY		; CHECK FOR INVALID NUM LOCK KEY
 2073  74 D9		      C 	je	short k26		; THROW AWAY IF (ALT-CTL)+NUM-LOCK
 2075  3C 46		      C 	cmp	al, SCROLL_KEY		; CHECK FOR INVALID SCROLL-LOCK KEY
 2077  74 D5		      C 	je	short k26		; THROW AWAY IF (ALT-CTL)+SCROLL_LOCK
 2079  3C 53		      C 	cmp	al, DEL_KEY		; CTL-ALT STATE, TEST FOR DELETE KEY
 207B  75 0F		      C 	jne	short k31		; NO-RESET
			      C 	;
			      C 	;-----	CTL-ALT-DEL HAS BEEN FOUND
			      C 	;;mov	byte ptr [RESET_FLAG], 1234h ; SET FLAG FOR RESET FUNCTION
			      C 	;;jmp	short START_1		; JUMP TO POWER ON DIAGNOSTICS
 207D  BB 0040		      C         mov     bx, BIOS_DSEGM
 2080  8E DB		      C         mov     ds, bx
 2082  BB 0072		      C         mov     bx, RESET_FLAG
 2085  C7 07 1234	      C         mov     word ptr [BX], 1234h ; warm reset
			      C 	; 07/03/2014
 2089  E9 E048		      C 	jmp	cpu_reset
			      C 
			      C ;cpu_reset:
			      C 	; 07/03/2014
			      C 	; CPU reset (power on) address
			      C 	;db	0EAh  ; far jump  (jmp 0FFFFh:0000h)
			      C 	;dw	0
			      C 	;dw	0FFFFh	; F000:0FFF0h
			      C 	
			      C ;khere:	hlt
			      C ;	jmp 	short khere
			      C 	
			      C 	;
			      C 	;-----	IN ALTERNATE SHIFT, RESET NOT FOUND
 208C			      C k31:					; NO-RESET
 208C  3C 39		      C 	cmp	al, 57			; TEST FOR SPACE KEY
 208E  75 05		      C 	jne	short k32		; NOT THERE
 2090  B0 20		      C 	mov	al, ' '			; SET SPACE CHAR
 2092  E9 0134		      C         jmp     k57                     ; BUFFER_FILL
			      C 	;
			      C 	;-----	LOOK FOR KEY PAD ENTRY
 2095			      C k32:					; ALT-KEY-PAD
 2095  BF 23EA R	      C 	mov	di, offset K30		; ALT-INPUT-TABLE
 2098  B9 000A		      C 	mov	cx, 10			; LOOK FOR ENTRY USING KEYPAD
 209B  F2/ AE		      C 	repne	scasb			; LOOK FOR MATCH
 209D  75 12		      C 	jne	short k33		; NO_ALT_KEYPAD
 209F  81 EF 23EB R	      C 	sub	di, offset K30+1	; DI-NOW-HAS ENTRY VALUE
 20A3  A0 273D R	      C 	mov	al, byte ptr [ALT_INPUT] ; GET THE CURRENT BYTE
 20A6  B4 0A		      C 	mov	ah, 10			; MULTIPLY BY 10
 20A8  F6 E4		      C 	mul	ah
 20AA  03 C7		      C 	add	ax, di			; ADD IN THE LATEST ENTRY
 20AC  A2 273D R	      C 	mov	byte ptr [ALT_INPUT], al ; STORE IT AWAY
 20AF  EB 9D		      C 	jmp	short k26		; THROW AWAY THAT KEYSTROKE
			      C 	;
			      C 	;-----	LOOK FOR SUPERSHIFT ENTRY
 20B1			      C k33:					; NO-ALT-KEYPAD
 20B1  C6 06 273D R 00	      C 	mov	byte ptr [ALT_INPUT], 0	; ZERO ANY PREVIOUS ENTRY INTO INPUT
 20B6  B9 001A		      C 	mov	cx, 26			; (DI),(ES) ALREADY POINTING
 20B9  F2/ AE		      C 	repne	scasb			; LOOK FOR MATCH IN ALPHABET
 20BB  75 05		      C 	jne	short k34		; NOT FOUND, FUNCTION KEY OR OTHER
 20BD  B0 00		      C 	mov	al, 0			; ASCII CODE OF ZERO
 20BF  E9 0107		      C         jmp     k57                     ; PUT IT IN THE BUFFER
			      C 	;
			      C 	;-----	LOOK FOR TOP ROW OF ALTERNATE SHIFT
 20C2			      C k34:					; ALT-TOP-ROW
 20C2  3C 02		      C 	cmp	al, 2			; KEY WITH '1' ON IT
 20C4  74 0C		      C 	je	short k35		;  NOT ONE OF INTERESTING KEYS
 20C6  3C 0E		      C 	cmp	al, 14			;  IS IT IN THE REGION
 20C8  73 08		      C 	jae	short k35		;  ALT-FUNCTION
 20CA  80 C4 76		      C 	add	ah, 118			;  CONVERT PSEUDO SCAN CODE TO RANGE
 20CD  B0 00		      C 	mov	al, 0			;  INDICATE AS SUCH
 20CF  E9 00F7		      C         jmp     k57                     ;  BUFFER_FILL
			      C 	;
			      C 	;-----	TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES
 20D2			      C k35:					; ALT-FUNCTION
			      C 	; 59 =  scan code of F1 key
 20D2  3C 3B		      C 	cmp	al, 59			; TEST FOR IN TABLE
			      C 	;;jae	short k37		; ALT-CONTINUE
			      C         ;jb	k26
			      C 	; 27/01/2022
 20D4  73 03		      C 	jnb	short k37
 20D6			      C k36:
 20D6  E9 FF75		      C 	jmp	k26
			      C ;k36:					; CLOSE-RETURN
			      C ;	jmp	short k26		; IGNORE THE KEY
 20D9			      C k37:					; ALT-CONTINUE
 20D9  3C 47		      C 	cmp	al, 71			; IN KEYPAD REGION
			      C 	; 27/01/2022
 20DB  73 F9		      C 	jae	short k36		; IF SO, IGNORE
			      C         ;jae	k26
			      C 
 20DD  BB 23BC R	      C 	mov	bx, offset K13		; ALT SHIFT PSEUDO SCAN TABLE
 20E0  E9 0138		      C         jmp     k63                     ; TRANSLATE THAT
			      C 	;
			      C 	;-----	NOT IN ALTERNATE SHIFT
 20E3			      C k38:					; NOT-ALT-SHIFT
 20E3  F6 06 2739 R 04	      C 	test	byte ptr [KB_FLAG], CTL_SHIFT ; ARE WE IN CONTROL SHIFT
 20E8  74 69		      C 	jz	short k44		; NOT-CTL-SHIFT
			      C 	;
			      C 	;-----	CONTROL SHIFT, TEST SPECIAL CHARACTERS
			      C 	;-----	TEST FOR BREAK AND PAUSE KEYS
 20EA  3C 46		      C 	cmp	al, SCROLL_KEY		; TEST FOR BREAK
 20EC  75 1D		      C 	jne	short k39		; NO-BREAK
 20EE  8B 1E 273E R	      C 	mov	bx, word ptr [BUFFER_START] ; RESET BUFFER TO EMPTY
 20F2  89 1E 2742 R	      C 	mov	word ptr [BUFFER_HEAD], bx
 20F6  89 1E 2744 R	      C 	mov	word ptr [BUFFER_TAIL], bx
 20FA  C6 06 2738 R 80	      C 	mov	byte ptr [BIOS_BREAK], 80h ; TURN ON @BIOS_BREAK BIT
			      C 	;
			      C 	;-----	ENABLE KEYBOARD
 20FF  B0 AE		      C 	mov	al, ENA_KBD		; ENABLE KEYBOARD
 2101  E8 01C9		      C 	call	ship_it			; EXECUTE ENABLE
 2104  CD 1B		      C 	int	1Bh			; BREAK INTERRUPT VECTOR
 2106  2B C0		      C 	sub	ax, ax			; PUT OUT DUMMY CHARACTER
 2108  E9 00BE		      C         jmp     k57                     ; BUFFER_FILL
 210B			      C k39:					; NO_BREAK
 210B  3C 45		      C 	cmp	al, NUM_KEY		; LOOK FOR PAUSE KEY
 210D  75 2D		      C 	jne	short k41		; NO-PAUSE
 210F  80 0E 273A R 08	      C 	or	byte ptr [KB_FLAG_1], HOLD_STATE ; TURN ON THE HOLD FLAG
			      C 	;
			      C 	;-----	ENABLE KEYBOARD
 2114  B0 AE		      C 	mov	al, ENA_KBD		; ENABLE KEYBOARD
 2116  E8 01B4		      C 	call	ship_it			; EXECUTE ENABLE
 2119  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT TO CONTROL PORT
 211B  E6 20		      C 	out	INTA00, al		; ALLOW FURTHER KEYSTROKE INTERRUPTS
			      C 	;
			      C 	;-----	DURING PAUSE INTERVAL, TURN COLOR CRT BACK ON
 211D  1E		      C         push    ds
 211E  BB 0040		      C         mov     bx, BIOS_DSEGM
 2121  8E DB		      C         mov     ds, bx
 2123  BB 0049		      C         mov     bx, offset CRT_MODE
 2126  80 3F 07		      C         cmp     byte ptr [BX], 7        ; IS THIS THE MONOCHROME CARD
 2129  74 06		      C         je      short k40p              ; YES, NOTHING TO DO
 212B  BA 03D8		      C 	mov	dx, 03D8h		; PORT FOR COLOR CARD
 212E  B0 65		      C         mov     al, byte ptr [CRT_MODE_SET] ; GET THE VALUE OF THE CURRENT MODE
 2130  EE		      C 	out	dx, al			; SET THE CRT MODE, SO THAT CRT 15 ON
			      C 	;
			      C 	;-----	SUSPEND SYSTEM OPERATION (LOOP) TILL NEXT KEY CLEARS HOLD STATE FLAG
 2131			      C k40p:
 2131  1F		      C         pop     ds
 2132			      C k40:					; PAUSE-LOOP
 2132  F6 06 273A R 08	      C 	test	byte ptr [KB_FLAG_1], HOLD_STATE ; CHECK HOLD STATE FLAG
 2137  75 F9		      C 	jnz	short k40		; LOOP UNTIL FLAG TURNED OFF
			      C 	;
 2139  E9 FF1C		      C         jmp     k27a                    ; INTERRUPT_RETURN_NO_EOI
			      C         ;
			      C 	;-----	TEST SPECIAL CASE KEY 55
 213C			      C k41:					; NO-PAUSE
 213C  3C 37		      C 	cmp	al, 55
 213E  75 06		      C 	jne	short k42		; NOT-KEY-55
 2140  B8 7200		      C 	mov	ax, 114*100h		; START/STOP PRINTING SWITCH
 2143  E9 0083		      C         jmp     k57                     ; BUFFER_FILL
			      C 	;
			      C 	;-----	SET UP TO TRANSLATE CONTROL SHIFT
 2146			      C k42:					; NOT-KEY-55
 2146  BB 22EC R	      C 	mov	bx, offset K8		; SET UP TO TRANSLATE C7L
 2149  3C 3B		      C 	cmp	al, 59			; IS IT IN TABLE
			      C 	;js	short k56 ; !? ; 29/01/2022 (Bug!?)
			      C 	; 29/01/2022 (Ref: IBM/PC AT BIOS v2 (KYB.ASM, 10/06/1985) 
 214B  72 79		      C 	jb	short k56		; YES, GO TRANSLATE CHAR
			      C 					; CTL-TABLE-TRANSLATE
 214D  BB 2326 R	      C 	mov	bx, offset K9		; CTL TABLE SCAN
 2150  E9 00C8		      C         jmp     k63                     ; TRANSLATE_SCAN
			      C 	;
			      C 	;-----	NOT IN CONTROL SHIFT
 2153			      C k44:					; NOT-CTL-SHIFT
 2153  3C 47		      C 	cmp	al, 71			; TEST FOR KEYPAD REGION
 2155  73 2F		      C 	jae	short k48		; HANDLE KEYPAD REGION
 2157  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT
 215C  74 5D		      C 	jz	short k54		; TEST FOR SHIFT STATE
			      C 	;
			      C 	;-----	UPPER CASE, HANDLE SPECIAL CASES
 215E  3C 0F		      C 	cmp	al, 15			; BACK TAB KEY
 2160  75 05		      C 	jne	short k45		; NOT-BACK-TAB
 2162  B8 0F00		      C 	mov	ax, 15*100h		; SET PSEUDO SCAN CODE
 2165  EB 62		      C 	jmp	short k57		; BUFFER_FILL
			      C 	;
 2167			      C k45:					; NOT-BACK-TAB
 2167  3C 37		      C 	cmp	al, 55			; PRINT SCREEN KEY
 2169  75 0C		      C 	jne	short k46		; NOT-PRINT-SCREEN
			      C 	;
			      C 	;-----	ISSUE INTERRUPT TO INDICATE PRINT SCREEN FUNCTION
 216B  B0 AE		      C 	mov	al, ENA_KBD		; INSURE KEYBOARD IS ENABLED
 216D  E8 015D		      C 	call	ship_it			; EXECUTE ENABLE
 2170  B0 20		      C 	mov	al, EOI			; END OF CURRENT INTERRUPT
 2172  E6 20		      C 	out	INTA00, al		; SO FURTHER THINGS CAN HAPPEN
			      C 	;push	bp			; SAVE POINTER
			      C 	;int	05h			; ISSUE PRINT SCREEN INTERRUPT
			      C 	;pop	bp			; RESTORE POINTER
 2174  E9 FEDC		      C         jmp     k27                     ; GO BACK WITHOUT EOI OCCURRING
			      C 	;
 2177			      C k46:					; NOT-PRINT-SCREEN
 2177  3C 3B		      C 	cmp	al, 59			; FUNCTION KEYS
			      C 	;js	short k47 ; !? ; 29/01/2022 (Bug!?)
			      C 	; 29/01/2022 (Ref: IBM/PC AT BIOS v2 (KYB.ASM, 10/06/1985) 
 2179  72 06		      C 	jb	short k47		; NOT-UPPER-FUNCTION
 217B  BB 23B2 R	      C 	mov	bx, offset K12		; UPPER CASE PSEUDO SCAN CODES
 217E  E9 009A		      C         jmp     k63                     ; TRANSLATE_SCAN
			      C 	;
 2181			      C k47:					; NOT-UPPER-FUNCTION
 2181  BB 2378 R	      C 	mov	bx, offset K11		; POINT TO UPPER CASE TABLE
 2184  EB 40		      C 	jmp	short k56		; OK, TRANSLATE THE CHAR
			      C 	;
			      C 	;-----	KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION
 2186			      C k48:					; KEYPAD-REGION
 2186  F6 06 2739 R 20	      C 	test byte ptr [KB_FLAG], NUM_STATE ; ARE WE IN NUM LOCK
 218B  75 20		      C 	jnz	short k52		; TEST FOR SURE
 218D  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE
 2192  75 20		      C 	jnz	short k53		; IF SHIFTED, REALLY NUM STATE
			      C 	;
			      C 	;-----	BASE CASE FOR KEYPAD
 2194			      C k49:					; BASE-CASE
 2194  3C 4A		      C 	cmp	al, 74			; SPECIAL CASE FOR A COUPLE OF KEYS
 2196  74 0B		      C 	je	short k50		; MINUS
 2198  3C 4E		      C 	cmp	al, 78
 219A  74 0C		      C 	je	short k51
 219C  2C 47		      C 	sub	al, 71			; CONVERT ORIGIN
 219E  BB 23D3 R	      C 	mov	bx, offset K15		; BASE CASE TABLE
 21A1  EB 7A		      C         jmp     k64                     ; CONVERT TO PSEUDO SCAN
 21A3			      C k50:
 21A3  B8 4A2D		      C 	mov	ax, (74*100h)+'-'	; MINUS
 21A6  EB 21		      C 	jmp	short k57		; BUFFER_FILL
 21A8			      C k51:
 21A8  B8 4E2B		      C 	mov	ax, (78*100h)+'+'		; PLUS
 21AB  EB 1C		      C 	jmp	short k57		; BUFFER_FILL
			      C 	;
			      C 	;-----	MIGHT BE NUM LOCK, TEST SHIFT STATUS
 21AD			      C k52:					; ALMOST-NUM-STATE
 21AD  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT
 21B2  75 E0		      C 	jnz 	short k49		; SHIFTED TEMP OUT OF NUM STATE
			      C 	;
 21B4			      C k53:					; REALLY NUM STATE
 21B4  2C 46		      C 	sub	al, 70			; CONVERT ORIGIN
 21B6  BB 23C6 R	      C 	mov	bx, offset K14		; NUM STATE TABLE
 21B9  EB 0B		      C 	jmp	short k56		; TRANSLATE_CHAR
			      C 	;
			      C 	;-----	PLAIN OLD LOWER CASE 
 21BB			      C k54:					; NOT-SHIFT
 21BB  3C 3B		      C 	cmp	al, 59			; TEST FOR FUNCTION KEYS
 21BD  72 04		      C 	jb	short k55		; NOT-LOWER-FUNCTION
 21BF  B0 00		      C 	mov	al, 0			; SCAN CODE IN AH ALREADY
 21C1  EB 06		      C 	jmp	short k57 		; BUFFER_FILL
			      C 	;
 21C3			      C k55:					; NOT-LOWER-FUNCTION
 21C3  BB 233F R	      C 	mov	bx, offset K10		; LC TABLE
			      C 	;
			      C 	;-----	TRANSLATE THE CHARACTER
 21C6			      C k56:					; TRANSLATE-CHAR
 21C6  FE C8		      C 	dec	al			; CONVERT ORIGIN
 21C8  D7		      C 	xlat    			; CONVERT THE SCAN CODE TO ASCII
			      C 	;
			      C 	;-----	PUT CHARACTER INTO BUFFER
 21C9			      C k57:					; BUFFER_FILL
 21C9  3C FF		      C 	cmp	al, -1			; IS THIS AN IGNORE CHAR
 21CB  74 1F		      C 	je	short k59		; YES, DO NOTHING WITH IT
			      C         ; 27/01/2022
			      C 	;je	k26
 21CD  80 FC FF		      C 	cmp	ah, -1			; LOOK FOR -1 PSEUDO SCAN
 21D0  74 1A		      C 	je	short k59		; NEAR_INTERRUPT_RETURN
			      C         ; 27/01/2022
			      C 	;je	k26
			      C 
			      C ;	; 07/03/2014
			      C ;; DELETE key handling (ASCII = 127)
			      C ;; (This code part was not in original INT 09h handler)
			      C ;; AX =  53E0h => AX = 007Fh <= AX = 5300h
			      C ;	cmp	ah, DEL_KEY
			      C ;	jne	short k58
			      C ;	cmp	al, 0E0h
			      C ;	je	short @f
			      C ;	and	al, al
			      C ;	jnz	short k58
			      C ;@@:
			      C ;	mov	ax, 127
			      C ;	jmp	short k61
			      C 	;
			      C 	;
			      C 	;-----	HANDLE THE CAPS LOCK PROBLEM
 21D2			      C k58:					; BUFFER_FILL-NOTEST
 21D2  F6 06 2739 R 40	      C 	test	byte ptr [KB_FLAG], CAPS_STATE ; ARE WE IN CAPS LOCK STATE
 21D7  74 20		      C 	jz	short k61		; SKIP IF NOT
			      C 	;
			      C 	;-----	IN CAPS LOCK STATE
 21D9  F6 06 2739 R 03	      C 	test	byte ptr [KB_FLAG], LEFT_SHIFT+RIGHT_SHIFT ; TEST FOR SHIFT STATE
 21DE  74 0F		      C 	jz	short k60		; IF NOT SHIFT, CONVERT LOWER TO UPPER
			      C 	;
			      C 	;-----	CONVERT ANY UPPER CASE TO LOWER CASE
 21E0  3C 41		      C 	cmp	al, 'A'			; FIND OUT IF ALPHABETIC
 21E2  72 15		      C 	jb	short k61		; NOT-CAPS-STATE
 21E4  3C 5A		      C 	cmp	al, 'Z'
 21E6  77 11		      C 	ja	short k61		; NOT_CAPS STATE
 21E8  04 20		      C 	add	al, 'a'-'A'		; CONVERT TO LOWER CASE
 21EA  EB 0D		      C 	jmp	short k61		; NOT_CAPS_STATE
 21EC			      C k59:					; NEAR-INTERRUPT-RETURN
 21EC  E9 FE5F		      C 	jmp	k26			; INTERRUPT_RETURN
			      C 	;
			      C 	;-----	CONVERT ANY LOWER CASE TO UPPER CASE
 21EF			      C k60:					; LOWER-TO-UPPER
 21EF  3C 61		      C 	cmp	al, 'a'			; FIND OUT IF ALPHABETIC
 21F1  72 06		      C 	jb	short k61		; NOT_CAPS_STATE
 21F3  3C 7A		      C 	cmp	al, 'z'
 21F5  77 02		      C 	ja	short k61		; NOT CAPS STATE
 21F7  2C 20		      C 	sub	al, 'a'-'A'		; CONVERT TO UPPER CASE
			      C 	;
 21F9			      C k61:					; NOT-CAPS-STATE
 21F9  8B 1E 2744 R	      C 	mov	bx, word ptr [BUFFER_TAIL] ; GET THE END POINTER TO THE BUFFER
 21FD  8B F3		      C 	mov	si, bx			; SAVE THE VALUE
 21FF  E8 FBFF		      C 	call	k4			; ADVANCE THE TAIL
 2202  3B 1E 2742 R	      C 	cmp	bx, word ptr [BUFFER_HEAD] ; HAS THE BUFFER WRAPPED AROUND
 2206  74 1C		      C 	je	short k62		; BUFFER_FULL_BEEP
 2208  89 04		      C 	mov	word ptr [SI], ax	; STORE THE VALUE
 220A  89 1E 2744 R	      C 	mov	word ptr [BUFFER_TAIL], bx ; MOVE THE POINTER UP
 220E  FA		      C 	cli				; TURN OFF INTERRUPTS
 220F  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT COMMAND
 2211  E6 20		      C 	out	INTA00, al		; SEND COMMAND TO INTERRUPT CONTROL PORT
 2213  B0 AE		      C 	mov	al, ENA_KBD		; INSURE KEYBOARD IS ENABLED
 2215  E8 00B5		      C 	call	ship_it			; EXECUTE ENABLE
			      C 	;mov	ax, 09102h		; MOVE IN POST CODE & TYPE
			      C 	;int	15h			; PERFORM OTHER FUNCTION
 2218  E9 FE3D		      C         jmp     k27a                    ; INTERRUPT_RETURN
			      C 	;
			      C 	;-----	TRANSLATE SCAN FOR PSEUDO SCAN CODES
 221B			      C k63:					; TRANSLATE-SCAN
 221B  2C 3B		      C 	sub	al, 59			; CONVERT ORIGIN TO FUNCTION KEYS
 221D			      C k64:					; TRANSLATE-SCAN-ORGD
 221D  D7		      C        	xlat    	                ; CTL TABLE SCAN
 221E  8A E0		      C 	mov	ah, al			; PUT VALUE INTO AH
 2220  B0 00		      C 	mov	al, 0			; ZERO ASCII CODE
 2222  EB A5		      C 	jmp	short k57		; PUT IT INTO THE BUFFER
 2224			      C k62:
 2224  B0 20		      C 	mov	al, EOI			; ENABLE INTERRUPT CONTROLLER CHIP
 2226  E6 20		      C 	out	INTA00, al
 2228  B9 02A6		      C 	mov	cx, 678			; DIVISOR FOR 1760 HZ
 222B  B3 04		      C 	mov	bl, 4			; SHORT BEEP COUNT (1/16  1/64 DELAY)
 222D  E8 F9E3		      C 	call	beep			; GO TO COMMON BEEP HANDLER
 2230  E9 FE20		      C         jmp     k27                     ; EXIT
			      C 
 2233			      C snd_data:
			      C 	; ---------------------------------------------------------------------------------
			      C 	; SND_DATA
			      C 	;	THIS ROUTINES HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
			      C 	;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS. IT ALSO
			      C 	;	HANDLES ANY RETRIES IF REQUIRED
			      C 	; ---------------------------------------------------------------------------------
			      C 	;
 2233  50		      C 	push	ax			; SAVE REGISTERS
 2234  53		      C 	push	bx
 2235  51		      C 	push	cx
 2236  8A F8		      C 	mov	bh, al			; SAVE TRANSMITTED BYTE FOR RETRIES
 2238  B3 03		      C 	mov	bl, 3			; LOAD RETRY COUNT SOOT
			      C 	; 29/01/2022
			      C 	; Ref: IBM PC AT BIOS v2 (15/11/1985)
 223A			      C sd0:
 223A  FA		      C 	cli				; DISABLE INTERRUPTS
 223B  80 26 273B R CF	      C 	and	byte ptr [KB_FLAG_2], not (KB_FE+KB_FA) ; CLEAR ACK AND RESEND FLAGS
			      C 	;
			      C 	;-----	WAIT FOR ANY PENDING COMMAND TO BE ACCEPTED
 2240  2B C9		      C 	sub	cx, cx			; MAXIMUM WAIT COUNT
 2242			      C sd1:
 2242  E4 64		      C 	in	al, STATUS_PORT		; READ KEYBOARD PROCESSOR STATUS PORT
 2244  A8 02		      C 	test	al, INPT_BUF_FULL	; CHECK FOR ANY PENDING COMMAND
 2246  E0 FA		      C 	loopnz	sd1			; WAIT FOR COMMAND TO BE ACCEPTED
			      C 	;
 2248  8A C7		      C 	mov	al, bh			; REESTABLISH BYTE TO TRANSMIT
 224A  E6 60		      C 	out	PORT_A, al		; SEND BYTE
 224C  FB		      C 	sti				; ENABLE INTERRUPTS
			      C 	;mov	cx, 01A00h		; LOAD COUNT FOR 10 ms+
 224D  33 C9		      C 	xor	cx, cx
 224F			      C sd3:
 224F  F6 06 273B R 30	      C 	test	byte ptr [KB_FLAG_2], KB_FE+KB_FA ; SEE IF EITHER BIT SET
 2254  75 0D		      C 	jnz	short sd7		; IF SET, SOMETHING RECEIVED GO PROCESS
			      C 	;
 2256  E2 F7		      C 	loop	sd3			; OTHERWISE WAIT
 2258			      C sd5:
 2258  FE CB		      C 	dec	bl			; DECREMENT RETRY COUNT
 225A  75 E6		      C 	jnz	short sd1		; RETRY TRANSMISSION
			      C 	;
 225C  80 0E 273B R 80	      C 	or	byte ptr [KB_FLAG_2], KB_ERR ; TURN ON TRANSMIT ERROR FLAG
 2261  EB 07		      C 	jmp	short sd9		; RETRIES EXHAUSTED FORGET TRANSMISSION
 2263			      C sd7:
 2263  F6 06 273B R 10	      C 	test	byte ptr [KB_FLAG_2], KB_FA  ; SEE IF THIS IS AN ACKNOWLEDGE
 2268  74 EE		      C 	jz	short sd5		; IF NOT, GO RESEND
 226A			      C sd9:	
 226A  59		      C 	pop	cx			; RESTORE REGISTERS
 226B  5B		      C 	pop	bx
 226C  58		      C 	pop	ax
 226D  C3		      C 	retn				; RETURN, GOOD TRANSMISSION
			      C 
 226E			      C snd_led:
			      C 	; ---------------------------------------------------------------------------------
			      C 	; SND_LED
			      C 	; SND_LED1
			      C 	;
			      C 	;	THIS ROUTINES TURNS ON THE MODE INDICATORS.
			      C 	;
			      C 	;----------------------------------------------------------------------------------
			      C 	;
 226E  FA		      C 	cli				; TURN OFF INTERRUPTS
 226F  F6 06 273B R 40	      C 	test	byte ptr [KB_FLAG_2], KB_PR_LED	; CHECK FOR MODE INDICATOR UPDATE
 2274  75 47		      C 	jnz	short sl9		; DON'T UPDATE AGAIN IF UPDATE UNDERWAY
			      C 	;
 2276  80 0E 273B R 40	      C 	or	byte ptr [KB_FLAG_2], KB_PR_LED	; TURN ON UPDATE IN PROCESS
 227B  B0 20		      C 	mov	al, EOI			; END OF INTERRUPT COMMAND
 227D  E6 20		      C 	out	INTA00, al		; SEND COMMAND TO INTERRUPT CONTROL PORT
 227F  EB 0D		      C 	jmp	short sl3		; GO SEND MODE INDICATOR COMMAND
			      C 
 2281			      C snd_led1:
 2281  FA		      C 	cli				; TURN OFF INTERRUPTS
 2282  F6 06 273B R 40	      C 	test	byte ptr [KB_FLAG_2], KB_PR_LED ; CHECK FOR MODE INDICATOR UPDATE
 2287  75 34		      C 	jnz	short sl9		; DON'T UPDATE AGAIN IF UPDATE UNDERWAY
			      C 	;
 2289  80 0E 273B R 40	      C 	or	byte ptr [KB_FLAG_2], KB_PR_LED	; TURN ON UPDATE IN PROCESS
 228E			      C sl3:
 228E  B0 ED		      C 	mov	al, LED_CMD		; LED CMD BYTE
 2290  E8 FFA0		      C 	call	snd_data		; SEND DATA TO KEYBOARD
 2293  FA		      C 	cli
 2294  E8 0028		      C 	call	make_led		; GO FORM INDICATOR DATA BYTE
 2297  80 26 273B R F8	      C 	and	byte ptr [KB_FLAG_2], not KB_LEDS ; CLEAR MODE INDICATOR BITS
 229C  08 06 273B R	      C 	or	byte ptr [KB_FLAG_2], al ; SAVE INDICATORS STATES FOR NEXT TIME
 22A0  F6 06 273B R 80	      C 	test	byte ptr [KB_FLAG_2], KB_ERR ; TRANSMIT ERROR DETECTED
 22A5  75 0B		      C 	jnz	short sl5		; IF SO, BYPASS SECOND BYTE TRANSMISSION
			      C 	;
 22A7  E8 FF89		      C 	call	snd_data		; SEND DATA TO KEYBOARD
 22AA  FA		      C 	cli				; TURN OFF INTERRUPTS
 22AB  F6 06 273B R 80	      C 	test	byte ptr [KB_FLAG_2], KB_ERR ; TRANSMIT ERROR DETECTED
 22B0  74 06		      C 	jz	short sl7		; IF NOT, DON'T SEND AN ENABLE COMMAND
 22B2			      C sl5:
 22B2  B0 F4		      C 	mov	al, KB_ENABLE		; GET KEYBOARD CSA ENABLE COMMAND
 22B4  E8 FF7C		      C 	call	snd_data		; SEND DATA TO KEYBOARD
 22B7  FA		      C 	cli				; TURN OFF INTERRUPTS
 22B8			      C sl7:
 22B8  80 26 273B R 3F	      C 	and	byte ptr [KB_FLAG_2], not (KB_PR_LED+KB_ERR) ; TURN OFF MODE INDICATOR
 22BD			      C sl9:					; UPDATE AND TRANSMIT ERROR FLAG
 22BD  FB		      C 	sti				; ENABLE INTERRUPTS
 22BE  C3		      C 	retn				; RETURN TO CALLER
			      C 
 22BF			      C make_led:
			      C 	;---------------------------------------------------------------------------------
			      C 	; MAKE_LED
			      C 	;
			      C 	;	THIS ROUTINES FORMS THE DATA BYTE NECESSARY TO TURN ON/OFF
			      C 	;	THE MODE INDICATORS.
			      C 	;
			      C 	;---------------------------------------------------------------------------------
			      C 	;
 22BF  51		      C 	push 	cx			; SAVE CX
 22C0  A0 2739 R	      C 	mov	al, byte ptr [KB_FLAG]	; GET CAPS & NUM LOCK INDICATORS
 22C3  24 70		      C 	and	al, CAPS_STATE+NUM_STATE+SCROLL_STATE ; ISOLATE INDICATORS
 22C5  B1 04		      C 	mov	cl, 4			; SHIFT COUNT
 22C7  D2 C0		      C 	rol	al, cl			; SHIFT BITS OVER TO TURN ON INDICATORS
 22C9  24 07		      C 	and	al, 07h			; MAKE SURE ONLY MODE BITS ON
 22CB  59		      C 	pop	cx
 22CC  C3		      C 	retn				; RETURN TO CALLER
			      C 
 22CD			      C ship_it:
			      C 	;---------------------------------------------------------------------------------
			      C 	; SHIP_IT
			      C 	;
			      C 	;	THIS ROUTINES HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
			      C 	;	TO THE KEYBOARD CONTROLLER.
			      C 	;
			      C 	;---------------------------------------------------------------------------------
			      C 	;
 22CD  50		      C 	push	ax			; SAVE DATA TO SEND
			      C 
			      C 	;-----	WAIT FOR COMMAND TO ACCEPTED
 22CE  FA		      C 	cli				; DISABLE INTERRUPTS TILL DATA SENT
 22CF  2B C9		      C 	sub	cx, cx			; CLEAR TIMEOUT COUNTER
 22D1			      C s10:
 22D1  E4 64		      C 	in	al, STATUS_PORT		; READ KEYBOARD CONTROLLER STATUS
 22D3  A8 02		      C 	test	al, INPT_BUF_FULL	; CHECK FOR ITS INPUT BUFFER BUSY
 22D5  E0 FA		      C 	loopnz	s10			; WAIT FOR COMMAND TO BE ACCEPTED
			      C 
 22D7  58		      C 	pop	ax			; GET DATA TO SEND
 22D8  E6 64		      C 	out	STATUS_PORT, al		; SEND TO KEYBOARD CONTROLLER
 22DA  FB		      C 	sti				; ENABLE INTERRUPTS AGAIN
 22DB  C3		      C 	retn				; RETURN TO CALLER
			      C 
			      C ; 29/01/2022
			      C ; Ref: IBM PC/AT BIOS v2 (ORGS.ASM, 10/06/1985)
			      C 
			      C ;---------------------------------------------------------------------
			      C ;	KEY IDENTIFICATION SCAN TABLES				     -
			      C ;---------------------------------------------------------------------
			      C 
			      C ;-----	TABLE OF SHIFT KEYS AND MASK VALUES (EARLY PC)
 22DC 52		      C K6:	db	INS_KEY			; INSERT KEY
 22DD  3A 45 46 38 1D	      C 	db	CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
 22E2  2A 36		      C         db      LEFT_KEY,RIGHT_KEY
 22E4 = 0008		      C K6L	equ	$-K6
			      C 
			      C ;-----	SHIFT_MASK_TABLE
 22E4 80		      C K7:	db	INS_SHIFT		; INSERT MODE SHIFT
 22E5  40 20 10 08 04	      C 	db	CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
 22EA  02 01		      C 	db	LEFT_SHIFT,RIGHT_SHIFT
			      C 
			      C ;-----	SCAN CODE TABLES
 22EC 1B FF 00 FF FF FF	      C K8:	db	27,-1,0,-1,-1,-1,30,-1,-1,-1,-1,31
       1E FF FF FF FF 1F
 22F8  FF 7F FF 11 17 05      C 	db	-1,127,-1,17,23,5,18,20,25,21,9,15
       12 14 19 15 09 0F
 2304  10 1B 1D 0A FF 01      C 	db	16,27,29,10,-1,1,19,4,6,7,8,10
       13 04 06 07 08 0A
 2310  0B 0C FF FF FF FF      C 	db	11,12,-1,-1,-1,-1,28,26,24,3,22,2
       1C 1A 18 03 16 02
 231C  0E 0D FF FF FF FF      C 	db	14,13,-1,-1,-1,-1,-1,-1,' ',-1
       FF FF 20 FF
			      C 
			      C ;-----	CTL TABLE SCAN
 2326 5E 5F 60 61 62 63	      C K9:	db 	94,95,96,97,98,99,100,101,102,103,-1,-1
       64 65 66 67 FF FF
 2332  77 FF 84 FF 73 FF      C 	db	119,-1,132,-1,115,-1,116,-1,117,-1,118,-1
       74 FF 75 FF 76 FF
 233E  FF		      C 	db	-1
			      C 
			      C ;-----	LC TABLE
 233F 1B 31 32 33 34 35	      C K10:	db 	01Bh,'1234567890-=',08h,09h
       36 37 38 39 30 2D
       3D 08 09
 234E  71 77 65 72 74 79      C 	db 	'qwertyuiop[]',0Dh,-1,'asdfghjkl;',027h
       75 69 6F 70 5B 5D
       0D FF 61 73 64 66
       67 68 6A 6B 6C 3B
       27
 2367  60 FF 5C 7A 78 63      C 	db	60h,-1,5Ch,'zxcvbnm,./',-1,'*',-1,' '
       76 62 6E 6D 2C 2E
       2F FF 2A FF 20
			      C 
			      C ;-----	UC TABLE
 2378 1B 21 40 23 24 25	      C K11:	db 	27,'!@#$',37,05Eh,'&*()_+',08h,0
       5E 26 2A 28 29 5F
       2B 08 00
 2387  51 57 45 52 54 59      C 	db 	'QWERTYUIOP{}',0Dh,-1,'ASDFGHJKL:"'
       55 49 4F 50 7B 7D
       0D FF 41 53 44 46
       47 48 4A 4B 4C 3A
       22
 23A0  7E FF 7C 5A 58 43      C 	db	07Eh,-1,'|ZXCVBNM<>?',-1,0,-1,' ',-1
       56 42 4E 4D 3C 3E
       3F FF 00 FF 20 FF
			      C 
			      C ;-----	UC TABLE SCAN
 23B2 54 55 56 57 58 59	      C K12:	db	84,85,86,87,88,89
 23B8  5A 5B 5C 5D	      C 	db	90,91,92,93
			      C 
			      C ;-----	ALT TABLE SCAN
 23BC 68 69 6A 6B 6C	      C K13:	db	104,105,106,107,108
 23C1  6D 6E 6F 70 71	      C 	db	109,110,111,112,113
			      C 
			      C ;-----	NUM STATE TABLE
 23C6 37 38 39 2D 34 35	      C K14:	db 	'789-456+1230.'
       36 2B 31 32 33 30
       2E
			      C 
			      C ;-----	BASE CASE TABLE
 23D3 47 48 49 FF 4B FF	      C K15:	db	71,72,73,-1,75,-1
 23D9  4D FF 4F 50 51 52      C 	db	77,-1,79,80,81,82,83
       53
			      C 
			      C ;-----	TABLE OF KEYPAD CURSOR	; CONTROL KEYS
 23E0			      C K_TAB1:
 23E0  48 50 52 53 4B 4D      C 	db 	UP_M, DN_M, INS_M, DEL_M, LEFT_M, RIGHT_M
 23E6  49 51 47 4F	      C 	db 	PGUP_M, PGDN_M, HOME_M, END_M
 23EA = 000A		      C L_TAB1	equ	$-K_TAB1
			      C 
			      C ;-----	ALT-INPUT-TABLE
 23EA 52 4F 50 51 4B 4C	      C K30:	db	82,79,80,81,75,76
 23F0  4D 47 48 49	      C 	db	77,71,72,73		; 10 NUMBERS ON KEYPAD
			      C 	;
			      C 	;----- 	SUPER-SHIFT-TABLE
 23F4  10 11 12 13 14 15      C 	db	16,17,18,19,20,21	; A-Z TYPEWRITER CHARS
 23FA  16 17 18 19 1E 1F      C 	db	22,23,24,25,30,31
 2400  20 21 22 23 24 25      C 	db	32,33,34,35,36,37
 2406  26 2C 2D 2E 2F 30      C 	db	38,44,45,46,47,48
 240C  31 32		      C 	db	49,50
			      C ;
			      C ;---------------------------------------------------------------------
			      C ;
			      C 

				; RETRO UNIX 8086 v1 special/private procedures
				;

 240E				epoch:
					; 09/04/2013
					; Retro UNIX 8086 v1 feature/procedure only!
					; 'epoch' procedure prototype: 
					; 	            UNIXCOPY.ASM, 10/03/2013
					; 14/11/2012
					; unixboot.asm (boot file configuration)
					; version of "epoch" procedure in "unixproc.asm"
					; 21/7/2012
					; 15/7/2012
					; 14/7/2012		
					; Erdogan Tan - RETRO UNIX v0.1
					; compute current date and time as UNIX Epoch/Time
					; UNIX Epoch: seconds since 1/1/1970 00:00:00
					;
				        ;  ((Modified registers: AX, DX, CX, BX))  
					;

					; 21/7/2012
					;push	bx
					;push	cx

 240E  B4 02				mov	ah, 02h			; Return Current Time
 2410  CD 1A			        int	1Ah
 2412  86 E9			        xchg	ch,cl
 2414  89 0E 2700 R		        mov	word ptr [hour], cx
 2418  86 F2			        xchg	dh,dl
 241A  89 16 2702 R		        mov	word ptr [second], dx

 241E  B4 04			        mov	ah, 04h			; Return Current Date
 2420  CD 1A			        int	1Ah
 2422  86 E9			        xchg	ch,cl
 2424  89 0E 26FC R		        mov	word ptr [year], cx
 2428  86 F2			        xchg	dh,dl
 242A  89 16 26FE R		        mov	word ptr [month], dx

 242E  B9 3030				mov	cx, 3030h

					
 2431  A0 2700 R			mov	al, byte ptr [hour] ; Hour
				           ; AL <= BCD number)
 2434  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 2436  D5 0A			        aad ; AX= AH*10+AL
						
 2438  A2 2700 R			mov	byte ptr [hour], al

 243B  A0 2701 R			mov	al, byte ptr [hour]+1 ; Minute
				           ; AL <= BCD number)
 243E  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 2440  D5 0A			        aad ; AX= AH*10+AL
						
 2442  A2 2701 R			mov	byte ptr [minute], al

 2445  A0 2702 R			mov	al, byte ptr [second] ; Second
				           ; AL <= BCD number)
 2448  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 244A  D5 0A			        aad ; AX= AH*10+AL
						
 244C  A2 2702 R			mov	byte ptr [second], al

					
 244F  A1 26FC R			mov	ax, word ptr [year] ; Year (century)
 2452  50			        push	ax
					   ; AL <= BCD number)
 2453  D4 10			        db	0D4h,10h                ; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 2455  D5 0A			        aad ; AX= AH*10+AL
						
 2457  B4 64				mov	ah, 100
 2459  F6 E4				mul	ah
 245B  A3 26FC R			mov	word ptr [year], ax

 245E  58				pop	ax
 245F  8A C4				mov	al, ah
				           ; AL <= BCD number)
 2461  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 2463  D5 0A			        aad ; AX= AH*10+AL
						
 2465  01 06 26FC R			add	word ptr [year], ax


 2469  A0 26FE R			mov	al, byte ptr [month] ; Month
				           ; AL <= BCD number)
 246C  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 246E  D5 0A			        aad ; AX= AH*10+AL
					
 2470  A2 26FE R			mov	byte ptr [month], al	


 2473  A0 26FF R			mov	al, byte ptr [month]+1 ; Day
				           ; AL <= BCD number)
 2476  D4 10			        db	0D4h,10h		; Undocumented inst. AAM
									; AH = AL / 10h
									; AL = AL MOD 10h
 2478  D5 0A			        aad ; AX= AH*10+AL

 247A  A2 26FF R			mov	byte ptr [Day], al
					
 247D				convert_to_epoch:
					; Derived from DALLAS Semiconductor
					; Application Note 31 (DS1602/DS1603)
					; 6 May 1998

 247D  8B 16 26FC R			mov	dx, word ptr [year]
 2481  81 EA 07B2			sub	dx, 1970
 2485  B8 016D				mov	ax, 365
 2488  F7 E2				mul	dx
 248A  32 FF				xor	bh, bh
 248C  8A 1E 26FE R			mov	bl, byte ptr [month]
 2490  FE CB				dec	bl
 2492  D0 E3				shl	bl, 1
 2494  8B 8F 2704 R			mov	cx, word ptr DMonth[BX]
 2498  8A 1E 26FF R			mov	bl, byte ptr [Day]
 249C  FE CB				dec	bl
					
 249E  03 C1				add	ax, cx
 24A0  83 D2 00				adc	dx, 0
 24A3  03 C3				add	ax, bx
 24A5  83 D2 00				adc	dx, 0
								; DX:AX = days since 1/1/1970
 24A8  8B 0E 26FC R			mov	cx, word ptr [year]
 24AC  81 E9 07B1			sub	cx, 1969
 24B0  D1 E9				shr	cx, 1
 24B2  D1 E9				shr	cx, 1		
						; (year-1969)/4
 24B4  03 C1				add	ax, cx
 24B6  83 D2 00				adc	dx, 0
								; + leap days since 1/1/1970

 24B9  80 3E 26FE R 02			cmp	byte ptr [month], 2  ; if past february
 24BE  76 0F				jna	short @f
 24C0  8B 0E 26FC R			mov	cx, word ptr [year]
 24C4  83 E1 03				and	cx, 3 ; year mod 4
 24C7  75 06				jnz	short @f		
								; and if leap year
 24C9  83 C0 01				add	ax, 1 ; add this year's leap day (february 29)
 24CC  83 D2 00				adc	dx, 0
 24CF				@@: 			; compute seconds since 1/1/1970
 24CF  BB 0018				mov	bx, 24
 24D2  E8 0028				call	mul32

 24D5  8A 1E 2700 R			mov	bl, byte ptr [hour]
 24D9  03 C3				add	ax, bx
 24DB  83 D2 00				adc	dx, 0
					
 24DE  BB 003C				mov	bx, 60
 24E1  E8 0019				call	mul32

 24E4  8A 1E 2701 R			mov	bl, byte ptr [minute]
 24E8  03 C3				add	ax, bx
 24EA  83 D2 00				adc	dx, 0
					
 24ED  BB 003C				mov	bx, 60
 24F0  E8 000A				call	mul32

 24F3  8A 1E 2702 R			mov	bl, byte ptr [second]
 24F7  03 C3				add	ax, bx
 24F9  83 D2 00			 	adc	dx, 0

					; DX:AX -> seconds since 1/1/1970 00:00:00

					; 21/7/2012
					;pop	cx
					;pop	bx
					
 24FC  C3				retn

 24FD				mul32:
					; push cx

 24FD  8B CB				mov	cx, bx
 24FF  8B DA				mov	bx, dx

 2501  F7 E1				mul	cx

 2503  93				xchg	ax, bx

 2504  52				push	dx

 2505  F7 E1			     	mul	cx 

 2507  59				pop	cx 

 2508  03 C1				add	ax, cx 
 250A  83 D2 00				adc	dx, 0

 250D  93				xchg	bx, ax
 250E  87 D3				xchg	dx, bx

					; pop	cx

 2510  C3				retn

 2511				set_date_time: ; 20/06/2013
 2511				convert_from_epoch:
					; 02/06/2022 (BugFix)
					; 20/06/2013
					; Retro UNIX 8086 v1 feature/procedure only!
					; 'convert_from_epoch' procedure prototype: 
					; 	            UNIXCOPY.ASM, 10/03/2013
					; 30/11/2012
					; Derived from DALLAS Semiconductor
					; Application Note 31 (DS1602/DS1603)
					; 6 May 1998
					;
					; INPUT:
					; DX:AX = Unix (Epoch) Time
					;
					; ((Modified registers: AX, DX, CX, BX))  
					;
 2511  B9 003C				mov	cx, 60
 2514  E8 00C4				call	div32
					;mov	word ptr [imin], ax   ; whole minutes
					;mov	word ptr [imin]+2, dx ; since 1/1/1970
					;mov	word ptr [second], bx ; leftover seconds
					; 02/06/2022
 2517  88 1E 2702 R			mov	byte ptr [second], bl ; leftover seconds

					;mov	cx, 60
 251B  E8 00BD				call	div32
					;mov	word ptr [ihrs], ax   ; whole hours
					;mov	word ptr [ihrs]+2, dx ; since 1/1/1970
					;mov	word ptr [minute], bx ; leftover minutes
					; 02/06/2022
 251E  88 1E 2701 R			mov	byte ptr [minute], bl ; leftover minutes
					;mov	cx, 24
 2522  B1 18				mov	cl, 24
 2524  E8 00B4				call	div32
					;mov	word ptr [iday], ax ; whole days
								  ; since 1/1/1970
					;mov	word ptr [iday]+2, dx ; DX = 0
					;mov	word ptr [hour], bx ; leftover hours
					; 02/06/2022
 2527  88 1E 2700 R			mov	byte ptr [hour], bl ; leftover hours

 252B  05 02DB				add	ax, 365+366	  ; whole day since
								  ; 1/1/1968 	
					; adc	dx, 0	          ;  DX = 0
					; mov	word ptr [iday], ax
 252E  50				push	ax
 252F  B9 05B5				mov	cx, (4*365)+1	  ; 4 years = 1461 days
 2532  E8 00A6				call div32
 2535  59				pop	cx
					;mov	word ptr [lday], ax ; count of quadyrs (4 years)
 2536  53				push	bx
					;mov	word ptr [qday], bx ; days since quadyr began
 2537  83 FB 3C				cmp	bx, 31 + 29       ; if past feb 29 then
 253A  F5				cmc			  ; add this quadyr's leap day
 253B  83 D0 00				adc	ax, 0		  ; to # of qadyrs (leap days)
					;mov	word ptr [lday], ax ; since 1968			  
					;mov	cx, word ptr [iday]
 253E  91				xchg	cx, ax		  ; CX = lday, AX = iday		  
 253F  2B C1				sub	ax, cx		  ; iday - lday
 2541  B9 016D				mov	cx, 365
					;xor	dx, dx		  ; DX  = 0
					; AX = iday-lday, DX = 0
 2544  E8 0094				call	div32
					;mov	word ptr [iyrs], ax ; whole years since 1968
					; jday = iday - (iyrs*365) - lday
					;mov	word ptr [jday], bx ; days since 1/1 of current year
 2547  05 07B0				add	ax, 1968	  ; compute year
 254A  A3 26FC R			mov	word ptr [year], ax
 254D  8B D0				mov	dx, ax		
					;mov	ax, word ptr [qday]
 254F  58				pop	ax
 2550  3D 016D				cmp	ax, 365		  ; if qday <= 365 and qday >= 60	
 2553  77 07				ja	short @f	  ; jday = jday +1
 2555  83 F8 3C				cmp	ax, 60	          ; if past 2/29 and leap year then
 2558  F5			        cmc			  ; add a leap day to the # of whole
 2559  83 D3 00				adc	bx, 0		  ; days since 1/1 of current year
 255C				@@:			
					;mov	word ptr [jday], bx
 255C  B9 000C				mov	cx, 12		  ; estimate month
 255F  87 CB				xchg	cx, bx		  ; CX = jday, BX = month 	
 2561  B8 016E				mov	ax, 366		  ; mday, max. days since 1/1 is 365
 2564  83 E2 03				and	dx, 11b		  ; year mod 4	(and dx, 3) 
 2567				@@:	; Month calculation	  ; 0 to 11  (11 to 0)	
 2567  3B C8				cmp	cx, ax		  ; mday = # of days passed from 1/1
 2569  73 15				jnb	short @f
 256B  4B				dec	bx		  ; month = month - 1
 256C  D1 E3				shl	bx, 1 
 256E  8B 87 2704 R			mov	ax, word ptr DMonth[BX] ; # elapsed days at 1st of month
 2572  D1 EB				shr	bx, 1		  ; bx = month - 1 (0 to 11)
 2574  83 FB 01				cmp	bx, 1		  ; if month > 2 and year mod 4  = 0	
 2577  76 EE				jna	short @b	  ; then mday = mday + 1
 2579  0A D2				or	dl, dl		  ; if past 2/29 and leap year then
 257B  75 EA				jnz	short @b	  ; add leap day (to mday)
 257D  40				inc	ax		  ; mday = mday + 1
 257E  EB E7				jmp	short @b
 2580				@@:
 2580  43				inc	bx 		  ; -> bx = month, 1 to 12
					;mov	word ptr [month], bx
					; 02/06/2022
 2581  88 1E 26FE R			mov	byte ptr [month], bl
 2585  2B C8				sub	cx, ax		  ; day = jday - mday + 1
 2587  41				inc	cx
					;mov	word ptr [day], cx
					; 02/06/2022
 2588  88 0E 26FF R			mov	byte ptr [day], cl
					
					; ax, bx, cx, dx is changed at return
					; output ->
					; [year], [month], [day], [hour], [minute], [second]
					
 258C				_set_date:
					; 02/06/2022 (BugFix)
 258C  A1 26FC R			mov	ax, word ptr [year]
 258F  B5 20				mov	ch, 20h
 2591  2D 07D0				sub	ax, 2000
 2594  73 05				jnb	short set_date
 2596  B5 19				mov	ch, 19h
 2598  83 C0 64				add	ax, 100
					; 02/06/2022
					; 20/06/2013
 259B				set_date:
					;mov	al, byte ptr [Year]+1
					;aam ; ah = al / 10, al = al mod 10
					;db	0D5h,10h     ; Undocumented inst. AAD
					;		     ; AL = AH * 10h + AL
					;mov	ch, al ; century (BCD)
					;mov	al, byte ptr [Year]
					; (ax = 0 to 99)
 259B  D4 0A				aam ; ah = al / 10, al = al mod 10
 259D  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
 259F  8A C8				mov	cl, al ; year (BCD)
 25A1  A0 26FE R		        mov	al, byte ptr [Month]
 25A4  D4 0A				aam ; ah = al / 10, al = al mod 10
 25A6  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
 25A8  8A F0				mov	dh, al ; month (BCD)
 25AA  A0 26FF R			mov	al, byte ptr [Day]
 25AD  D4 0A				aam ; ah = al / 10, al = al mod 10
 25AF  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
					; 02/06/2022 (BugFix)
 25B1  8A D0				mov	dl, al ; day (BCD)

					; Set real-time clock date
 25B3  B4 05			        mov	ah, 05h
 25B5  CD 1A			        int	1Ah
					; retn
 25B7				set_time:
				        ; Read real-time clock time
 25B7  B4 02			        mov	ah, 02h
 25B9  CD 1A			        int	1Ah
					; DL = 1 or 0 (day light saving time)	
 25BB  A0 2700 R			mov	al, byte ptr [Hour]
 25BE  D4 0A				aam ; ah = al / 10, al = al mod 10
 25C0  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
 25C2  8A E8				mov	ch, al ; hour (BCD)
 25C4  A0 2701 R			mov	al, byte ptr [Minute]
 25C7  D4 0A				aam ; ah = al / 10, al = al mod 10
 25C9  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
 25CB  8A C8				mov	cl, al ; minute (BCD)
 25CD  A0 2702 R		        mov	al, byte ptr [Second]
 25D0  D4 0A				aam ; ah = al / 10, al = al mod 10
 25D2  D5 10				db	0D5h,10h     ; Undocumented inst. AAD
							     ; AL = AH * 10h + AL
 25D4  8A F0				mov	dh, al ; second (BCD)
					; Set real-time clock time
 25D6  B4 03			        mov	ah, 03h
 25D8  CD 1A			        int	1Ah
 25DA  C3				retn

 25DB				div32:
					; Input -> DX:AX = 32 bit dividend
					;          CX = 16 bit divisor
					; output -> DX:AX = 32 bit quotient
					;          BX = 16 bit remainder
 25DB  8B DA				mov	bx, dx
 25DD  93				xchg	ax, bx
 25DE  33 D2				xor	dx, dx
 25E0  F7 F1				div	cx    	; at first, divide DX
 25E2  93				xchg	ax, bx	; remainder is in DX
							; now, BX has quotient
							; save remainder
 25E3  F7 F1				div	cx	; so, DX_AX divided and
							; AX has quotient
							; DX has remainder
 25E5  87 D3				xchg	dx, bx	; finally, BX has remainder

 25E7  C3				retn

				;; 13/07/2013
 25E8 00			unixbootdrive: db 0
				;;
				; Following (data) section is derived from UNIX v1 'ux.s' file
				; 11/03/2013
				;
				align 2
				; 13/07/2013
				; 30/01/2022
				;sb0:	db 4 dup(0) ; Retro UNIX 8086 v1 modification !
				;systm:
				;;s:	db 218 dup(?)
				; 30/01/2022
				;s:	db 512 dup(0) ; Retro UNIX 8086 v1 modification !
				;;inode:
				;i:	db 32 dup(0)
				; 30/01/2022
				;sb1:	db 4 dup(0)    ; Retro UNIX 8086 v1 modification !
				;mount:	db 512 dup(0)  ; Retro UNIX 8086 v1 modification !
				;;mount: db 1024 dup(0)
				;inode:
 25EA  0020 [			i:	db 32 dup(0)
        00
       ]
				;
				;proc:
				;p:	db 9*nproc dup(0) ; 03/09/2013 
 260A  00A0 [			p:	db 10*nproc dup(0)
        00
       ]
				;tty:	db ntty*8 dup(0)
				; 30/01/2022
				;fsp:	db nfiles*8 dup(0)
 26AA  0014 [			bufp:	db ((nbuf*2)+4) dup(0) ; will be initialized (09/07/2013)
        00
       ]
				;bufp:	db ((nbuf*2)+6) dup(0)
				;;sb0:	db 8 dup(0)
				;sb0:	db 4 dup(0) ; Retro UNIX 8086 v1 modification !
				;;sb1:	db 8 dup(0)
				;sb1:	db 4 dup(0) ; Retro UNIX 8086 v1 modification !
				;swp:	db 8 dup(0)
				;;swp:	db 4 dup(0) ; Retro UNIX 8086 v1 modification ! 
 26BE 0000			ii:	dw 0
 26C0 0000			idev:	dw 0 ; device number is 1 byte in Retro UNIX 8086 v1 !
 26C2 0000			cdev:	dw 0 ; device number is 1 byte in Retro UNIX 8086 v1 !
				;;deverr: db 12 dup(0)
				;
				; 26/04/2013 device/drive parameters
				; Retro UNIX 8086 v1 feature only!
				; there are 8 available Retro UNIX devices
				;
				; 'UNIX' device numbers (as in 'cdev' and 'u.cdrv')
				;	0 -> root device (which has Retro UNIX 8086 v1 file system)
				; 	1 -> mounted device (which has Retro UNIX 8086 v1 file system)
				; 'Retro UNIX 8086 v1' device numbers: (for disk I/O procedures)
				;	0 -> fd0 (physical drive, floppy disk 1), physical drive number = 0
				;	1 -> fd1 (physical drive, floppy disk 2), physical drive number = 1
				;	2 -> hd0 (physical drive, hard disk 1), physical drive number = 80h
				;	3 -> hd1 (physical drive, hard disk 2), physical drive number = 81h
				;	4 -> hd2 (physical drive, hard disk 3), physical drive number = 82h
				;	5 -> hd3 (physical drive, hard disk 4), physical drive number = 83h
 26C4 00			rdev:	db 0 ; root device number ; Retro UNIX 8086 v1 feature only!
					     ; as above, for physical drives numbers in following table
 26C5 00			mdev:	db 0 ; mounted device number ; Retro UNIX 8086 v1 feature only!
				 	     ; as above, for physical drives numbers in following table
				; NOTE: the value of 'cdev' and 'u.drv' and 'idev' will be 0 or 1.
				;	0 is for rdev, 1 is for mdev

 26C6				drv: ; Retro UNIX 8086 v1 feature only!
 26C6				drverr:
 26C6  0006 [				db 6 dup(0FFh) ; error status (>0 means error) 	
        FF
       ]
 26CC				drvpdn:
 26CC  0006 [				db 6 dup(0FFh) ; physical drive number (FFh = invalid drive)
        FF
       ]
 26D2				drvspt:	
 26D2  0006 [				dw 6 dup(0)    ; sectors per track
        0000
       ]
 26DE				drvhds:  	 
 26DE  0006 [				dw 6 dup(0)    ; number of heads
        0000
       ]
				;active: dw 0
				; 15/07/2022
				;active: db 0 ; 15/03/2013
 26EA 00			brwdev: db 0 ; 26/04/2013 Retro UNIX 8086 v1 feature only !
 26EB  00				db 0 ; (for word alignment) ; 15/07/2022

				;rfap:	dw 0
				;rkap:	dw 0
				;tcap:	dw 0
				;tcstate: dw 0
				;tcerrc: dw 0
 26EC 0000			mnti:	dw 0
				;mntd:	dw 0 ; device number is 1 byte in Retro UNIX 8086 v1 !
 26EE 0000			mpid:	dw 0
				;clockp: dw 0
 26F0 0000			rootdir: dw 0
				;toutt:	db 16 dup(0)
				;touts: db 32 dup(0)
				;runq:	db 6 dup (0)
				; 14/02/2014
				; Major Modification: Retro UNIX 8086 v1 feature only!
				;		      Single level run queue
				;		      (in order to solve sleep/wakeup lock)
 26F2 0000			runq:	dw 0	


				;wlist:	db 40 dup(0)
				;cc:	db 30 dup(0)
				;cf:	db 31 dup(0)
				;cl_:	db 31 dup(0) ; cl
				;clist:	db 510 dup(0)

 26F4 00			imod: 	db 0 
 26F5 00			smod: 	db 0
 26F6 00			mmod: 	db 0
				;uquant: db 0  ; 14/02/2014 --> u.quant
 26F7 00			sysflg: db 0
				;pptiflg:db 0
				;ttyoch: db 0

				align 2

				; Retro Unix 8086 v1 features only !  
				; 31/07/2013
				; 07/04/2013 
 26F8 00			rw: db 0 ;; Read/Write sign 
				;; 07/08/2013 (reset in error routine)
				;; mov word ptr [namei_r], 0 -> namei_r = 0,  mkdir_w = 0
				; 26/07/2013
 26F9 00			namei_r: db 0 ; the caller is 'namei' sign for 'dskr' (ES=CS)
				; 01/08/2013
 26FA 00			mkdir_w: db 0 ; the caller is 'mkdir' sign for 'dskw' (ES=CS)
				;

				align 2

				; 09/04/2013 epoch variables
				; Retro UNIX 8086 v1 Prototype: UNIXCOPY.ASM, 10/03/2013
				;

 26FC 07B2			year:	dw 1970
				;month: dw 1
				;day:	dw 1
				;hour:	dw 0
				;minute: dw 0
				;second: dw 0
				; 02/06/2022
 26FE 01			month:	db 1
 26FF 01			day:	db 1
 2700 00			hour:	db 0
 2701 00			minute: db 0
 2702 00			second: db 0
 2703  00				db 0

 2704				DMonth:
 2704  0000			dw 0
 2706  001F			dw 31
 2708  003B			dw 59
 270A  005A			dw 90
 270C  0078			dw 120
 270E  0097			dw 151
 2710  00B5			dw 181
 2712  00D4			dw 212
 2714  00F3			dw 243
 2716  0111			dw 273
 2718  0130			dw 304
 271A  014E			dw 334

				; 10/05/2013
				; Retro UNIX 8086 v1 feature only !
 271C				int09h: ; BIOS INT 09h handler (original)
 271C  0000				dw 0 ; offset
 271E  0000				dw 0 ; segment

				; 03/06/2013
 2720 00000000			p_time: dd 0 ; present time (for systime & sysmdate)

				; 04/12/2013  ('putc', 'write_tty' in U9.ASM)
 2724 0000			crt_start: dw 0	; starting address in regen buffer
						; NOTE: active page only		 	
 2726  0008 [			cursor_posn: dw 8 dup(0) ; cursor positions for video pages
        0000
       ]

				; 04/12/2013
 2736				active_page: ; = ptty  ('putc', 'write_tty' in U9.ASM)
				; 10/05/2013
				; Retro UNIX 8086 v1 feature only !
 2736 00			ptty: db 0 ; current tty
				;nxtty: db 0 ; next tty (will be switched to)
				; 16/07/2013
				;getctty: db 0 ; for using in 'getc' routine
				; 12/08/2013
				;AltKeyDown: db 0 ; INT 09h

				align 2

				; 03/03/2014
				; Derived from IBM "pc-at" 
					; rombios source code (06/10/1985)
					;	 'dseg.inc'

				;---------------------------------------;
				;	SYSTEM DATA AREA		;
				;----------------------------------------
 2738 00			BIOS_BREAK	db	0		; BIT 7=1 IF BREAK KEY HAS BEEN PRESSED

				;----------------------------------------
				;	KEYBOARD DATA AREAS		;
				;----------------------------------------

 2739 00			KB_FLAG		db	0		; KEYBOARD SHIFT STATE AND STATUS FLAGS
 273A 00			KB_FLAG_1	db	0		; SECOND BYTE OF KEYBOARD STATUS
 273B 00			KB_FLAG_2	db	0		; KEYBOARD LED FLAGS
 273C 00			KB_FLAG_3	db	0		; KEYBOARD MODE STATE AND TYPE FLAGS
 273D 00			ALT_INPUT	db	0		; STORAGE FOR ALTERNATE KEY PAD ENTRY
 273E 2746 R			BUFFER_START	dW	offset KB_BUFFER ; OFFSET OF KEYBOARD BUFFER START
 2740 2766 R			BUFFER_END	dW	offset KB_BUFFER + 32 ; OFFSET OF END OF BUFFER
 2742 2746 R			BUFFER_HEAD	dw	offset KB_BUFFER ; POINTER TO HEAD OF KEYBOARD BUFFER
 2744 2746 R			BUFFER_TAIL	dw	offset KB_BUFFER ; POINTER TO TAIL OF KEYBOARD BUFFER
				; ------	HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY
 2746  0010 [			KB_BUFFER	dw	16 DUP (0)	; ROOM FOR 15 SCAN CODE ENTRIES
        0000
       ]
				;

				;align 2

				; 26/01/2014 'ttyl' lock table instead of 'ttyr' and 'ttyw'
				;
				; 16/08/2013 'ttypt' owner table -> 'ttyr', 'ttyw' lock table
				; byte ptr [BX]+ttyl = owner/lock for read/write 
				;		(process number = locked, 0 = unlocked/free)
				; byte ptr [BX]+ttyr+1 = count of open for read&write
				;		(0 = free, >0 = in use)
				;
				;; Retro UNIX 8086 v1 feature only!
				;;
				;; (26/01/2014)
				;; (13/01/2014)
				;; 06/12/2013
				;; <<<Major modification on TTY procedures>>>
				;; 
				; Console TTY for process :
				;   'sys fork' system call sets/copies parent process's 
				;   console TTY number as child process's console TTY number. 
				;   It is a zero based number (0 to 9) which is hold in 'p.ttyc'.
				;   Console TTY setting can be changed by 'sys stty' system call.
				; Recent TTY for process:
				;   Recent TTY number during the last TTY read/write routine
				;   by process. 'u.ttyp' (word pointer) is used for that purpose.
				;   TTY num. of the last TTY Read is stored in low byte of 'u.ttyp'.
				;   TTY num. of the last TTY write is stored in high byte of 'u.ttyp.
				;
				; TTY 'Open' conditions: (06/12/2013 <--- 16/08/2013)
				;     1) A process can open a free/unlocked tty or a tty
				;	 which is locked by it or it's parent process. (13/01/2014)
				;	 (Open count is increased by 1 while a new instance of 
				;	 tty is being open.)
				;     2) The caller/process locks a tty if it is unlocked/free.
				;     3) TTY open procedure sets 'u.ttyp' to related tty number + 1.
				;	 Open for read procedure sets the low byte and open for 
				;	 write procedure sets the high byte. 
				;	 NOTE: TTY read and write procedures change these recent tty
				;	 (u.ttyp) values. (06/12/2013)
				;
				; TTY 'close' conditions: (16/08/2013)
				;     1) A tty is unlocked if it's open count becomes zero while
				;	 closing it. (26/01/2014)  
				;	 (Open count is decreased by 1 when the instance of 
				;	 tty is closed.)
				;     2) TTY close procedure resets low byte or high byte of
				;	 'u.ttyp' if it was set to related tty number + 1. 
				;	 Open for read procedure resets the low byte and open
				;	 for write procedure resets the high byte. (06/12/2013)
				;
				; NOTE: 'tty' functionality of 'Retro UNIX 8086 v1' is almost
				;	different than original UNIX v1 (also v1 to recent 
				;	unix sys v versions). Above logic/methods is/are 
				;	developed by Erdogan Tan, for keeping 'multi screen',
				; 	'multi tasking' ability of 'Retro UNIX 8086 v1' (tty and 
				;	process switching by 'ALT + Function keys' and
				;	for ensuring proper/stable process separation between
				;	pseudo TTYs and serial ports).	  
				;	   	

				; 09/07/2014 (tty8, tty9)
				; 24/09/2013 (tty0 to tty7)
 2766				ttychr: ; (0 to 9)
 2766  000A [			    dw ntty+2 dup(0) ; ascii (lb) & scan code (hb) of keys
        0000
       ]
						   ; per every pseudo tty (video page)
				; 26/01/2014 'ttyl' lock table instead of 'ttyr' and 'ttyw'
				; 13/01/2014 (COM1 & COM2 have been added to pseudo TTYs)
				; (ntty -> ntty + 2)
				; 16/08/2013 (open mode locks for pseudo TTYs)
				; [ major tty locks (return error in any conflicts) ]
 277A				ttyl: ; Retro UNIX 8086 v1 feature only !
 277A  000A [			    dw ntty+2 dup(0) ; opening locks for TTYs.
        0000
       ]
				; 22/09/2013
 278E  000A [			wlist: db ntty+2 dup(0) ; wait channel list (0 to 9 for TTYs)
        00
       ]
				; 27/07/2014
 2798 0000			tsleep: dw 0 ; Transmit sleep sign for port processes 
					     ; which use serial ports (COM1, COM2) as tty.	 

				;; 16/07/2013
				;; tty (keyboard) process/owner table (ttypt)
				;ttypt: db ntty*2 dup(0)		

				;; 12/07/2014 -> communication status data is not needed here
				;	        <cancel>
				; 16/07/2013
				; 21/05/2013
				;;com_stat: 
				; 13/01/2014
				;;com1_stat:
				;;	  db 0 ; COM1 line status
				;;	  db 0 ; COM1 modem status		
				;;com2_stat:	  
				;;	  db 0 ; COM2 line status
				;;	  db 0 ; COM2 modem status

				; 16/08/2013
				; Communication parameters for serial ports
				; Retro UNIX 8086 v1 default: 
				;;    11100011b ; E3h
				   ;; (111) Baud rate: 9600, (00) parity: none,
				   ;; (0) stop bits: 1, (11) word length: 8 bits
				;
				; NOTE: Default value (E3h) will be set again
				; after an initalization error, even if 'sys stty'
				; system call changes the value before 
				; an initialization error in tty 'open' routine.
				; (Serial port initialization is performed 
				; when a tty 'open' routine runs for 
				; COM1 or COM2 while the tty is free/closed.)  

				;; 12/07/2014 -> sp_init set comm. parameters as 0E3h
				;; 0 means serial port is not available 
				;;comprm: ; 25/06/2014
 279A 00			com1p: db 0  ;;0E3h
 279B 00			com2p: db 0  ;;0E3h
				 	
				;Buffer:
					;db ntty*140 dup(0)
					;db nbuf*520 dup(0)

				align 8
 27A0  00000000			dd 0
				; 30/01/2022
				;Buffer: ; Retro UNIX 8086 v1 modification !	
				;	db nbuf*516 dup(0)
				;user:
 27A4  0040 [			u: db 64 dup (0)  ; (Original Unix v1 'user' structure has 62 bytes)
        00
       ]

				; 14/07/2013
 27E4				kernel_init_err_msg:
 27E4  0D 0A				db 0Dh, 0Ah
 27E6  07				db 07h
 27E7  4B 65 72 6E 65 6C		db 'Kernel initialization ERROR !'
       20 69 6E 69 74 69
       61 6C 69 7A 61 74
       69 6F 6E 20 45 52
       52 4F 52 20 21
 2804  0D 0A 00				db 0Dh, 0Ah, 0 
 2807				kernel_init_ok_msg: 
 2807  07				db 07h
 2808  57 65 6C 63 6F 6D		db 'Welcome to Retro UNIX 8086 v1 Operating System !'
       65 20 74 6F 20 52
       65 74 72 6F 20 55
       4E 49 58 20 38 30
       38 36 20 76 31 20
       4F 70 65 72 61 74
       69 6E 67 20 53 79
       73 74 65 6D 20 21
 2838  0D 0A				db 0Dh, 0Ah
 283A  62 79 20 45 72 64	        db 'by Erdogan Tan - 19/07/2022'
       6F 67 61 6E 20 54
       61 6E 20 2D 20 31
       39 2F 30 37 2F 32
       30 32 32
					;db 'by Erdogan Tan - 16/07/2015'
 2855  0D 0A 00				db 0Dh, 0Ah, 0
 2858				panic_msg:
 2858  0D 0A 07				db 0Dh, 0Ah, 07h
 285B  45 52 52 4F 52 3A		db 'ERROR: Kernel Panic !'
       20 4B 65 72 6E 65
       6C 20 50 61 6E 69
       63 20 21
 2870  0D 0A 00				db 0Dh, 0Ah, 0
 2873				etc_init_err_msg:
 2873  0D 0A				db 0Dh, 0Ah
 2875  07				db 07h
 2876  45 52 52 4F 52 3A		db 'ERROR: /etc/init !?'
       20 2F 65 74 63 2F
       69 6E 69 74 20 21
       3F
 2889  0D 0A 00				db 0Dh, 0Ah, 0

				; 30/01/2022
 288C 07			color:	db 07h ; sysstty color setting 	

				; 30/01/2022
				;int1Ch: dw 2022
				;	 dw 417

				align 2

				; 11/05/2022
 288E 0000			mntp:	dw 0 ; parent dir inumber of [mnti]

				; sstack:
				;	db 256 dup(0)

				; 10/12/2013
				; 'Enable Multi Tasking' system call (sys emt)
				; (time-out enabling/disabling functionality)
				; has been added to Retro UNIX 8086 v1 Kernel (in U1.ASM)

				; 30/01/2022	
 2890 = 2892			SizeOfFile equ $+2	

 2890  2892 R				dw SizeOfFile

				; 30/01/2022	
				;SizeOfFile equ $
				;; 08/03/2014 (system systack size = 256 - 64)
				;sstack	equ SizeOfFile + 256 - 64
				;;sstack equ SizeOfFile + 256 ; 24/07/2013
				               
 2892				UNIX	ends

				        end  START
Microsoft (R) Macro Assembler Version 6.14.8444		    07/19/22 20:22:34
unix.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

sys  . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

inode  . . . . . . . . . . . . .	 0020
  flgs . . . . . . . . . . . . .	 0000	     Word
  nlks . . . . . . . . . . . . .	 0002	     Byte
  uid  . . . . . . . . . . . . .	 0003	     Byte
  size_  . . . . . . . . . . . .	 0004	     Word
  dskp . . . . . . . . . . . . .	 0006	     Word
  ctim . . . . . . . . . . . . .	 0016	     DWord
  mtim . . . . . . . . . . . . .	 001A	     DWord
  rsvd . . . . . . . . . . . . .	 001E	     Word
phydrv . . . . . . . . . . . . .	 0024
  err  . . . . . . . . . . . . .	 0000	     Byte
  pdn  . . . . . . . . . . . . .	 0006	     Byte
  spt  . . . . . . . . . . . . .	 000C	     Word
  hds  . . . . . . . . . . . . .	 0018	     Word
process  . . . . . . . . . . . .	 00A0
  pid  . . . . . . . . . . . . .	 0000	     Word
  ppid . . . . . . . . . . . . .	 0020	     Word
  break  . . . . . . . . . . . .	 0040	     Word
  ttyc . . . . . . . . . . . . .	 0060	     Byte
  waitc  . . . . . . . . . . . .	 0070	     Byte
  link . . . . . . . . . . . . .	 0080	     Byte
  stat . . . . . . . . . . . . .	 0090	     Byte
superblock . . . . . . . . . . .	 01A2
  time . . . . . . . . . . . . .	 018C	     DWord
  syst . . . . . . . . . . . . .	 0190	     DWord
  wait_  . . . . . . . . . . . .	 0194	     DWord
  idlet  . . . . . . . . . . . .	 0198	     DWord
  chrgt  . . . . . . . . . . . .	 019C	     DWord
  drerr  . . . . . . . . . . . .	 01A0	     Word
user . . . . . . . . . . . . . .	 0040
  sp_  . . . . . . . . . . . . .	 0000	     Word
  usp  . . . . . . . . . . . . .	 0002	     Word
  r0 . . . . . . . . . . . . . .	 0004	     Word
  cdir . . . . . . . . . . . . .	 0006	     Word
  fp . . . . . . . . . . . . . .	 0008	     Byte
  fofp . . . . . . . . . . . . .	 0012	     Word
  dirp . . . . . . . . . . . . .	 0014	     Word
  namep  . . . . . . . . . . . .	 0016	     Word
  off  . . . . . . . . . . . . .	 0018	     Word
  base . . . . . . . . . . . . .	 001A	     Word
  count  . . . . . . . . . . . .	 001C	     Word
  nread  . . . . . . . . . . . .	 001E	     Word
  break_ . . . . . . . . . . . .	 0020	     Word
  ttyp . . . . . . . . . . . . .	 0022	     Word
  dirbuf . . . . . . . . . . . .	 0024	     Byte
  quant  . . . . . . . . . . . .	 002E	     Byte
  pri  . . . . . . . . . . . . .	 002F	     Byte
  intr . . . . . . . . . . . . .	 0030	     Word
  quit . . . . . . . . . . . . .	 0032	     Word
  ilgins . . . . . . . . . . . .	 0034	     Word
  cdrv . . . . . . . . . . . . .	 0036	     Word
  uid_ . . . . . . . . . . . . .	 0038	     Byte
  ruid . . . . . . . . . . . . .	 0039	     Byte
  bsys . . . . . . . . . . . . .	 003A	     Byte
  uno  . . . . . . . . . . . . .	 003B	     Byte
  segmnt . . . . . . . . . . . .	 003C	     Word
  ttyn . . . . . . . . . . . . .	 003E	     Byte
  errn . . . . . . . . . . . . .	 003F	     Byte


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

UNIX . . . . . . . . . . . . . .	16 Bit	 2892	  Para	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

ACKSTATUS  . . . . . . . . . . .	Number	 0040h	 
ALT_INPUT  . . . . . . . . . . .	Byte	 273D	  UNIX	
ALT_KEY  . . . . . . . . . . . .	Number	 0038h	 
ALT_SHIFT  . . . . . . . . . . .	Number	 0008h	 
BIOS_BREAK . . . . . . . . . . .	Byte	 2738	  UNIX	
BIOS_DSEGM . . . . . . . . . . .	Number	 0040h	 
BSSEND . . . . . . . . . . . . .	Text   	 Buffer+(nbuf*516)
BSSSIZE  . . . . . . . . . . . .	Text   	 BSSEND-BSSSTART
BSSSTART . . . . . . . . . . . .	Text   	 SizeOfFile
BUFFER_END . . . . . . . . . . .	Word	 2740	  UNIX	
BUFFER_HEAD  . . . . . . . . . .	Word	 2742	  UNIX	
BUFFER_START . . . . . . . . . .	Word	 273E	  UNIX	
BUFFER_TAIL  . . . . . . . . . .	Word	 2744	  UNIX	
Buffer . . . . . . . . . . . . .	Text   	 mount+512
CAPS_KEY . . . . . . . . . . . .	Number	 003Ah	 
CAPS_SHIFT . . . . . . . . . . .	Number	 0040h	 
CAPS_STATE . . . . . . . . . . .	Number	 0040h	 
CRT_MODE_SET . . . . . . . . . .	Number	 0065h	 
CRT_MODE . . . . . . . . . . . .	Number	 0049h	 
CTL_KEY  . . . . . . . . . . . .	Number	 001Dh	 
CTL_SHIFT  . . . . . . . . . . .	Number	 0004h	 
DEL_KEY  . . . . . . . . . . . .	Number	 0053h	 
DEL_M  . . . . . . . . . . . . .	Number	 0053h	 
DIS_KBD  . . . . . . . . . . . .	Number	 00ADh	 
DMonth . . . . . . . . . . . . .	L Near	 2704	  UNIX	
DN_M . . . . . . . . . . . . . .	Number	 0050h	 
ENA_KBD  . . . . . . . . . . . .	Number	 00AEh	 
END_M  . . . . . . . . . . . . .	Number	 004Fh	 
EOI  . . . . . . . . . . . . . .	Number	 0020h	 
F11_B  . . . . . . . . . . . . .	Number	 00D7h	 
F11_M  . . . . . . . . . . . . .	Number	 00D9h	 
F12_B  . . . . . . . . . . . . .	Number	 00D8h	 
F12_M  . . . . . . . . . . . . .	Number	 00DAh	 
FUNC11 . . . . . . . . . . . . .	Number	 0085h	 
GATE2  . . . . . . . . . . . . .	Number	 0001h	 
GRAPH_ON . . . . . . . . . . . .	Number	 0004h	 
HC . . . . . . . . . . . . . . .	Number	 00E0h	 
HOLD_STATE . . . . . . . . . . .	Number	 0008h	 
HOME_M . . . . . . . . . . . . .	Number	 0047h	 
ID_1 . . . . . . . . . . . . . .	Number	 00ABh	 
ID_2 . . . . . . . . . . . . . .	Number	 0041h	 
INPT_BUF_FULL  . . . . . . . . .	Number	 0002h	 
INS_KEY  . . . . . . . . . . . .	Number	 0052h	 
INS_M  . . . . . . . . . . . . .	Number	 0052h	 
INS_SHIFT  . . . . . . . . . . .	Number	 0080h	 
INS_STATE  . . . . . . . . . . .	Number	 0080h	 
INTA00 . . . . . . . . . . . . .	Number	 0020h	 
IOERRSTATUS  . . . . . . . . . .	Number	 0008h	 
K102_B . . . . . . . . . . . . .	Number	 00D6h	 
K102_M . . . . . . . . . . . . .	Number	 0056h	 
K10  . . . . . . . . . . . . . .	L Near	 233F	  UNIX	
K11  . . . . . . . . . . . . . .	L Near	 2378	  UNIX	
K12  . . . . . . . . . . . . . .	L Near	 23B2	  UNIX	
K13  . . . . . . . . . . . . . .	L Near	 23BC	  UNIX	
K14  . . . . . . . . . . . . . .	L Near	 23C6	  UNIX	
K15  . . . . . . . . . . . . . .	L Near	 23D3	  UNIX	
K30  . . . . . . . . . . . . . .	L Near	 23EA	  UNIX	
K6L  . . . . . . . . . . . . . .	Number	 0008h	 
K6 . . . . . . . . . . . . . . .	L Near	 22DC	  UNIX	
K7 . . . . . . . . . . . . . . .	L Near	 22E4	  UNIX	
K8 . . . . . . . . . . . . . . .	L Near	 22EC	  UNIX	
K9 . . . . . . . . . . . . . . .	L Near	 2326	  UNIX	
KBX  . . . . . . . . . . . . . .	Number	 0001h	 
KB_ACK . . . . . . . . . . . . .	Number	 00FAh	 
KB_BUFFER  . . . . . . . . . . .	Word	 2746	  UNIX	
KB_ENABLE  . . . . . . . . . . .	Number	 00F4h	 
KB_ERR . . . . . . . . . . . . .	Number	 0080h	 
KB_FA  . . . . . . . . . . . . .	Number	 0010h	 
KB_FE  . . . . . . . . . . . . .	Number	 0020h	 
KB_FLAG_1  . . . . . . . . . . .	Byte	 273A	  UNIX	
KB_FLAG_2  . . . . . . . . . . .	Byte	 273B	  UNIX	
KB_FLAG_3  . . . . . . . . . . .	Byte	 273C	  UNIX	
KB_FLAG  . . . . . . . . . . . .	Byte	 2739	  UNIX	
KB_LEDS  . . . . . . . . . . . .	Number	 0007h	 
KB_OVER_RUN  . . . . . . . . . .	Number	 00FFh	 
KB_PR_LED  . . . . . . . . . . .	Number	 0040h	 
KB_RESEND  . . . . . . . . . . .	Number	 00FEh	 
K_TAB1 . . . . . . . . . . . . .	L Near	 23E0	  UNIX	
LC_AB  . . . . . . . . . . . . .	Number	 0040h	 
LC_HC  . . . . . . . . . . . . .	Number	 0002h	 
LED_CMD  . . . . . . . . . . . .	Number	 00EDh	 
LEFT_KEY . . . . . . . . . . . .	Number	 002Ah	 
LEFT_M . . . . . . . . . . . . .	Number	 004Bh	 
LEFT_SHIFT . . . . . . . . . . .	Number	 0002h	 
L_TAB1 . . . . . . . . . . . . .	Number	 000Ah	 
NOPAPERSTATUS  . . . . . . . . .	Number	 0020h	 
NOTBUSYSTATUS  . . . . . . . . .	Number	 0080h	 
NUM_KEY  . . . . . . . . . . . .	Number	 0045h	 
NUM_SHIFT  . . . . . . . . . . .	Number	 0020h	 
NUM_STATE  . . . . . . . . . . .	Number	 0020h	 
PGDN_M . . . . . . . . . . . . .	Number	 0051h	 
PGUP_M . . . . . . . . . . . . .	Number	 0049h	 
PORT_A . . . . . . . . . . . . .	Number	 0060h	 
PORT_B . . . . . . . . . . . . .	Number	 0061h	 
PRN$LOOP . . . . . . . . . . . .	L Near	 1485	  UNIX	
PRN$OUT  . . . . . . . . . . . .	L Near	 148C	  UNIX	
PRN$STAT . . . . . . . . . . . .	L Near	 14AF	  UNIX	
PRN$WRIT . . . . . . . . . . . .	L Near	 1485	  UNIX	
PRNOP2 . . . . . . . . . . . . .	L Near	 14CB	  UNIX	
PRNOP  . . . . . . . . . . . . .	L Near	 14BF	  UNIX	
PRNSTAT  . . . . . . . . . . . .	L Near	 14BD	  UNIX	
PrRetry  . . . . . . . . . . . .	L Near	 1493	  UNIX	
RD_ID  . . . . . . . . . . . . .	Number	 0080h	 
REFRESH_BIT  . . . . . . . . . .	Number	 0010h	 
RESERVED . . . . . . . . . . . .	Number	 0006h	 
RESET_FLAG . . . . . . . . . . .	Number	 0072h	 
RHRZ . . . . . . . . . . . . . .	Number	 0001h	 
RIGHT_KEY  . . . . . . . . . . .	Number	 0036h	 
RIGHT_M  . . . . . . . . . . . .	Number	 004Dh	 
RIGHT_SHIFT  . . . . . . . . . .	Number	 0001h	 
RVRT . . . . . . . . . . . . . .	Number	 0008h	 
SCROLL_KEY . . . . . . . . . . .	Number	 0046h	 
SCROLL_SHIFT . . . . . . . . . .	Number	 0010h	 
SCROLL_STATE . . . . . . . . . .	Number	 0010h	 
SELECTEDSTATUS . . . . . . . . .	Number	 0010h	 
SET_NUM_LK . . . . . . . . . . .	Number	 0020h	 
SPK2 . . . . . . . . . . . . . .	Number	 0002h	 
START  . . . . . . . . . . . . .	L Near	 0000	  UNIX	
STATUS_PORT  . . . . . . . . . .	Number	 0064h	 
SYS_KEY  . . . . . . . . . . . .	Number	 0054h	 
SYS_SHIFT  . . . . . . . . . . .	Number	 0004h	 
SizeOfFile . . . . . . . . . . .	Number	 2892h	 
TIMEOUTSTATUS  . . . . . . . . .	Number	 0001h	 
TIMER  . . . . . . . . . . . . .	Number	 0040h	 
UP_M . . . . . . . . . . . . . .	Number	 0048h	 
_break . . . . . . . . . . . . .	Number	 0011h	 
_chdir . . . . . . . . . . . . .	Number	 000Ch	 
_chmod . . . . . . . . . . . . .	Number	 000Fh	 
_chown . . . . . . . . . . . . .	Number	 0010h	 
_close . . . . . . . . . . . . .	Number	 0006h	 
_creat . . . . . . . . . . . . .	Number	 0008h	 
_emt . . . . . . . . . . . . . .	Number	 001Dh	 
_exec  . . . . . . . . . . . . .	Number	 000Bh	 
_exit  . . . . . . . . . . . . .	Number	 0001h	 
_fork  . . . . . . . . . . . . .	Number	 0002h	 
_fstat . . . . . . . . . . . . .	Number	 001Ch	 
_getuid  . . . . . . . . . . . .	Number	 0018h	 
_gtty  . . . . . . . . . . . . .	Number	 0020h	 
_ilgins  . . . . . . . . . . . .	Number	 0021h	 
_intr  . . . . . . . . . . . . .	Number	 001Bh	 
_link  . . . . . . . . . . . . .	Number	 0009h	 
_mdate . . . . . . . . . . . . .	Number	 001Eh	 
_mkdir . . . . . . . . . . . . .	Number	 000Eh	 
_mount . . . . . . . . . . . . .	Number	 0015h	 
_open  . . . . . . . . . . . . .	Number	 0005h	 
_quit  . . . . . . . . . . . . .	Number	 001Ah	 
_read  . . . . . . . . . . . . .	Number	 0003h	 
_rele  . . . . . . . . . . . . .	Number	 0000h	 
_seek  . . . . . . . . . . . . .	Number	 0013h	 
_set_date  . . . . . . . . . . .	L Near	 258C	  UNIX	
_setuid  . . . . . . . . . . . .	Number	 0017h	 
_sleep . . . . . . . . . . . . .	Number	 0022h	 
_stat  . . . . . . . . . . . . .	Number	 0012h	 
_stime . . . . . . . . . . . . .	Number	 0019h	 
_stty  . . . . . . . . . . . . .	Number	 001Fh	 
_tell  . . . . . . . . . . . . .	Number	 0014h	 
_time  . . . . . . . . . . . . .	Number	 000Dh	 
_umount  . . . . . . . . . . . .	Number	 0016h	 
_unlink  . . . . . . . . . . . .	Number	 000Ah	 
_wait  . . . . . . . . . . . . .	Number	 0007h	 
_write . . . . . . . . . . . . .	Number	 0004h	 
access_1 . . . . . . . . . . . .	L Near	 123F	  UNIX	
access_2 . . . . . . . . . . . .	L Near	 124A	  UNIX	
access . . . . . . . . . . . . .	L Near	 1228	  UNIX	
active_page  . . . . . . . . . .	L Near	 2736	  UNIX	
alloc_1  . . . . . . . . . . . .	L Near	 1118	  UNIX	
alloc_2  . . . . . . . . . . . .	L Near	 1124	  UNIX	
alloc_3  . . . . . . . . . . . .	L Near	 1136	  UNIX	
alloc_4  . . . . . . . . . . . .	L Near	 113D	  UNIX	
alloc_5  . . . . . . . . . . . .	L Near	 114C	  UNIX	
alloc_6  . . . . . . . . . . . .	L Near	 1159	  UNIX	
alloc_free_3 . . . . . . . . . .	L Near	 115E	  UNIX	
alloc_free_4 . . . . . . . . . .	L Near	 1174	  UNIX	
alloc_free_5 . . . . . . . . . .	L Near	 1185	  UNIX	
alloc  . . . . . . . . . . . . .	L Near	 110A	  UNIX	
anyi_1 . . . . . . . . . . . . .	L Near	 0EBD	  UNIX	
anyi_2 . . . . . . . . . . . . .	L Near	 0EE8	  UNIX	
anyi . . . . . . . . . . . . . .	L Near	 0EBA	  UNIX	
badsys_1 . . . . . . . . . . . .	L Near	 03E7	  UNIX	
badsys_2 . . . . . . . . . . . .	L Near	 03F0	  UNIX	
badsys_msg . . . . . . . . . . .	L Near	 03CC	  UNIX	
badsys . . . . . . . . . . . . .	L Near	 0376	  UNIX	
beeper . . . . . . . . . . . . .	L Near	 1C07	  UNIX	
beep . . . . . . . . . . . . . .	L Near	 1C13	  UNIX	
bf_init  . . . . . . . . . . . .	L Near	 1AA0	  UNIX	
bread0 . . . . . . . . . . . . .	L Near	 1849	  UNIX	
bread1 . . . . . . . . . . . . .	L Near	 184D	  UNIX	
bread  . . . . . . . . . . . . .	L Near	 1842	  UNIX	
brwdev . . . . . . . . . . . . .	L Near	 26EA	  UNIX	
bs . . . . . . . . . . . . . . .	L Near	 1BC1	  UNIX	
bufaloc_0  . . . . . . . . . . .	L Near	 1950	  UNIX	
bufaloc_1  . . . . . . . . . . .	L Near	 1962	  UNIX	
bufaloc_2  . . . . . . . . . . .	L Near	 1965	  UNIX	
bufaloc_3  . . . . . . . . . . .	L Near	 1973	  UNIX	
bufaloc_4  . . . . . . . . . . .	L Near	 197F	  UNIX	
bufaloc_5  . . . . . . . . . . .	L Near	 1990	  UNIX	
bufaloc_6  . . . . . . . . . . .	L Near	 1990	  UNIX	
bufaloc_7  . . . . . . . . . . .	L Near	 1999	  UNIX	
bufaloc_8  . . . . . . . . . . .	L Near	 19A9	  UNIX	
bufaloc_9  . . . . . . . . . . .	L Near	 1981	  UNIX	
bufaloc  . . . . . . . . . . . .	L Near	 1945	  UNIX	
bufp . . . . . . . . . . . . . .	L Near	 26AA	  UNIX	
bwrite0  . . . . . . . . . . . .	L Near	 1890	  UNIX	
bwrite1  . . . . . . . . . . . .	L Near	 1894	  UNIX	
bwrite . . . . . . . . . . . . .	L Near	 1889	  UNIX	
bwslot_0 . . . . . . . . . . . .	L Near	 18FE	  UNIX	
bwslot_1 . . . . . . . . . . . .	L Near	 190C	  UNIX	
bwslot . . . . . . . . . . . . .	L Near	 18F9	  UNIX	
cbrk1  . . . . . . . . . . . . .	L Near	 011D	  UNIX	
cbrk2  . . . . . . . . . . . . .	L Near	 0138	  UNIX	
cbrk3  . . . . . . . . . . . . .	L Near	 0144	  UNIX	
cbrk4  . . . . . . . . . . . . .	L Near	 0146	  UNIX	
ccvt . . . . . . . . . . . . . .	L Near	 17E2	  UNIX	
cdev . . . . . . . . . . . . . .	L Near	 26C2	  UNIX	
clear  . . . . . . . . . . . . .	L Near	 0FB3	  UNIX	
clk_0  . . . . . . . . . . . . .	L Near	 0FE5	  UNIX	
clk_1  . . . . . . . . . . . . .	L Near	 1009	  UNIX	
clk_2  . . . . . . . . . . . . .	L Near	 100D	  UNIX	
clock  . . . . . . . . . . . . .	L Near	 0FC6	  UNIX	
clr_all_vps  . . . . . . . . . .	L Near	 0076	  UNIX	
color  . . . . . . . . . . . . .	L Near	 288C	  UNIX	
com1_int . . . . . . . . . . . .	L Near	 01AC	  UNIX	
com1p_eirq . . . . . . . . . . .	L Near	 1747	  UNIX	
com1p  . . . . . . . . . . . . .	L Near	 279A	  UNIX	
com2_int . . . . . . . . . . . .	L Near	 01A2	  UNIX	
com2p  . . . . . . . . . . . . .	L Near	 279B	  UNIX	
com_eoi  . . . . . . . . . . . .	L Near	 01EB	  UNIX	
com_iret . . . . . . . . . . . .	L Near	 01F3	  UNIX	
com_port_init_xor  . . . . . . .	L Near	 171C	  UNIX	
com_port_init  . . . . . . . . .	L Near	 171E	  UNIX	
com_rdei . . . . . . . . . . . .	L Near	 01D5	  UNIX	
comp_get_stat  . . . . . . . . .	L Near	 175D	  UNIX	
comp_init_ok . . . . . . . . . .	L Near	 1775	  UNIX	
convert_from_epoch . . . . . . .	L Near	 2511	  UNIX	
convert_to_epoch . . . . . . . .	L Near	 247D	  UNIX	
core . . . . . . . . . . . . . .	Number	 0000h	 
cpass  . . . . . . . . . . . . .	L Near	 1536	  UNIX	
cpu_reset  . . . . . . . . . . .	L Near	 00D4	  UNIX	
cret . . . . . . . . . . . . . .	L Near	 1811	  UNIX	
crt_start  . . . . . . . . . . .	L Near	 2724	  UNIX	
csgmnt . . . . . . . . . . . . .	Number	 2000h	 
ctl_on . . . . . . . . . . . . .	L Near	 1F03	  UNIX	
ctrlbrk  . . . . . . . . . . . .	L Near	 0115	  UNIX	
ctty_ret . . . . . . . . . . . .	L Near	 17F7	  UNIX	
cttyp  . . . . . . . . . . . . .	L Near	 17E4	  UNIX	
ctty . . . . . . . . . . . . . .	L Near	 17D6	  UNIX	
cursor_posn  . . . . . . . . . .	L Near	 2726	  UNIX	
day  . . . . . . . . . . . . . .	L Near	 26FF	  UNIX	
dioreg . . . . . . . . . . . . .	L Near	 18C9	  UNIX	
diskio . . . . . . . . . . . . .	L Near	 19AE	  UNIX	
div32  . . . . . . . . . . . . .	L Near	 25DB	  UNIX	
do_fn  . . . . . . . . . . . . .	L Near	 1F32	  UNIX	
dparam_error . . . . . . . . . .	L Near	 1A81	  UNIX	
dparam . . . . . . . . . . . . .	L Near	 1A76	  UNIX	
drv_init_err . . . . . . . . . .	L Near	 1A4F	  UNIX	
drv_init_lbs . . . . . . . . . .	L Near	 1A39	  UNIX	
drv_init . . . . . . . . . . . .	L Near	 1A0B	  UNIX	
drverr . . . . . . . . . . . . .	L Near	 26C6	  UNIX	
drvhds . . . . . . . . . . . . .	L Near	 26DE	  UNIX	
drvpdn . . . . . . . . . . . . .	L Near	 26CC	  UNIX	
drvspt . . . . . . . . . . . . .	L Near	 26D2	  UNIX	
drv  . . . . . . . . . . . . . .	L Near	 26C6	  UNIX	
dskr_1 . . . . . . . . . . . . .	L Near	 13A3	  UNIX	
dskr_2 . . . . . . . . . . . . .	L Near	 13BD	  UNIX	
dskr_3 . . . . . . . . . . . . .	L Near	 13C8	  UNIX	
dskrd_0  . . . . . . . . . . . .	L Near	 18EE	  UNIX	
dskrd  . . . . . . . . . . . . .	L Near	 18E9	  UNIX	
dskr . . . . . . . . . . . . . .	L Near	 1389	  UNIX	
dskw_1 . . . . . . . . . . . . .	L Near	 14E7	  UNIX	
dskw_2 . . . . . . . . . . . . .	L Near	 14FE	  UNIX	
dskw_3 . . . . . . . . . . . . .	L Near	 1501	  UNIX	
dskw_4 . . . . . . . . . . . . .	L Near	 1516	  UNIX	
dskw_5 . . . . . . . . . . . . .	L Near	 1521	  UNIX	
dskwr  . . . . . . . . . . . . .	L Near	 191F	  UNIX	
dskw . . . . . . . . . . . . . .	L Near	 14CC	  UNIX	
ecore  . . . . . . . . . . . . .	Number	 7FC0h	 
ejec . . . . . . . . . . . . . .	L Near	 1817	  UNIX	
emt_1  . . . . . . . . . . . . .	L Near	 06E2	  UNIX	
emt_2  . . . . . . . . . . . . .	L Near	 06EB	  UNIX	
emt_iret . . . . . . . . . . . .	L Near	 06F0	  UNIX	
epoch  . . . . . . . . . . . . .	L Near	 240E	  UNIX	
error  . . . . . . . . . . . . .	L Near	 02F3	  UNIX	
etc_init_err_msg . . . . . . . .	L Near	 2873	  UNIX	
fclose_1 . . . . . . . . . . . .	L Near	 0BF8	  UNIX	
fclose_2 . . . . . . . . . . . .	L Near	 0BFC	  UNIX	
fclose . . . . . . . . . . . . .	L Near	 0BC9	  UNIX	
fd_init  . . . . . . . . . . . .	L Near	 1A0B	  UNIX	
find_position  . . . . . . . . .	L Near	 1C77	  UNIX	
free3  . . . . . . . . . . . . .	L Near	 115E	  UNIX	
free_1 . . . . . . . . . . . . .	L Near	 114C	  UNIX	
free_2 . . . . . . . . . . . . .	L Near	 1159	  UNIX	
free . . . . . . . . . . . . . .	L Near	 1146	  UNIX	
fspend . . . . . . . . . . . . .	Text   	 fsp+(nfiles*8)
fsp  . . . . . . . . . . . . . .	Text   	 SizeOfFile+2
g7 . . . . . . . . . . . . . . .	L Near	 1C2E	  UNIX	
gcw0 . . . . . . . . . . . . . .	L Near	 1AF1	  UNIX	
gcw1 . . . . . . . . . . . . . .	L Near	 1AF3	  UNIX	
gcw2 . . . . . . . . . . . . . .	L Near	 1B0F	  UNIX	
gcw3 . . . . . . . . . . . . . .	L Near	 1B1A	  UNIX	
get_cpos . . . . . . . . . . . .	L Near	 1D4B	  UNIX	
getc_n . . . . . . . . . . . . .	L Near	 1AC8	  UNIX	
getc_sn  . . . . . . . . . . . .	L Near	 1AEC	  UNIX	
getc_s . . . . . . . . . . . . .	L Near	 1AF1	  UNIX	
getc . . . . . . . . . . . . . .	L Near	 1AC4	  UNIX	
getf1  . . . . . . . . . . . . .	L Near	 0C00	  UNIX	
getf . . . . . . . . . . . . . .	L Near	 0BFE	  UNIX	
getspl_err . . . . . . . . . . .	L Near	 15E8	  UNIX	
getspl . . . . . . . . . . . . .	L Near	 1657	  UNIX	
gtty . . . . . . . . . . . . . .	L Near	 088A	  UNIX	
hd_init  . . . . . . . . . . . .	L Near	 1A1C	  UNIX	
hlt_sys  . . . . . . . . . . . .	L Near	 04B3	  UNIX	
hour . . . . . . . . . . . . . .	L Near	 2700	  UNIX	
icalc_1  . . . . . . . . . . . .	L Near	 1200	  UNIX	
icalc_2  . . . . . . . . . . . .	L Near	 121E	  UNIX	
icalc_3  . . . . . . . . . . . .	L Near	 1225	  UNIX	
icalc  . . . . . . . . . . . . .	L Near	 11E7	  UNIX	
iclose_0 . . . . . . . . . . . .	L Near	 17A0	  UNIX	
iclose_1 . . . . . . . . . . . .	L Near	 17B0	  UNIX	
iclose . . . . . . . . . . . . .	L Near	 1795	  UNIX	
idev . . . . . . . . . . . . . .	L Near	 26C0	  UNIX	
idle . . . . . . . . . . . . . .	L Near	 0FAA	  UNIX	
iget_1 . . . . . . . . . . . . .	L Near	 1198	  UNIX	
iget_2 . . . . . . . . . . . . .	L Near	 11BC	  UNIX	
iget_3 . . . . . . . . . . . . .	L Near	 11D3	  UNIX	
iget_4 . . . . . . . . . . . . .	L Near	 11E3	  UNIX	
iget . . . . . . . . . . . . . .	L Near	 1186	  UNIX	
ii . . . . . . . . . . . . . . .	L Near	 26BE	  UNIX	
imap . . . . . . . . . . . . . .	L Near	 12BC	  UNIX	
imod . . . . . . . . . . . . . .	L Near	 26F4	  UNIX	
init_argp  . . . . . . . . . . .	L Near	 00B2	  UNIX	
init_file  . . . . . . . . . . .	L Near	 00B6	  UNIX	
int09h . . . . . . . . . . . . .	L Near	 271C	  UNIX	
int_09h  . . . . . . . . . . . .	L Near	 1E0E	  UNIX	
int_16h  . . . . . . . . . . . .	L Near	 1D86	  UNIX	
intract  . . . . . . . . . . . .	L Near	 0426	  UNIX	
invscmsg1  . . . . . . . . . . .	L Near	 038A	  UNIX	
invscmsg2  . . . . . . . . . . .	L Near	 038E	  UNIX	
iopen_0  . . . . . . . . . . . .	L Near	 1671	  UNIX	
iopen_1  . . . . . . . . . . . .	L Near	 1681	  UNIX	
iopen_2  . . . . . . . . . . . .	L Near	 16A7	  UNIX	
iopen  . . . . . . . . . . . . .	L Near	 1667	  UNIX	
isdir  . . . . . . . . . . . . .	L Near	 098B	  UNIX	
isintr1  . . . . . . . . . . . .	L Near	 1073	  UNIX	
isintr2  . . . . . . . . . . . .	L Near	 1074	  UNIX	
isintr . . . . . . . . . . . . .	L Near	 1061	  UNIX	
isown_err  . . . . . . . . . . .	L Near	 0D64	  UNIX	
isown  . . . . . . . . . . . . .	L Near	 0D5A	  UNIX	
itrunc_1 . . . . . . . . . . . .	L Near	 1276	  UNIX	
itrunc_2 . . . . . . . . . . . .	L Near	 128C	  UNIX	
itrunc_3 . . . . . . . . . . . .	L Near	 1296	  UNIX	
itrunc_4 . . . . . . . . . . . .	L Near	 129E	  UNIX	
itrunc_5 . . . . . . . . . . . .	L Near	 12A2	  UNIX	
itrunc . . . . . . . . . . . . .	L Near	 1270	  UNIX	
i  . . . . . . . . . . . . . . .	L Near	 25EA	  UNIX	
k16a . . . . . . . . . . . . . .	L Near	 1F9B	  UNIX	
k16c . . . . . . . . . . . . . .	L Near	 1F8A	  UNIX	
k16  . . . . . . . . . . . . . .	L Near	 1E66	  UNIX	
k17c . . . . . . . . . . . . . .	L Near	 1FB8	  UNIX	
k17  . . . . . . . . . . . . . .	L Near	 1FAA	  UNIX	
k18  . . . . . . . . . . . . . .	L Near	 1FC4	  UNIX	
k1a  . . . . . . . . . . . . . .	L Near	 1DC5	  UNIX	
k1b  . . . . . . . . . . . . . .	L Near	 1D9C	  UNIX	
k1c  . . . . . . . . . . . . . .	L Near	 1DA8	  UNIX	
k1d  . . . . . . . . . . . . . .	L Near	 1DB1	  UNIX	
k1 . . . . . . . . . . . . . . .	L Near	 1DA6	  UNIX	
k20  . . . . . . . . . . . . . .	L Near	 1FE4	  UNIX	
k21  . . . . . . . . . . . . . .	L Near	 1FEA	  UNIX	
k22a0  . . . . . . . . . . . . .	L Near	 1FF7	  UNIX	
k22b . . . . . . . . . . . . . .	L Near	 2009	  UNIX	
k22  . . . . . . . . . . . . . .	L Near	 1FF1	  UNIX	
k23  . . . . . . . . . . . . . .	L Near	 2013	  UNIX	
k24  . . . . . . . . . . . . . .	L Near	 2032	  UNIX	
k25  . . . . . . . . . . . . . .	L Near	 203A	  UNIX	
k26  . . . . . . . . . . . . . .	L Near	 204E	  UNIX	
k27a . . . . . . . . . . . . . .	L Near	 2058	  UNIX	
k27  . . . . . . . . . . . . . .	L Near	 2053	  UNIX	
k28  . . . . . . . . . . . . . .	L Near	 2063	  UNIX	
k29  . . . . . . . . . . . . . .	L Near	 206A	  UNIX	
k2 . . . . . . . . . . . . . . .	L Near	 1DD5	  UNIX	
k31  . . . . . . . . . . . . . .	L Near	 208C	  UNIX	
k32  . . . . . . . . . . . . . .	L Near	 2095	  UNIX	
k33  . . . . . . . . . . . . . .	L Near	 20B1	  UNIX	
k34  . . . . . . . . . . . . . .	L Near	 20C2	  UNIX	
k35  . . . . . . . . . . . . . .	L Near	 20D2	  UNIX	
k36  . . . . . . . . . . . . . .	L Near	 20D6	  UNIX	
k37  . . . . . . . . . . . . . .	L Near	 20D9	  UNIX	
k38  . . . . . . . . . . . . . .	L Near	 20E3	  UNIX	
k39  . . . . . . . . . . . . . .	L Near	 210B	  UNIX	
k3 . . . . . . . . . . . . . . .	L Near	 1DFB	  UNIX	
k40p . . . . . . . . . . . . . .	L Near	 2131	  UNIX	
k40  . . . . . . . . . . . . . .	L Near	 2132	  UNIX	
k41  . . . . . . . . . . . . . .	L Near	 213C	  UNIX	
k42  . . . . . . . . . . . . . .	L Near	 2146	  UNIX	
k44  . . . . . . . . . . . . . .	L Near	 2153	  UNIX	
k45  . . . . . . . . . . . . . .	L Near	 2167	  UNIX	
k46  . . . . . . . . . . . . . .	L Near	 2177	  UNIX	
k47  . . . . . . . . . . . . . .	L Near	 2181	  UNIX	
k48  . . . . . . . . . . . . . .	L Near	 2186	  UNIX	
k49  . . . . . . . . . . . . . .	L Near	 2194	  UNIX	
k4 . . . . . . . . . . . . . . .	L Near	 1E01	  UNIX	
k50  . . . . . . . . . . . . . .	L Near	 21A3	  UNIX	
k51  . . . . . . . . . . . . . .	L Near	 21A8	  UNIX	
k52  . . . . . . . . . . . . . .	L Near	 21AD	  UNIX	
k53  . . . . . . . . . . . . . .	L Near	 21B4	  UNIX	
k54  . . . . . . . . . . . . . .	L Near	 21BB	  UNIX	
k55  . . . . . . . . . . . . . .	L Near	 21C3	  UNIX	
k56  . . . . . . . . . . . . . .	L Near	 21C6	  UNIX	
k57  . . . . . . . . . . . . . .	L Near	 21C9	  UNIX	
k58  . . . . . . . . . . . . . .	L Near	 21D2	  UNIX	
k59  . . . . . . . . . . . . . .	L Near	 21EC	  UNIX	
k5 . . . . . . . . . . . . . . .	L Near	 1E0D	  UNIX	
k60  . . . . . . . . . . . . . .	L Near	 21EF	  UNIX	
k61  . . . . . . . . . . . . . .	L Near	 21F9	  UNIX	
k62  . . . . . . . . . . . . . .	L Near	 2224	  UNIX	
k63  . . . . . . . . . . . . . .	L Near	 221B	  UNIX	
k64  . . . . . . . . . . . . . .	L Near	 221D	  UNIX	
kb_init  . . . . . . . . . . . .	L Near	 00E9	  UNIX	
kb_int_01  . . . . . . . . . . .	L Near	 1E27	  UNIX	
kb_int_02  . . . . . . . . . . .	L Near	 1E2F	  UNIX	
kb_int_03  . . . . . . . . . . .	L Near	 1E41	  UNIX	
kb_int_04  . . . . . . . . . . .	L Near	 1E4A	  UNIX	
kb_int_1 . . . . . . . . . . . .	L Near	 0185	  UNIX	
kb_int_2 . . . . . . . . . . . .	L Near	 0196	  UNIX	
kb_int_3 . . . . . . . . . . . .	L Near	 0198	  UNIX	
kb_int_4 . . . . . . . . . . . .	L Near	 019E	  UNIX	
kb_int . . . . . . . . . . . . .	L Near	 0147	  UNIX	
kernel_init_err_msg  . . . . . .	L Near	 27E4	  UNIX	
kernel_init_err  . . . . . . . .	L Near	 002C	  UNIX	
kernel_init_ok_msg . . . . . . .	L Near	 2807	  UNIX	
kernel_init  . . . . . . . . . .	L Near	 0000	  UNIX	
key_to_reboot  . . . . . . . . .	L Near	 00C6	  UNIX	
lpr_stat . . . . . . . . . . . .	L Near	 14AF	  UNIX	
lpt_init_ok  . . . . . . . . . .	L Near	 1828	  UNIX	
lpt_init . . . . . . . . . . . .	L Near	 1817	  UNIX	
m16  . . . . . . . . . . . . . .	L Near	 1BEA	  UNIX	
m17  . . . . . . . . . . . . . .	L Near	 1C05	  UNIX	
m18  . . . . . . . . . . . . . .	L Near	 1BDD	  UNIX	
make_led . . . . . . . . . . . .	L Near	 22BF	  UNIX	
maknod . . . . . . . . . . . . .	L Near	 0DE9	  UNIX	
mdev . . . . . . . . . . . . . .	L Near	 26C5	  UNIX	
mget_0 . . . . . . . . . . . . .	L Near	 1075	  UNIX	
mget_1 . . . . . . . . . . . . .	L Near	 10A3	  UNIX	
mget_2 . . . . . . . . . . . . .	L Near	 10A4	  UNIX	
mget_3 . . . . . . . . . . . . .	L Near	 10B5	  UNIX	
mget_4 . . . . . . . . . . . . .	L Near	 10BD	  UNIX	
mget_5 . . . . . . . . . . . . .	L Near	 10D0	  UNIX	
mget_6 . . . . . . . . . . . . .	L Near	 10E7	  UNIX	
mget_7 . . . . . . . . . . . . .	L Near	 1108	  UNIX	
mget . . . . . . . . . . . . . .	L Near	 1075	  UNIX	
minute . . . . . . . . . . . . .	L Near	 2701	  UNIX	
mkdir_1  . . . . . . . . . . . .	L Near	 09E7	  UNIX	
mkdir_2  . . . . . . . . . . . .	L Near	 0A03	  UNIX	
mkdir_w  . . . . . . . . . . . .	L Near	 26FA	  UNIX	
mkdir  . . . . . . . . . . . . .	L Near	 09D5	  UNIX	
mmod . . . . . . . . . . . . . .	L Near	 26F6	  UNIX	
mnti . . . . . . . . . . . . . .	L Near	 26EC	  UNIX	
mntp . . . . . . . . . . . . . .	L Near	 288E	  UNIX	
month  . . . . . . . . . . . . .	L Near	 26FE	  UNIX	
mount  . . . . . . . . . . . . .	Text   	 sb1+4
mpid . . . . . . . . . . . . . .	L Near	 26EE	  UNIX	
mul32  . . . . . . . . . . . . .	L Near	 24FD	  UNIX	
n0 . . . . . . . . . . . . . . .	L Near	 1CB3	  UNIX	
n10  . . . . . . . . . . . . . .	L Near	 1CDD	  UNIX	
n11  . . . . . . . . . . . . . .	L Near	 1CE8	  UNIX	
n1 . . . . . . . . . . . . . . .	L Near	 1CB7	  UNIX	
n3 . . . . . . . . . . . . . . .	L Near	 1CE4	  UNIX	
n5 . . . . . . . . . . . . . . .	L Near	 1CEA	  UNIX	
n8 . . . . . . . . . . . . . . .	L Near	 1CBA	  UNIX	
n9 . . . . . . . . . . . . . . .	L Near	 1CC4	  UNIX	
n_hld1 . . . . . . . . . . . . .	L Near	 1F40	  UNIX	
n_hld  . . . . . . . . . . . . .	L Near	 1ED2	  UNIX	
namei_1  . . . . . . . . . . . .	L Near	 0C55	  UNIX	
namei_2  . . . . . . . . . . . .	L Near	 0C60	  UNIX	
namei_3  . . . . . . . . . . . .	L Near	 0C80	  UNIX	
namei_4  . . . . . . . . . . . .	L Near	 0CB5	  UNIX	
namei_5  . . . . . . . . . . . .	L Near	 0CC4	  UNIX	
namei_6  . . . . . . . . . . . .	L Near	 0CDA	  UNIX	
namei_7  . . . . . . . . . . . .	L Near	 0CE8	  UNIX	
namei_8  . . . . . . . . . . . .	L Near	 0D1B	  UNIX	
namei_r  . . . . . . . . . . . .	L Near	 26F9	  UNIX	
namei  . . . . . . . . . . . . .	L Near	 0C2D	  UNIX	
nbuf . . . . . . . . . . . . . .	Number	 0008h	 
nfiles . . . . . . . . . . . . .	Number	 0032h	 
nib  . . . . . . . . . . . . . .	L Near	 0CB1	  UNIX	
nig  . . . . . . . . . . . . . .	L Near	 0CB4	  UNIX	
not_alt  . . . . . . . . . . . .	L Near	 1EE7	  UNIX	
not_cur  . . . . . . . . . . . .	L Near	 1F18	  UNIX	
not_id . . . . . . . . . . . . .	L Near	 1EA4	  UNIX	
not_i  . . . . . . . . . . . . .	L Near	 1EB9	  UNIX	
not_lc_hc  . . . . . . . . . . .	L Near	 1F0B	  UNIX	
nproc  . . . . . . . . . . . . .	Number	 0010h	 
ntty . . . . . . . . . . . . . .	Number	 0008h	 
ocvt . . . . . . . . . . . . . .	L Near	 16C4	  UNIX	
op0  . . . . . . . . . . . . . .	L Near	 0629	  UNIX	
otty_err . . . . . . . . . . . .	L Near	 1713	  UNIX	
otty_ret . . . . . . . . . . . .	L Near	 16F2	  UNIX	
ottyp  . . . . . . . . . . . . .	L Near	 16C6	  UNIX	
ottys_ret  . . . . . . . . . . .	L Near	 1776	  UNIX	
ottys_rtn  . . . . . . . . . . .	L Near	 177E	  UNIX	
ottys  . . . . . . . . . . . . .	L Near	 16F7	  UNIX	
otty . . . . . . . . . . . . . .	L Near	 16B8	  UNIX	
p11  . . . . . . . . . . . . . .	L Near	 1D59	  UNIX	
p12  . . . . . . . . . . . . . .	L Near	 1D66	  UNIX	
p13  . . . . . . . . . . . . . .	L Near	 1D6B	  UNIX	
p20  . . . . . . . . . . . . . .	L Near	 1C87	  UNIX	
p21  . . . . . . . . . . . . . .	L Near	 1C8D	  UNIX	
p41  . . . . . . . . . . . . . .	L Near	 1CFE	  UNIX	
p42  . . . . . . . . . . . . . .	L Near	 1D0F	  UNIX	
p43  . . . . . . . . . . . . . .	L Near	 1D14	  UNIX	
p44  . . . . . . . . . . . . . .	L Near	 1D14	  UNIX	
p_kernel_init_err  . . . . . . .	L Near	 00AD	  UNIX	
p_time . . . . . . . . . . . . .	L Near	 2720	  UNIX	
panic_msg  . . . . . . . . . . .	L Near	 2858	  UNIX	
panic  . . . . . . . . . . . . .	L Near	 00C0	  UNIX	
passc  . . . . . . . . . . . . .	L Near	 13D4	  UNIX	
poke . . . . . . . . . . . . . .	L Near	 1923	  UNIX	
position . . . . . . . . . . . .	L Near	 1C66	  UNIX	
ppoke  . . . . . . . . . . . . .	L Near	 1923	  UNIX	
pr_err_exit  . . . . . . . . . .	L Near	 1497	  UNIX	
pr_exit  . . . . . . . . . . . .	L Near	 14AD	  UNIX	
preread  . . . . . . . . . . . .	L Near	 1858	  UNIX	
print_msg_int10h . . . . . . . .	L Near	 0094	  UNIX	
print_msg  . . . . . . . . . . .	L Near	 00D9	  UNIX	
prnop_chk_nrdy . . . . . . . . .	L Near	 14C8	  UNIX	
ptty . . . . . . . . . . . . . .	L Near	 2736	  UNIX	
putc . . . . . . . . . . . . . .	L Near	 1B5F	  UNIX	
putlu_1  . . . . . . . . . . . .	L Near	 0F9C	  UNIX	
putlu_2  . . . . . . . . . . . .	L Near	 0F9F	  UNIX	
putlu  . . . . . . . . . . . . .	L Near	 0F86	  UNIX	
p  . . . . . . . . . . . . . . .	L Near	 260A	  UNIX	
rcvt . . . . . . . . . . . . . .	L Near	 1371	  UNIX	
rdev . . . . . . . . . . . . . .	L Near	 26C4	  UNIX	
read_ac_current  . . . . . . . .	L Near	 1D56	  UNIX	
readi  . . . . . . . . . . . . .	L Near	 12F3	  UNIX	
ret_ . . . . . . . . . . . . . .	L Near	 1384	  UNIX	
rfd  . . . . . . . . . . . . . .	L Near	 182A	  UNIX	
rhd  . . . . . . . . . . . . . .	L Near	 1836	  UNIX	
rlpr . . . . . . . . . . . . . .	L Near	 1386	  UNIX	
rmem . . . . . . . . . . . . . .	L Near	 1375	  UNIX	
rootdir  . . . . . . . . . . . .	L Near	 26F0	  UNIX	
rst_rd_id  . . . . . . . . . . .	L Near	 1E7B	  UNIX	
rswap  . . . . . . . . . . . . .	L Near	 0F60	  UNIX	
rtty_idle  . . . . . . . . . . .	L Near	 1362	  UNIX	
rtty_nc  . . . . . . . . . . . .	L Near	 134B	  UNIX	
rttys  . . . . . . . . . . . . .	L Near	 1343	  UNIX	
rtty . . . . . . . . . . . . . .	L Near	 1339	  UNIX	
runq . . . . . . . . . . . . . .	L Near	 26F2	  UNIX	
rw0  . . . . . . . . . . . . . .	L Near	 05F8	  UNIX	
rw1  . . . . . . . . . . . . . .	L Near	 0601	  UNIX	
rw_error . . . . . . . . . . . .	L Near	 05F0	  UNIX	
rw . . . . . . . . . . . . . . .	L Near	 26F8	  UNIX	
s10  . . . . . . . . . . . . . .	L Near	 22D1	  UNIX	
sb0  . . . . . . . . . . . . . .	Text   	 fspend+2
sb1  . . . . . . . . . . . . . .	Text   	 systm+512
scroll_up  . . . . . . . . . . .	L Near	 1C9A	  UNIX	
sd0  . . . . . . . . . . . . . .	L Near	 223A	  UNIX	
sd1  . . . . . . . . . . . . . .	L Near	 2242	  UNIX	
sd3  . . . . . . . . . . . . . .	L Near	 224F	  UNIX	
sd5  . . . . . . . . . . . . . .	L Near	 2258	  UNIX	
sd7  . . . . . . . . . . . . . .	L Near	 2263	  UNIX	
sd9  . . . . . . . . . . . . . .	L Near	 226A	  UNIX	
sdsegmnt . . . . . . . . . . . .	Number	 06C0h	 
second . . . . . . . . . . . . .	L Near	 2702	  UNIX	
seektell0  . . . . . . . . . . .	L Near	 0E59	  UNIX	
seektell_1 . . . . . . . . . . .	L Near	 0E85	  UNIX	
seektell . . . . . . . . . . . .	L Near	 0E55	  UNIX	
segm_sw  . . . . . . . . . . . .	L Near	 05C9	  UNIX	
set_cpos . . . . . . . . . . . .	L Near	 1BCA	  UNIX	
set_date_time  . . . . . . . . .	L Near	 2511	  UNIX	
set_date . . . . . . . . . . . .	L Near	 259B	  UNIX	
set_fn . . . . . . . . . . . . .	L Near	 1F64	  UNIX	
set_time . . . . . . . . . . . .	L Near	 25B7	  UNIX	
seta . . . . . . . . . . . . . .	L Near	 1934	  UNIX	
setimod  . . . . . . . . . . . .	L Near	 124B	  UNIX	
ship_it  . . . . . . . . . . . .	L Near	 22CD	  UNIX	
sioreg . . . . . . . . . . . . .	L Near	 155B	  UNIX	
sk2  . . . . . . . . . . . . . .	L Near	 1DF3	  UNIX	
sl3  . . . . . . . . . . . . . .	L Near	 228E	  UNIX	
sl5  . . . . . . . . . . . . . .	L Near	 22B2	  UNIX	
sl7  . . . . . . . . . . . . . .	L Near	 22B8	  UNIX	
sl9  . . . . . . . . . . . . . .	L Near	 22BD	  UNIX	
sleep  . . . . . . . . . . . . .	L Near	 102E	  UNIX	
smod . . . . . . . . . . . . . .	L Near	 26F5	  UNIX	
snd_data . . . . . . . . . . . .	L Near	 2233	  UNIX	
snd_led1 . . . . . . . . . . . .	L Near	 2281	  UNIX	
snd_led  . . . . . . . . . . . .	L Near	 226E	  UNIX	
sndcs  . . . . . . . . . . . . .	L Near	 1B26	  UNIX	
sndc . . . . . . . . . . . . . .	L Near	 1B1E	  UNIX	
sp_init  . . . . . . . . . . . .	L Near	 01F8	  UNIX	
sret . . . . . . . . . . . . . .	L Near	 178F	  UNIX	
sstack . . . . . . . . . . . . .	Text   	 BSSEND+256-64
swap_0 . . . . . . . . . . . . .	L Near	 0EF2	  UNIX	
swap_1 . . . . . . . . . . . . .	L Near	 0EF5	  UNIX	
swap_2 . . . . . . . . . . . . .	L Near	 0F00	  UNIX	
swap_3 . . . . . . . . . . . . .	L Near	 0F10	  UNIX	
swap_4 . . . . . . . . . . . . .	L Near	 0F14	  UNIX	
swap_5 . . . . . . . . . . . . .	L Near	 0F27	  UNIX	
swap_6 . . . . . . . . . . . . .	L Near	 0F33	  UNIX	
swap . . . . . . . . . . . . . .	L Near	 0EF2	  UNIX	
sysbreak_0 . . . . . . . . . . .	L Near	 0DD5	  UNIX	
sysbreak_1 . . . . . . . . . . .	L Near	 0DDB	  UNIX	
sysbreak_2 . . . . . . . . . . .	L Near	 0DDE	  UNIX	
sysbreak_3 . . . . . . . . . . .	L Near	 0DE2	  UNIX	
sysbreak . . . . . . . . . . . .	L Near	 0DBD	  UNIX	
syscalls . . . . . . . . . . . .	L Near	 02AD	  UNIX	
syschdir_err . . . . . . . . . .	L Near	 0D2D	  UNIX	
syschdir . . . . . . . . . . . .	L Near	 0D24	  UNIX	
syschmod . . . . . . . . . . . .	L Near	 0D48	  UNIX	
syschown . . . . . . . . . . . .	L Near	 0D7C	  UNIX	
sysclose . . . . . . . . . . . .	L Near	 06BE	  UNIX	
syscreat . . . . . . . . . . . .	L Near	 067A	  UNIX	
sysemt . . . . . . . . . . . . .	L Near	 06C8	  UNIX	
sysent . . . . . . . . . . . . .	L Near	 025A	  UNIX	
sysexec_10 . . . . . . . . . . .	L Near	 0B69	  UNIX	
sysexec_1  . . . . . . . . . . .	L Near	 0A58	  UNIX	
sysexec_2  . . . . . . . . . . .	L Near	 0A72	  UNIX	
sysexec_3  . . . . . . . . . . .	L Near	 0A7C	  UNIX	
sysexec_4  . . . . . . . . . . .	L Near	 0A84	  UNIX	
sysexec_5  . . . . . . . . . . .	L Near	 0A8D	  UNIX	
sysexec_6  . . . . . . . . . . .	L Near	 0AA2	  UNIX	
sysexec_7  . . . . . . . . . . .	L Near	 0AAD	  UNIX	
sysexec_8  . . . . . . . . . . .	L Near	 0ABD	  UNIX	
sysexec_9  . . . . . . . . . . .	L Near	 0B66	  UNIX	
sysexec  . . . . . . . . . . . .	L Near	 0A25	  UNIX	
sysexit_1  . . . . . . . . . . .	L Near	 043C	  UNIX	
sysexit_2  . . . . . . . . . . .	L Near	 045D	  UNIX	
sysexit_3  . . . . . . . . . . .	L Near	 0473	  UNIX	
sysexit_4  . . . . . . . . . . .	L Near	 0475	  UNIX	
sysexit_5  . . . . . . . . . . .	L Near	 047D	  UNIX	
sysexit_6  . . . . . . . . . . .	L Near	 04AB	  UNIX	
sysexit  . . . . . . . . . . . .	L Near	 0438	  UNIX	
sysflg . . . . . . . . . . . . .	L Near	 26F7	  UNIX	
sysfork_1  . . . . . . . . . . .	L Near	 050B	  UNIX	
sysfork_2  . . . . . . . . . . .	L Near	 051B	  UNIX	
sysfork_3  . . . . . . . . . . .	L Near	 0540	  UNIX	
sysfork_4  . . . . . . . . . . .	L Near	 05AE	  UNIX	
sysfork_5  . . . . . . . . . . .	L Near	 05C2	  UNIX	
sysfork  . . . . . . . . . . . .	L Near	 0509	  UNIX	
sysfstat . . . . . . . . . . . .	L Near	 0B84	  UNIX	
sysgetuid  . . . . . . . . . . .	L Near	 0EB1	  UNIX	
sysgtty_0  . . . . . . . . . . .	L Near	 088A	  UNIX	
sysgtty_1  . . . . . . . . . . .	L Near	 08BE	  UNIX	
sysgtty_2  . . . . . . . . . . .	L Near	 08CA	  UNIX	
sysgtty_3  . . . . . . . . . . .	L Near	 08D4	  UNIX	
sysgtty_4  . . . . . . . . . . .	L Near	 08D6	  UNIX	
sysgtty_5  . . . . . . . . . . .	L Near	 08E9	  UNIX	
sysgtty_6  . . . . . . . . . . .	L Near	 0910	  UNIX	
sysgtty_7  . . . . . . . . . . .	L Near	 0927	  UNIX	
sysgtty_8  . . . . . . . . . . .	L Near	 092B	  UNIX	
sysgtty_9  . . . . . . . . . . .	L Near	 093A	  UNIX	
sysgtty  . . . . . . . . . . . .	L Near	 088A	  UNIX	
sysilgins  . . . . . . . . . . .	L Near	 06F1	  UNIX	
sysintr  . . . . . . . . . . . .	L Near	 0E88	  UNIX	
syslink  . . . . . . . . . . . .	L Near	 094D	  UNIX	
sysmdate_err . . . . . . . . . .	L Near	 071B	  UNIX	
sysmdate . . . . . . . . . . . .	L Near	 06F4	  UNIX	
sysmkdir . . . . . . . . . . . .	L Near	 069A	  UNIX	
sysmount_err . . . . . . . . . .	L Near	 15E8	  UNIX	
sysmount_sbrd_err  . . . . . . .	L Near	 15DE	  UNIX	
sysmount . . . . . . . . . . . .	L Near	 1588	  UNIX	
sysopen  . . . . . . . . . . . .	L Near	 060C	  UNIX	
sysquit  . . . . . . . . . . . .	L Near	 0E8F	  UNIX	
sysread  . . . . . . . . . . . .	L Near	 05DB	  UNIX	
sysrelease . . . . . . . . . . .	L Near	 0351	  UNIX	
sysrele  . . . . . . . . . . . .	L Near	 034A	  UNIX	
sysret . . . . . . . . . . . . .	L Near	 0310	  UNIX	
sysseek  . . . . . . . . . . . .	L Near	 0E3B	  UNIX	
syssetuid  . . . . . . . . . . .	L Near	 0E99	  UNIX	
syssleep . . . . . . . . . . . .	L Near	 1D76	  UNIX	
sysstat  . . . . . . . . . . . .	L Near	 0B98	  UNIX	
sysstime . . . . . . . . . . . .	L Near	 0DA9	  UNIX	
sysstty_0  . . . . . . . . . . .	L Near	 0767	  UNIX	
sysstty_10 . . . . . . . . . . .	L Near	 0854	  UNIX	
sysstty_11 . . . . . . . . . . .	L Near	 0865	  UNIX	
sysstty_12 . . . . . . . . . . .	L Near	 07BB	  UNIX	
sysstty_13 . . . . . . . . . . .	L Near	 0867	  UNIX	
sysstty_14 . . . . . . . . . . .	L Near	 0870	  UNIX	
sysstty_16 . . . . . . . . . . .	L Near	 083F	  UNIX	
sysstty_17 . . . . . . . . . . .	L Near	 0836	  UNIX	
sysstty_18 . . . . . . . . . . .	L Near	 079D	  UNIX	
sysstty_1  . . . . . . . . . . .	L Near	 077A	  UNIX	
sysstty_2  . . . . . . . . . . .	L Near	 077C	  UNIX	
sysstty_3  . . . . . . . . . . .	L Near	 07B3	  UNIX	
sysstty_4  . . . . . . . . . . .	L Near	 07CA	  UNIX	
sysstty_5  . . . . . . . . . . .	L Near	 07D4	  UNIX	
sysstty_6  . . . . . . . . . . .	L Near	 07EB	  UNIX	
sysstty_7  . . . . . . . . . . .	L Near	 0805	  UNIX	
sysstty_8  . . . . . . . . . . .	L Near	 0813	  UNIX	
sysstty_9  . . . . . . . . . . .	L Near	 0846	  UNIX	
sysstty_err_s  . . . . . . . . .	L Near	 0790	  UNIX	
sysstty_error  . . . . . . . . .	L Near	 078D	  UNIX	
sysstty_err  . . . . . . . . . .	L Near	 071B	  UNIX	
sysstty  . . . . . . . . . . . .	L Near	 071E	  UNIX	
systell  . . . . . . . . . . . .	L Near	 0E47	  UNIX	
systime  . . . . . . . . . . . .	L Near	 0D96	  UNIX	
systm  . . . . . . . . . . . . .	Text   	 sb0+4
sysumnt_2  . . . . . . . . . . .	L Near	 1626	  UNIX	
sysumnt_3  . . . . . . . . . . .	L Near	 162D	  UNIX	
sysumount_err  . . . . . . . . .	L Near	 15E8	  UNIX	
sysumount  . . . . . . . . . . .	L Near	 15EB	  UNIX	
sysunlink  . . . . . . . . . . .	L Near	 09A5	  UNIX	
syswait_0  . . . . . . . . . . .	L Near	 04B6	  UNIX	
syswait_1  . . . . . . . . . . .	L Near	 04C6	  UNIX	
syswait_2  . . . . . . . . . . .	L Near	 04EA	  UNIX	
syswait_3  . . . . . . . . . . .	L Near	 04EC	  UNIX	
syswait  . . . . . . . . . . . .	L Near	 04B6	  UNIX	
syswrite . . . . . . . . . . . .	L Near	 05E8	  UNIX	
t_ctl  . . . . . . . . . . . . .	L Near	 1F4E	  UNIX	
t_f12  . . . . . . . . . . . . .	L Near	 1F2B	  UNIX	
t_shf  . . . . . . . . . . . . .	L Near	 1F5A	  UNIX	
t_sys_key  . . . . . . . . . . .	L Near	 1F69	  UNIX	
time_count . . . . . . . . . . .	Number	 0004h	 
tsleep . . . . . . . . . . . . .	L Near	 2798	  UNIX	
tst_id_2 . . . . . . . . . . . .	L Near	 1E83	  UNIX	
tswap  . . . . . . . . . . . . .	L Near	 0EEC	  UNIX	
ts . . . . . . . . . . . . . . .	L Near	 1BB3	  UNIX	
tty_sw . . . . . . . . . . . . .	L Near	 1D21	  UNIX	
ttychr . . . . . . . . . . . . .	L Near	 2766	  UNIX	
ttyl . . . . . . . . . . . . . .	L Near	 277A	  UNIX	
u0 . . . . . . . . . . . . . . .	L Near	 1B74	  UNIX	
u10  . . . . . . . . . . . . . .	L Near	 1B82	  UNIX	
u11  . . . . . . . . . . . . . .	L Near	 1C07	  UNIX	
u1 . . . . . . . . . . . . . . .	L Near	 1B87	  UNIX	
u2 . . . . . . . . . . . . . . .	L Near	 1B8A	  UNIX	
u3 . . . . . . . . . . . . . . .	L Near	 1B8F	  UNIX	
u6 . . . . . . . . . . . . . . .	L Near	 1B94	  UNIX	
u8 . . . . . . . . . . . . . . .	L Near	 1B98	  UNIX	
u9 . . . . . . . . . . . . . . .	L Near	 1BC8	  UNIX	
unixbootdrive  . . . . . . . . .	L Near	 25E8	  UNIX	
unkni  . . . . . . . . . . . . .	L Near	 025A	  UNIX	
up0  . . . . . . . . . . . . . .	L Near	 1E5C	  UNIX	
u  . . . . . . . . . . . . . . .	L Near	 27A4	  UNIX	
waitf1 . . . . . . . . . . . . .	L Near	 1C58	  UNIX	
waitf  . . . . . . . . . . . . .	L Near	 1C57	  UNIX	
wakeup . . . . . . . . . . . . .	L Near	 1010	  UNIX	
wdir . . . . . . . . . . . . . .	L Near	 0A0A	  UNIX	
wfd  . . . . . . . . . . . . . .	L Near	 1830	  UNIX	
whd  . . . . . . . . . . . . . .	L Near	 183C	  UNIX	
wlist  . . . . . . . . . . . . .	L Near	 278E	  UNIX	
wlpr . . . . . . . . . . . . . .	L Near	 1485	  UNIX	
wmem . . . . . . . . . . . . . .	L Near	 1474	  UNIX	
wret . . . . . . . . . . . . . .	L Near	 146C	  UNIX	
write_c_current  . . . . . . . .	L Near	 1CF9	  UNIX	
write_tty  . . . . . . . . . . .	L Near	 1B64	  UNIX	
writei . . . . . . . . . . . . .	L Near	 13F2	  UNIX	
wslot  . . . . . . . . . . . . .	L Near	 1914	  UNIX	
wswap  . . . . . . . . . . . . .	L Near	 0F39	  UNIX	
wtty_nc  . . . . . . . . . . . .	L Near	 1454	  UNIX	
wttyc  . . . . . . . . . . . . .	L Near	 0870	  UNIX	
wttys  . . . . . . . . . . . . .	L Near	 144B	  UNIX	
wtty . . . . . . . . . . . . . .	L Near	 143F	  UNIX	
xmtt . . . . . . . . . . . . . .	L Near	 146E	  UNIX	
year . . . . . . . . . . . . . .	L Near	 26FC	  UNIX	

	   0 Warnings
	   0 Errors
